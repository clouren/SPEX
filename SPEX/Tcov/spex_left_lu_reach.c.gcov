        -:    0:Source:spex_left_lu_reach.c
        -:    0:Graph:spex_left_lu_reach.gcno
        -:    0:Data:spex_left_lu_reach.gcda
        -:    0:Runs:6
        -:    1://------------------------------------------------------------------------------
        -:    2:// SPEX_Left_LU/spex_left_lu_reach: compute the set of nodes reachable from an input set
        -:    3://------------------------------------------------------------------------------
        -:    4:
        -:    5:// SPEX_Left_LU: (c) 2019-2021, Chris Lourenco (US Naval Academy), Jinhao Chen,
        -:    6:// Erick Moreno-Centeno, Timothy A. Davis, Texas A&M.  All Rights Reserved.
        -:    7:// SPDX-License-Identifier: GPL-2.0-or-later or LGPL-3.0-or-later
        -:    8:
        -:    9://------------------------------------------------------------------------------
        -:   10:
        -:   11:#include "spex_left_lu_internal.h"
        -:   12:
        -:   13:/* Purpose: This function computes the reach of column k of A on the graph of L
        -:   14: * mathematically that is: xi = Reach(A(:,k))_G_L
        -:   15: *
        -:   16: * This function is derived from CSparse/cs_reach.c
        -:   17: */
        -:   18:
     3645:   19:void spex_left_lu_reach    // compute the reach of column k of A on the graph of L
        -:   20:(
        -:   21:    int64_t *top,
        -:   22:    SPEX_matrix* L,         // matrix representing graph of L
        -:   23:    const SPEX_matrix* A,   // input matrix
        -:   24:    int64_t k,              // column of A of interest
        -:   25:    int64_t* xi,            // nonzero pattern
        -:   26:    const int64_t* pinv     // row permutation
        -:   27:)
        -:   28:{
        -:   29:
        -:   30:    //--------------------------------------------------------------------------
        -:   31:    // check inputs
        -:   32:    //--------------------------------------------------------------------------
    3645*:   33:    if (top == NULL) { return ;}
        -:   34:    // inputs have been checked in spex_ref_triangular_solve
     3645:   35:    int64_t p, n = L->n;
     3645:   36:    *top = n;
        -:   37:
        -:   38:    //--------------------------------------------------------------------------
        -:   39:    // Iterating across number of nonzero in column k
        -:   40:    //--------------------------------------------------------------------------
        -:   41:
    15200:   42:    for (p = A->p[k]; p < A->p[k + 1]; p++)
        -:   43:    {
        -:   44:        // DFS at unmarked node i
    11555:   45:        if (!SPEX_MARKED(L->p, A->i[p]))
        -:   46:        {
     9705:   47:            spex_left_lu_dfs(top, A->i[p], L, xi, xi+n, pinv);
        -:   48:        }
        -:   49:    }
        -:   50:
        -:   51:    // Restore L
    43599:   52:    for ( p = *top; p < n; p++)
        -:   53:    {
    39954:   54:        SPEX_MARK(L->p, xi[p]);
        -:   55:    }
        -:   56:}
        -:   57:
