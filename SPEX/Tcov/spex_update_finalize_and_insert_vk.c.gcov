        -:    0:Source:spex_update_finalize_and_insert_vk.c
        -:    0:Graph:spex_update_finalize_and_insert_vk.gcno
        -:    0:Data:spex_update_finalize_and_insert_vk.gcda
        -:    0:Runs:3
        -:    1://------------------------------------------------------------------------------
        -:    2:// SPEX_Update/spex_update_finalize_and_insert_vk.c: perform history update for
        -:    3:// entries that would be in L and insert entries that would in U to
        -:    4:// corresponding row of U.
        -:    5://------------------------------------------------------------------------------
        -:    6:
        -:    7:// SPEX_Update: (c) 2020-2021, Jinhao Chen, Timothy A. Davis, Erick
        -:    8:// Moreno-Centeno, Texas A&M University.  All Rights Reserved.  See
        -:    9:// SPEX_Update/License for the license.
        -:   10:
        -:   11://------------------------------------------------------------------------------
        -:   12:
        -:   13:// Purpose: This function is called to perform history update for entries that
        -:   14:// would be in L and insert entries that would in U to corresponding row of U.
        -:   15:// Entries that would appear in U are removed from the nnz pattern, while
        -:   16:// entries that would be in L are updated and moved from vk_dense. The pivot
        -:   17:// entry is kept as the first entry in L->v[k] but not inserted to U.
        -:   18:
        -:   19:#include "spex_update_internal.h"
        -:   20:
    10507:   21:SPEX_info spex_update_finalize_and_insert_vk
        -:   22:(
        -:   23:    spex_scattered_vector *vk_dense, //scattered version of the solution for
        -:   24:                      // LDx=v using the first k-1 columns of L
        -:   25:    int64_t *h,       // history vector for vk_dense
        -:   26:    SPEX_matrix *U,      // matrix U
        -:   27:    SPEX_matrix *L,      // matrix L
        -:   28:    const SPEX_matrix *rhos,// array of scaled pivots
        -:   29:    const int64_t *Q, // the column permutation
        -:   30:    const int64_t *P_inv,// inverse of row permutation
        -:   31:    const int64_t k,  // the column index in L that vk_dense will be inserted
        -:   32:    const int64_t diag,// the index of entry in vk_dense that will be diagonal
        -:   33:    const SPEX_options *option
        -:   34:)
        -:   35:{
        -:   36:    SPEX_info info;
    10507:   37:    int64_t i, p = 0, real_i, vk_nz = vk_dense->nz, Lk_nz;
        -:   38:    int sgn;
    10507:   39:    mpz_t *sd = rhos->x.mpz;
        -:   40:
        -:   41:    // move entries to U
    57317:   42:    while(p < vk_nz)
        -:   43:    {
    46878:   44:        i = vk_dense->i[p];
    46878:   45:        real_i = P_inv[i];
    46878:   46:        if (real_i < k)
        -:   47:        {
   29603*:   48:            SPEX_CHECK(SPEX_mpz_sgn(&sgn, vk_dense->x[i]));
    29603:   49:            if (sgn != 0)
        -:   50:            {
        -:   51:                // insert vk_dense->x[i] to U(P_inv[i],Q[k]) by swapping
    22924:   52:                SPEX_CHECK(spex_update_insert_new_entry(vk_dense->x[i],
        -:   53:                    U->v[real_i], U->v[real_i]->scale, Q[k], option));
        -:   54:                // vk_dense->x[i] = 0
   22856*:   55:                SPEX_CHECK(SPEX_mpz_set_ui(vk_dense->x[i], 0));
        -:   56:            }
    29535:   57:            vk_nz--;
    29535:   58:            vk_dense->i[p] = vk_dense->i[vk_nz];
        -:   59:        }
        -:   60:        else
        -:   61:        {
    17275:   62:            p++;
        -:   63:        }
        -:   64:    }
        -:   65:
        -:   66:    // check if L->v[k] needs more space for all remaining entries
    10439:   67:    if (vk_nz > L->v[k]->nzmax)
        -:   68:    {
      954:   69:        SPEX_CHECK(SPEX_vector_realloc(L->v[k], vk_nz, option));
        -:   70:    }
        -:   71:
        -:   72:    // move the remaining nonzero entries to L->v[k]
    10430:   73:    Lk_nz = 1; // reserve the first entry for the pivot
    27625:   74:    for (p = 0; p < vk_nz; p++)
        -:   75:    {
    17210:   76:        i = vk_dense->i[p];
   17210*:   77:        SPEX_CHECK(SPEX_mpz_sgn(&sgn, vk_dense->x[i]));
    17210:   78:        if (sgn == 0)        {continue;}
        -:   79:
    16618:   80:        h[i] = SPEX_FLIP(h[i]);
    16618:   81:        if (h[i] < k-1)
        -:   82:        {
        -:   83:            // perform history update if needed
     8101:   84:            SPEX_CHECK(SPEX_mpz_mul(vk_dense->x[i], vk_dense->x[i], sd[k-1]));
     8086:   85:            if (h[i] > -1)
        -:   86:            {
    3542*:   87:                SPEX_CHECK(SPEX_mpz_divexact(vk_dense->x[i],
        -:   88:                                             vk_dense->x[i], sd[h[i]]));
        -:   89:            }
        -:   90:        }
    16603:   91:        if (P_inv[i] == diag) // put pivot as the first entry
        -:   92:        {
   10420*:   93:            SPEX_CHECK(SPEX_mpz_swap(L->v[k]->x[0], vk_dense->x[i]));
    10420:   94:            L->v[k]->i[0] = i;
        -:   95:        }
        -:   96:        else
        -:   97:        {
    6183*:   98:            SPEX_CHECK(SPEX_mpz_swap(L->v[k]->x[Lk_nz], vk_dense->x[i]));
     6183:   99:            L->v[k]->i[Lk_nz] = i;
     6183:  100:            Lk_nz++;
        -:  101:        }
        -:  102:        // vk_dense->x[i] = 0
   16603*:  103:        SPEX_CHECK(SPEX_mpz_set_ui(vk_dense->x[i], 0));
        -:  104:    }
    10415:  105:    L->v[k]->nz = Lk_nz;
        -:  106:
    10415:  107:    return SPEX_OK;
        -:  108:}
