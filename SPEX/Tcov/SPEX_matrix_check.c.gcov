        -:    0:Source:SPEX_matrix_check.c
        -:    0:Graph:SPEX_matrix_check.gcno
        -:    0:Data:SPEX_matrix_check.gcda
        -:    0:Runs:9
        -:    1://------------------------------------------------------------------------------
        -:    2:// SPEX_Util/SPEX_matrix_check: check if a matrix is OK
        -:    3://------------------------------------------------------------------------------
        -:    4:
        -:    5:// SPEX_Util: (c) 2019-2021, Chris Lourenco (US Naval Academy), Jinhao Chen,
        -:    6:// Erick Moreno-Centeno, Timothy A. Davis, Texas A&M.  All Rights Reserved.
        -:    7:// SPDX-License-Identifier: GPL-2.0-or-later or LGPL-3.0-or-later
        -:    8:
        -:    9://------------------------------------------------------------------------------
        -:   10:
        -:   11:#define SPEX_FREE_ALL    \
        -:   12:    SPEX_FREE (work) ;   \
        -:   13:    SPEX_MPZ_CLEAR(q);   \
        -:   14:    SPEX_MPZ_CLEAR(r);
        -:   15:
        -:   16:#include "spex_util_internal.h"
        -:   17:
        -:   18:// if pr == 2, turn off printing after 30 lines of output
        -:   19:#define SPEX_PR_LIMIT                       \
        -:   20:    lines++ ;                               \
        -:   21:    if (pr == 2 && lines > 30)              \
        -:   22:    {                                       \
        -:   23:        SPEX_PRINTF ("    ...\n") ;         \
        -:   24:        pr = 1 ;                            \
        -:   25:    }
        -:   26:
        -:   27:int compar (const void *x, const void *y) ;
        -:   28:
   336664:   29:int compar (const void *x, const void *y)
        -:   30:{
        -:   31:    // compare two (i,j) tuples
   336664:   32:    int64_t *a = (int64_t *) x ;
   336664:   33:    int64_t *b = (int64_t *) y ;
   336664:   34:    if (a [0] < b [0])
        -:   35:    {
   133233:   36:        return (-1) ;
        -:   37:    }
   203431:   38:    else if (a [0] > b [0])
        -:   39:    {
      210:   40:        return (1) ;
        -:   41:    }
   203221:   42:    else if (a [1] < b [1])
        -:   43:    {
   202801:   44:        return (-1) ;
        -:   45:    }
      420:   46:    else if (a [1] > b [1])
        -:   47:    {
      210:   48:        return (1) ;
        -:   49:    }
        -:   50:    else
        -:   51:    {
      210:   52:        return (0) ;
        -:   53:    }
        -:   54:}
        -:   55:
        -:   56:/* check the validity of a SPEX_matrix */
        -:   57:
        -:   58:// print_level from option struct:
        -:   59://      0: nothing
        -:   60://      1: just errors
        -:   61://      2: errors and terse output
        -:   62://      3: verbose
        -:   63:
    65160:   64:SPEX_info SPEX_matrix_check     // returns a SPEX status code
        -:   65:(
        -:   66:    const SPEX_matrix *A,     // matrix to check
        -:   67:    const SPEX_options* option
        -:   68:)
        -:   69:{
        -:   70:
   65160*:   71:    if (!spex_initialized ( )) return (SPEX_PANIC) ;
        -:   72:
        -:   73:    //--------------------------------------------------------------------------
        -:   74:    // check the dimensions
        -:   75:    //--------------------------------------------------------------------------
        -:   76:
    65160:   77:    SPEX_info status = 0 ;
    65160:   78:    char * buff = NULL ;
    65160:   79:    int pr = SPEX_OPTION_PRINT_LEVEL (option) ;
        -:   80:    int64_t nz;                            // Number of nonzeros in A
    65160:   81:    status = SPEX_matrix_nnz(&nz, A, option);
    65160:   82:    if (status != SPEX_OK) {return status;}
        -:   83:
    64806:   84:    int64_t m = A->m ;
    64806:   85:    int64_t n = A->n ;
    64806:   86:    int64_t nzmax = A->nzmax ;
        -:   87:
    64806:   88:    if (m < 0)
        -:   89:    {
      316:   90:        SPEX_PR1 ("m invalid\n") ;
      316:   91:        return (SPEX_INCORRECT_INPUT) ;
        -:   92:    }
    64490:   93:    if (n < 0)
        -:   94:    {
      193:   95:        SPEX_PR1 ("n invalid\n") ;
      193:   96:        return (SPEX_INCORRECT_INPUT) ;
        -:   97:    }
    64297:   98:    if (nzmax < 0)
        -:   99:    {
      316:  100:        SPEX_PR1 ("nzmax invalid\n") ;
      316:  101:        return (SPEX_INCORRECT_INPUT) ;
        -:  102:    }
        -:  103:
        -:  104:    //--------------------------------------------------------------------------
        -:  105:    // check the dimensions
        -:  106:    //--------------------------------------------------------------------------
        -:  107:
    63981:  108:    if (A->type < SPEX_MPZ || A->type > SPEX_FP64 ||
    63665:  109:        (A->kind == SPEX_DYNAMIC_CSC && A->type != SPEX_MPZ))
        -:  110:    //  A->kind < SPEX_CSC || A->kind > SPEX_DENSE // checked in SPEX_matrix_nnz
        -:  111:    {
      316:  112:        SPEX_PR1 ("A has invalid type.\n") ;
      316:  113:        return (SPEX_INCORRECT_INPUT) ;
        -:  114:    }
        -:  115:
    63665:  116:    SPEX_PR2 ("SPEX_matrix: nrows: %"PRId64", ncols: %"PRId64", nz:"
        -:  117:        "%"PRId64", nzmax: %"PRId64", kind: %s, type: %s\n", m, n, nz, nzmax,
        -:  118:        A->kind < 1 ? "CSC" : A->kind < 2 ? "Triplet" : A->kind < 3 ?
        -:  119:        "Dense" : "Dynamic CSC",
        -:  120:        A->type < 1 ? "MPZ" : A->type < 2 ? "MPQ" : A->type < 3 ?
        -:  121:        "MPFR" : A->type < 4 ? "int64" : "double") ;
        -:  122:
    63665:  123:    if (pr >= 2)
        -:  124:    {
    11600:  125:        SPEX_PR2 ("scale factor: ") ;
    11600:  126:        status = SPEX_mpfr_asprintf (&buff,"%Qd\n", A->scale) ;
    11600:  127:        if (status >= 0)
        -:  128:        {
    11092:  129:            SPEX_PR2 ("%s", buff) ;
    11092:  130:            SPEX_mpfr_free_str (buff) ;
        -:  131:        }
        -:  132:    }
        -:  133:
        -:  134:    //--------------------------------------------------------------------------
        -:  135:    // initialize workspace
        -:  136:    //--------------------------------------------------------------------------
        -:  137:
        -:  138:    int64_t i, j, p, pend ;
    63665:  139:    int64_t* work = NULL;   // used for checking duplicates for CSC and triplet
    63665:  140:    uint64_t prec = SPEX_OPTION_PREC (option);
        -:  141:    mpz_t q, r;
    63665:  142:    SPEX_MPZ_SET_NULL(q);
    63665:  143:    SPEX_MPZ_SET_NULL(r);
        -:  144:
    63665:  145:    int64_t lines = 0 ;     // # of lines printed so far
        -:  146:
        -:  147:    //--------------------------------------------------------------------------
        -:  148:    // check each kind of matrix: CSC, triplet, or dense
        -:  149:    //--------------------------------------------------------------------------
        -:  150:
    63665:  151:    switch (A->kind)
        -:  152:    {
        -:  153:
        -:  154:        //----------------------------------------------------------------------
        -:  155:        // check a matrix in CSC format
        -:  156:        //----------------------------------------------------------------------
        -:  157:
    34540:  158:        case SPEX_CSC:
        -:  159:        {
    34540:  160:            int64_t* Ap = A->p;
    34540:  161:            int64_t* Ai = A->i;
        -:  162:
        -:  163:            //------------------------------------------------------------------
        -:  164:            // check the column pointers
        -:  165:            //------------------------------------------------------------------
        -:  166:
    34540:  167:            if (nzmax > 0 && (Ap == NULL || Ap [0] != 0))
        -:  168:            {
        -:  169:                // column pointers invalid
      316:  170:                SPEX_PR1 ("p invalid\n") ;
      316:  171:                return (SPEX_INCORRECT_INPUT) ;
        -:  172:            }
   137457:  173:            for (j = 0 ; j < n ; j++)
        -:  174:            {
   103549:  175:                p = Ap [j] ;
   103549:  176:                pend = Ap [j+1] ;
   103549:  177:                if (pend < p || pend > nz)
        -:  178:                {
        -:  179:                    // column pointers not monotonically non-decreasing
      316:  180:                    SPEX_PR1 ("p invalid\n") ;
      316:  181:                    return (SPEX_INCORRECT_INPUT) ;
        -:  182:                }
        -:  183:            }
        -:  184:
        -:  185:            //------------------------------------------------------------------
        -:  186:            // check the row indices && print values
        -:  187:            //------------------------------------------------------------------
        -:  188:
    33908:  189:            if (nzmax > 0 && (Ai == NULL || SPEX_X(A) == NULL))
        -:  190:            {
        -:  191:                // row indices or values not present
      316:  192:                SPEX_PR1 ("i or x invalid\n") ;
      316:  193:                return (SPEX_INCORRECT_INPUT) ;
        -:  194:            }
        -:  195:
        -:  196:            // allocate workspace to check for duplicates
    33592:  197:            work = (int64_t *) SPEX_calloc (m, sizeof (int64_t)) ;
    33592:  198:            if (work == NULL)
        -:  199:            {
        -:  200:                // out of memory
      274:  201:                SPEX_PR1 ("out of memory\n") ;
     274*:  202:                SPEX_FREE_ALL;
      274:  203:                return (SPEX_OUT_OF_MEMORY) ;
        -:  204:            }
        -:  205:
   132095:  206:            for (j = 0 ; j < n ; j++)  // iterate across columns
        -:  207:            {
   99384*:  208:                SPEX_PR_LIMIT ;
    99384:  209:                SPEX_PR2 ("column %"PRId64" :\n", j) ;
    99384:  210:                int64_t marked = j+1 ;
   460552:  211:                for (p = Ap [j] ; p < Ap [j+1] ; p++)
        -:  212:                {
   361775:  213:                    i = Ai [p] ;
   361775:  214:                    if (i < 0 || i >= m)
        -:  215:                    {
        -:  216:                        // row indices out of range
      316:  217:                        SPEX_PR1 ("index out of range: (%ld,%ld)\n", i, j) ;
     316*:  218:                        SPEX_FREE_ALL ;
      316:  219:                        return (SPEX_INCORRECT_INPUT) ;
        -:  220:                    }
   361459:  221:                    else if (work [i] == marked)
        -:  222:                    {
        -:  223:                        // duplicate
       30:  224:                        SPEX_PR1 ("duplicate index: (%ld,%ld)\n", i, j) ;
      30*:  225:                        SPEX_FREE_ALL ;
       30:  226:                        return (SPEX_INCORRECT_INPUT) ;
        -:  227:                    }
   361429:  228:                    if (pr >= 2)
        -:  229:                    {
   29372*:  230:                        SPEX_PR_LIMIT ;
    29372:  231:                        SPEX_PR2 ("  row %"PRId64" : ", i) ;
        -:  232:
    29372:  233:                        switch ( A->type)
        -:  234:                        {
     5885:  235:                            case SPEX_MPZ:
        -:  236:                            {
     5885:  237:                                status = SPEX_mpfr_asprintf(&buff, "%Zd \n",
     5885:  238:                                    A->x.mpz[p]);
     5885:  239:                                if (status >= 0)
        -:  240:                                {
     5808:  241:                                    SPEX_PR2("%s", buff);
     5808:  242:                                    SPEX_mpfr_free_str (buff);
        -:  243:                                }
     5885:  244:                                break;
        -:  245:                            }
     6798:  246:                            case SPEX_MPQ:
        -:  247:                            {
     6798:  248:                                status = SPEX_mpfr_asprintf(&buff,"%Qd \n",
     6798:  249:                                    A->x.mpq[p]);
     6798:  250:                                if (status >= 0)
        -:  251:                                {
     6710:  252:                                    SPEX_PR2("%s", buff);
     6710:  253:                                    SPEX_mpfr_free_str (buff);
        -:  254:                                }
     6798:  255:                                break;
        -:  256:                            }
     6880:  257:                            case SPEX_MPFR:
        -:  258:                            {
     6880:  259:                                status = SPEX_mpfr_asprintf(&buff, "%.*Rf \n",
     6880:  260:                                    prec, A->x.mpfr [p]);
     6880:  261:                                if (status >= 0) 
        -:  262:                                {
     6784:  263:                                    SPEX_PR2("%s", buff);
     6784:  264:                                    SPEX_mpfr_free_str (buff);
        -:  265:                                }
     6880:  266:                                break;
        -:  267:                            }
     5852:  268:                            case SPEX_FP64:
        -:  269:                            {
     5852:  270:                                SPEX_PR2 ("%lf \n", A->x.fp64[p]);
     5852:  271:                                break;
        -:  272:                            }
     3957:  273:                            case SPEX_INT64:
        -:  274:                            {
     3957:  275:                                SPEX_PR2 ("%ld \n", A->x.int64[p]);
     3957:  276:                                break;
        -:  277:                            }
        -:  278:                        }
    29372:  279:                        if (status < 0)
        -:  280:                        {
     261*:  281:                            SPEX_FREE_ALL ;
      261:  282:                            SPEX_PRINTF (" error: %d\n", status) ;
      261:  283:                            return (status) ;
        -:  284:                        }
        -:  285:                    }
   361168:  286:                    work [i] = marked ;
        -:  287:                }
        -:  288:            }
        -:  289:        }
    32711:  290:        break;
        -:  291:
        -:  292:        //----------------------------------------------------------------------
        -:  293:        // check a matrix in triplet format
        -:  294:        //----------------------------------------------------------------------
        -:  295:
    20864:  296:        case SPEX_TRIPLET:
        -:  297:        {
        -:  298:
    20864:  299:            int64_t* Aj = A->j;
    20864:  300:            int64_t* Ai = A->i;
        -:  301:
        -:  302:            //------------------------------------------------------------------
        -:  303:            // basic pointer checking
        -:  304:            //------------------------------------------------------------------
        -:  305:
    20864:  306:            if (nzmax > 0 && (Ai == NULL || Aj == NULL || SPEX_X(A) == NULL))
        -:  307:            {
        -:  308:                // row indices or values not present
      193:  309:                SPEX_PR1 ("i or j or x invalid\n") ;
      193:  310:                return (SPEX_INCORRECT_INPUT) ;
        -:  311:            }
        -:  312:
        -:  313:            //------------------------------------------------------------------
        -:  314:            // print each entry as "Ai Aj Ax"
        -:  315:            //------------------------------------------------------------------
        -:  316:
   240930:  317:            for (p = 0 ; p < nz ; p++)
        -:  318:            {
   220883:  319:                i = Ai[p];
   220883:  320:                j = Aj[p];
   220883:  321:                if (i < 0 || i >= m || j < 0 || j >= n)
        -:  322:                {
        -:  323:                    // row indices out of range
      193:  324:                    SPEX_PR1 ("invalid index\n") ;
     193*:  325:                    SPEX_FREE_ALL ;
      193:  326:                    return (SPEX_INCORRECT_INPUT) ;
        -:  327:                }
   220690:  328:                if (pr >= 2)
        -:  329:                {
   31468*:  330:                    SPEX_PR_LIMIT ;
    31468:  331:                    SPEX_PR2 ("  %"PRId64" %"PRId64" : ", i, j) ;
        -:  332:
    31468:  333:                    switch ( A->type)
        -:  334:                    {
     4630:  335:                        case SPEX_MPZ:
        -:  336:                        {
     4630:  337:                            status = SPEX_mpfr_asprintf(&buff, "%Zd \n",
     4630:  338:                                A->x.mpz [p]);
     4630:  339:                            if (status >= 0) 
        -:  340:                            {
     4543:  341:                                SPEX_PR2("%s", buff);
     4543:  342:                                SPEX_mpfr_free_str (buff);
        -:  343:                            }
     4630:  344:                            break;
        -:  345:                        }
     7325:  346:                        case SPEX_MPQ:
        -:  347:                        {
     7325:  348:                            status = SPEX_mpfr_asprintf (&buff,"%Qd \n",
     7325:  349:                                A->x.mpq [p]);
     7325:  350:                            if (status >= 0)  
        -:  351:                            {   
     7227:  352:                                SPEX_PR2("%s", buff); 
     7227:  353:                                SPEX_mpfr_free_str (buff); 
        -:  354:                            }
     7325:  355:                            break;
        -:  356:                        }
     7528:  357:                        case SPEX_MPFR:
        -:  358:                        {
     7528:  359:                            status = SPEX_mpfr_asprintf(&buff, "%.*Rf \n",
     7528:  360:                                prec, A->x.mpfr [p]);
     7528:  361:                            if (status >= 0)  
        -:  362:                            {   
     7422:  363:                                SPEX_PR2("%s", buff); 
     7422:  364:                                SPEX_mpfr_free_str (buff); 
        -:  365:                            }
     7528:  366:                            break;
        -:  367:                        }
     6555:  368:                        case SPEX_FP64:
        -:  369:                        {
     6555:  370:                            SPEX_PR2 ("%lf \n", A->x.fp64[p]);
     6555:  371:                            break;
        -:  372:                        }
     5430:  373:                        case SPEX_INT64:
        -:  374:                        {
     5430:  375:                            SPEX_PR2 ("%ld \n", A->x.int64[p]);
     5430:  376:                            break;
        -:  377:                        }
        -:  378:                    }
    31468:  379:                    if (status < 0)
        -:  380:                    {
     431*:  381:                        SPEX_FREE_ALL ;
      431:  382:                        SPEX_PRINTF (" error: %d\n", status) ;
      431:  383:                        return (status) ;
        -:  384:                    }
        -:  385:                }
        -:  386:            }
        -:  387:
        -:  388:            //------------------------------------------------------------------
        -:  389:            // check for duplicates
        -:  390:            //------------------------------------------------------------------
        -:  391:
        -:  392:            // allocate workspace to check for duplicates
    20047:  393:            work = (int64_t *) SPEX_malloc (nz * 2 * sizeof (int64_t)) ;
    20047:  394:            if (work == NULL)
        -:  395:            {
        -:  396:                // out of memory
       95:  397:                SPEX_PR1 ("out of memory\n") ;
      95*:  398:                SPEX_FREE_ALL;
       95:  399:                return (SPEX_OUT_OF_MEMORY) ;
        -:  400:            }
        -:  401:
        -:  402:            // load the (i,j) indices of the triplets into the workspace
   237954:  403:            for (p = 0 ; p < nz ; p++)
        -:  404:            {
   218002:  405:                work [2*p  ] = Aj [p] ;
   218002:  406:                work [2*p+1] = Ai [p] ;
        -:  407:            }
        -:  408:
        -:  409:            // sort the (i,j) indices
    19952:  410:            qsort (work, nz, 2 * sizeof (int64_t), compar) ;
        -:  411:
        -:  412:            // check for duplicates
   217792:  413:            for (p = 1 ; p < nz ; p++)
        -:  414:            {
   198050:  415:                int64_t this_j = work [2*p  ] ;
   198050:  416:                int64_t this_i = work [2*p+1] ;
   198050:  417:                int64_t last_j = work [2*(p-1)  ] ;
   198050:  418:                int64_t last_i = work [2*(p-1)+1] ;
   198050:  419:                if (this_j == last_j && this_i == last_i)
        -:  420:                {
      210:  421:                    SPEX_PR1 ("duplicate index: (%ld, %ld)\n", this_i, this_j) ;
     210*:  422:                    SPEX_FREE_ALL ;
      210:  423:                    return (SPEX_INCORRECT_INPUT) ;
        -:  424:                }
        -:  425:            }
        -:  426:
        -:  427:        }
    19742:  428:        break;
        -:  429:
        -:  430:        //----------------------------------------------------------------------
        -:  431:        // check a matrix in dense format
        -:  432:        //----------------------------------------------------------------------
        -:  433:
     7814:  434:        case SPEX_DENSE:
        -:  435:        {
        -:  436:            // If A is dense, A->i, A->j etc are all NULL. All we must do is
        -:  437:            // to check that its dimensions are correct and print the values if
        -:  438:            // desired.
        -:  439:
     7814:  440:            if (nzmax > 0 && SPEX_X(A) == NULL)
        -:  441:            {
        -:  442:                // row indices or values not present
       42:  443:                SPEX_PR1 ("x invalid\n") ;
       42:  444:                return (SPEX_INCORRECT_INPUT) ;
        -:  445:            }
        -:  446:
        -:  447:            //------------------------------------------------------------------
        -:  448:            // print values
        -:  449:            //------------------------------------------------------------------
        -:  450:
    25529:  451:            for (j = 0 ; j < n ; j++)
        -:  452:            {
   18068*:  453:                SPEX_PR_LIMIT ;
    18068:  454:                SPEX_PR2 ("column %"PRId64" :\n", j) ;
   118616:  455:                for (i = 0; i < m; i++)
        -:  456:                {
   100859:  457:                    if (pr >= 2)
        -:  458:                    {
   33088*:  459:                        SPEX_PR_LIMIT ;
    33088:  460:                        SPEX_PR2 ("  row %"PRId64" : ", i) ;
        -:  461:
    33088:  462:                        switch ( A->type)
        -:  463:                        {
     5158:  464:                            case SPEX_MPZ:
        -:  465:                            {
     5158:  466:                                status = SPEX_mpfr_asprintf (&buff, "%Zd \n" ,
     5158:  467:                                    SPEX_2D(A, i, j, mpz)) ;
     5158:  468:                                if (status >= 0)  
        -:  469:                                {   
     5071:  470:                                    SPEX_PR2("%s", buff); 
     5071:  471:                                    SPEX_mpfr_free_str (buff); 
        -:  472:                                }
     5158:  473:                                break;
        -:  474:                            }
     7853:  475:                            case SPEX_MPQ:
        -:  476:                            {
     7853:  477:                                status = SPEX_mpfr_asprintf (&buff, "%Qd \n",
     7853:  478:                                    SPEX_2D(A, i, j, mpq));
     7853:  479:                                if (status >= 0)   
        -:  480:                                {    
     7755:  481:                                    SPEX_PR2("%s", buff);  
     7755:  482:                                    SPEX_mpfr_free_str (buff);  
        -:  483:                                }
     7853:  484:                                break;
        -:  485:                            }
     8056:  486:                            case SPEX_MPFR:
        -:  487:                            {
     8056:  488:                                status = SPEX_mpfr_asprintf (&buff, "%.*Rf \n",
     8056:  489:                                    prec, SPEX_2D(A, i, j, mpfr));
     8056:  490:                                if (status >= 0)   
        -:  491:                                {    
     7950:  492:                                    SPEX_PR2("%s", buff);  
     7950:  493:                                    SPEX_mpfr_free_str (buff);  
        -:  494:                                }
     8056:  495:                                break;
        -:  496:                            }
     7083:  497:                            case SPEX_FP64:
        -:  498:                            {
     7083:  499:                                SPEX_PR2 ("%lf \n", SPEX_2D(A, i, j, fp64));
     7083:  500:                                break;
        -:  501:                            }
     4938:  502:                            case SPEX_INT64:
        -:  503:                            {
     4938:  504:                                SPEX_PR2 ("%ld \n", SPEX_2D(A, i, j, int64));
     4938:  505:                                break;
        -:  506:                            }
        -:  507:                        }
    33088:  508:                        if (status < 0)
        -:  509:                        {
      311:  510:                            SPEX_PR2 (" error: %d\n", status) ;
      311:  511:                            return (status) ;
        -:  512:                        }
        -:  513:                    }
        -:  514:                }
        -:  515:            }
        -:  516:        }
     7461:  517:        break;
        -:  518:
        -:  519:        //----------------------------------------------------------------------
        -:  520:        // check a matrix in dynamic CSC format
        -:  521:        //----------------------------------------------------------------------
        -:  522:
      447:  523:        case SPEX_DYNAMIC_CSC:
        -:  524:        {
        -:  525:            // This is checked by SPEX_matrix_nnz
        -:  526:            ASSERT (A->v != NULL);
        -:  527:
        -:  528:            // allocate workspace to check for duplicates
      447:  529:            work = (int64_t *) SPEX_calloc (m, sizeof (int64_t)) ;
      447:  530:            if (work == NULL)
        -:  531:            {
        -:  532:                // out of memory
       33:  533:                SPEX_PR1 ("out of memory\n") ;
      33*:  534:                SPEX_FREE_ALL;
       33:  535:                return (SPEX_OUT_OF_MEMORY) ;
        -:  536:            }
        -:  537:
        -:  538:            // initialize q and r
        -:  539:            SPEX_info info;
     414*:  540:            SPEX_CHECK(SPEX_mpz_init(q));
     411*:  541:            SPEX_CHECK(SPEX_mpz_init(r));
        -:  542:
        -:  543:            //------------------------------------------------------------------
        -:  544:            // check the row indices && print values
        -:  545:            //------------------------------------------------------------------
        -:  546:
     1554:  547:            for (j = 0 ; j < n ; j++)  // iterate across columns
        -:  548:            {
        -:  549:                // This is checked by SPEX_matrix_nnz
        -:  550:                ASSERT (A->v[j] != NULL);
        -:  551:
    1475*:  552:                SPEX_PR_LIMIT ;
     1475:  553:                SPEX_PR2 ("column %"PRId64" :\n", j) ;
     1475:  554:                int64_t marked = j+1 ;
        -:  555:
     1475:  556:                if (A->v[j]->nzmax > 0 &&
     1475:  557:                    (A->v[j]->i == NULL || A->v[j]->x == NULL))
        -:  558:                {
        -:  559:                    // row indices or values not present
       19:  560:                    SPEX_PR1 ("i or x invalid\n") ;
       19:  561:                    SPEX_FREE_ALL;
       19:  562:                    return (SPEX_INCORRECT_INPUT) ;
        -:  563:                }
        -:  564:
     5668:  565:                for (p = 0 ; p < A->v[j]->nz ; p++)
        -:  566:                {
     4522:  567:                    i = A->v[j]->i [p] ;
     4522:  568:                    if (i < 0 || i >= m)
        -:  569:                    {
        -:  570:                        // row indices out of range
       19:  571:                        SPEX_PR1 ("index out of range: (%ld,%ld)\n", i, j) ;
       19:  572:                        SPEX_FREE_ALL ;
       19:  573:                        return (SPEX_INCORRECT_INPUT) ;
        -:  574:                    }
     4503:  575:                    else if (work [i] == marked)
        -:  576:                    {
        -:  577:                        // duplicate
       17:  578:                        SPEX_PR1 ("duplicate index: (%ld,%ld)\n", i, j) ;
       17:  579:                        SPEX_FREE_ALL ;
       17:  580:                        return (SPEX_INCORRECT_INPUT) ;
        -:  581:                    }
     4486:  582:                    if (pr >= 2)
        -:  583:                    {
    4486*:  584:                        SPEX_PR_LIMIT ;
     4486:  585:                        SPEX_PR2 ("  row %"PRId64" : ", i) ;
        -:  586:
        -:  587:                        // check if each entry will be integer after scale
        -:  588:                        // applied, report error if not.
        -:  589:                        int sgn;
    4760*:  590:                        SPEX_CHECK(SPEX_mpz_sgn(&sgn, A->v[j]->x[p]));
     4486:  591:                        if (sgn != 0)
        -:  592:                        {
     4430:  593:                            SPEX_CHECK(SPEX_mpz_mul(q, A->v[j]->x[p],
        -:  594:                                SPEX_MPQ_NUM(A->v[j]->scale)));
    4427*:  595:                            SPEX_CHECK(SPEX_mpz_cdiv_qr(q, r, q,
        -:  596:                                SPEX_MPQ_DEN(A->v[j]->scale)));
    4427*:  597:                            SPEX_CHECK(SPEX_mpz_sgn(&sgn, r));
     4427:  598:                            if (sgn != 0)
        -:  599:                            {
        -:  600:                                // entry is not integer after scale applied
       19:  601:                                SPEX_PR1 ("entry not integer: (%ld,%ld)\n",
        -:  602:                                    i, j) ;
       19:  603:                                SPEX_FREE_ALL ;
       19:  604:                                return (SPEX_INCORRECT_INPUT) ;
        -:  605:                            }
     4408:  606:                            status = SPEX_mpfr_asprintf(&buff, "%Zd \n", q);
     4408:  607:                            if (status >= 0)
        -:  608:                            {
     4156:  609:                                SPEX_PR2("%s", buff);
     4156:  610:                                SPEX_mpfr_free_str (buff);
        -:  611:                            }
        -:  612:                            else
        -:  613:                            {
      252:  614:                                SPEX_FREE_ALL ;
      252:  615:                                SPEX_PRINTF (" error: %d\n", status) ;
      252:  616:                                return (status) ;
        -:  617:                            }
        -:  618:                        }
        -:  619:                        else
        -:  620:                        {
        -:  621:                            // just print 0 as it is
       56:  622:                            SPEX_PR2("%d \n", 0);
        -:  623:                        }
        -:  624:                    }
     4212:  625:                    work [i] = marked ;
        -:  626:                }
        -:  627:            }
        -:  628:
        -:  629:        }
       79:  630:        break;
        -:  631:
        -:  632:    }
        -:  633:
        -:  634:    //--------------------------------------------------------------------------
        -:  635:    // free workspace and return result
        -:  636:    //--------------------------------------------------------------------------
        -:  637:
    59993:  638:    SPEX_FREE_ALL ;
    59993:  639:    return (SPEX_OK) ;
        -:  640:}
        -:  641:
