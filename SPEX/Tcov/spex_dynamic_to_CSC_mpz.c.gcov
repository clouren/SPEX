        -:    0:Source:spex_dynamic_to_CSC_mpz.c
        -:    0:Graph:spex_dynamic_to_CSC_mpz.gcno
        -:    0:Data:spex_dynamic_to_CSC_mpz.gcda
        -:    0:Runs:9
        -:    1://------------------------------------------------------------------------------
        -:    2:// SPEX_Util/spex_dynamic_to_CSC_mpz.c: convert SPEX_DYNAMIC_CSC matrix to a
        -:    3:// SPEX_CSC matrix with mpz_t entries.
        -:    4://------------------------------------------------------------------------------
        -:    5:
        -:    6:// SPEX_Util: (c) 2020-2021, Jinhao Chen, Chris Lourenco (US Naval Academy),
        -:    7:// Erick Moreno-Centeno, Timothy A. Davis, Texas A&M.  All Rights Reserved.
        -:    8:// SPDX-License-Identifier: GPL-2.0-or-later or LGPL-3.0-or-later
        -:    9:
        -:   10://------------------------------------------------------------------------------
        -:   11:
        -:   12:// spex_dynamic_to_CSC_mpz create a SPEX_matrix A in Compressed Sparse Column
        -:   13:// (CSC) format with entries in mpz_t type from the give matrix B, which is a
        -:   14:// SPEX_DYNAMIC_CSC matrix with mpz_t entries.
        -:   15:
        -:   16:#define SPEX_FREE_ALL                \
        -:   17:    SPEX_matrix_free(&A, option);
        -:   18:
        -:   19:#include "spex_util_internal.h"
        -:   20:
      715:   21:SPEX_info spex_dynamic_to_CSC_mpz
        -:   22:(
        -:   23:    SPEX_matrix **A_handle,       // converted CSC matrix
        -:   24:    const SPEX_matrix *B,         // original matrix
        -:   25:    const int64_t nnz,            // number of nonzeros in B
        -:   26:    const SPEX_options *option
        -:   27:)
        -:   28:{
     715*:   29:    SPEX_REQUIRE (B, SPEX_DYNAMIC_CSC, SPEX_MPZ) ;
     715*:   30:    if (A_handle == NULL)   {return SPEX_INCORRECT_INPUT;}
        -:   31:
        -:   32:    SPEX_info info;
        -:   33:    int sgn;
      715:   34:    int64_t i, j, Ap = 0, Bp;
      715:   35:    (*A_handle) = NULL;
      715:   36:    SPEX_matrix *A = NULL;
        -:   37:
        -:   38:    // allocate space for A
      715:   39:    SPEX_CHECK(SPEX_matrix_allocate(&A, SPEX_CSC, SPEX_MPZ, B->m, B->n, nnz,
        -:   40:        false, true, option));
        -:   41:
        -:   42:    // initialize for A and construct A from B
      661:   43:    A->p[0] = 0;
     5374:   44:    for (j = 0 ; j < B->n ; j++)
        -:   45:    {
    4716*:   46:        SPEX_CHECK(SPEX_mpq_cmp_ui(&sgn, B->v[j]->scale, 1, 1));
    58201:   47:        for (Bp = 0 ; Bp < B->v[j]->nz ; Bp++)
        -:   48:        {
    53488:   49:            i = B->v[j]->i[Bp];
    53488:   50:            A->i[Ap] = i ;
        -:   51:            // A->x[Ap] = B->v[j]->x[Bp]*scale
    53488:   52:            if (sgn == 0) // scale == 1
        -:   53:            {
   53114*:   54:                SPEX_CHECK(SPEX_mpz_set(SPEX_1D(A, Ap, mpz),
        -:   55:                    B->v[j]->x[Bp])) ;
        -:   56:            }
        -:   57:            else
        -:   58:            {
     374*:   59:                SPEX_CHECK(SPEX_mpz_divexact(SPEX_1D(A, Ap, mpz),
        -:   60:                    B->v[j]->x[Bp], SPEX_MPQ_DEN(B->v[j]->scale))) ;
      374:   61:                SPEX_CHECK(SPEX_mpz_mul(SPEX_1D(A, Ap, mpz),
        -:   62:                    SPEX_1D(A, Ap, mpz), SPEX_MPQ_NUM(B->v[j]->scale))) ;
        -:   63:            }
    53485:   64:            Ap++;
        -:   65:        }
     4713:   66:        A->p[j+1] = Ap;
        -:   67:    }
     658*:   68:    SPEX_CHECK(SPEX_mpq_set(A->scale, B->scale));
        -:   69:
      658:   70:    (*A_handle) = A;
      658:   71:    return SPEX_OK;
        -:   72:}
