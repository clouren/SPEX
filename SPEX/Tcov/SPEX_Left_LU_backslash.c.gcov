        -:    0:Source:SPEX_Left_LU_backslash.c
        -:    0:Graph:SPEX_Left_LU_backslash.gcno
        -:    0:Data:SPEX_Left_LU_backslash.gcda
        -:    0:Runs:6
        -:    1://------------------------------------------------------------------------------
        -:    2:// SPEX_Left_LU/SPEX_Left_LU_backslash: solve Ax=b, returning solution as desired data type
        -:    3://------------------------------------------------------------------------------
        -:    4:
        -:    5:// SPEX_Left_LU: (c) 2019-2021, Chris Lourenco (US Naval Academy), Jinhao Chen,
        -:    6:// Erick Moreno-Centeno, Timothy A. Davis, Texas A&M.  All Rights Reserved.
        -:    7:// SPDX-License-Identifier: GPL-2.0-or-later or LGPL-3.0-or-later
        -:    8:
        -:    9://------------------------------------------------------------------------------
        -:   10:
        -:   11:/* Purpose: This code utilizes the SPEX Left LU factorization to exactly solve the
        -:   12: *          linear system Ax = b. This is essentially an exact version of
        -:   13: *          MATLAB sparse backslash
        -:   14: *
        -:   15: * Input/Output arguments:
        -:   16: *
        -:   17: * X_handle:    A pointer to the solution of the linear system. The output is
        -:   18: *              allowed to be returned in either double precision, mpfr_t, or
        -:   19: *              rational mpq_t
        -:   20: *
        -:   21: * type:        Data structure of output desired. Must be either SPEX_MPQ,
        -:   22: *              SPEX_FP64, or SPEX_MPFR
        -:   23: *
        -:   24: * A:           User's input matrix. It must be populated prior to calling this
        -:   25: *              function.
        -:   26: *
        -:   27: * b:           Collection of right hand side vectors. Must be populated prior to
        -:   28: *              factorization.
        -:   29: *
        -:   30: * option:      Struct containing various command parameters for the factorization. If
        -:   31: *              NULL on input, default values are used.
        -:   32: */
        -:   33:
        -:   34:# define SPEX_FREE_WORK             \
        -:   35:    SPEX_matrix_free(&L, NULL);     \
        -:   36:    SPEX_matrix_free(&U, NULL);     \
        -:   37:    SPEX_FREE(pinv);                \
        -:   38:    SPEX_matrix_free(&rhos, NULL);  \
        -:   39:    SPEX_LU_analysis_free (&S, NULL);
        -:   40:
        -:   41:# define SPEX_FREE_ALL              \
        -:   42:    SPEX_FREE_WORK                  \
        -:   43:    SPEX_matrix_free(&x, NULL);     \
        -:   44:
        -:   45:#include "spex_left_lu_internal.h"
        -:   46:
     1905:   47:SPEX_info SPEX_Left_LU_backslash
        -:   48:(
        -:   49:    // Output
        -:   50:    SPEX_matrix **X_handle,       // Final solution vector
        -:   51:    // Input
        -:   52:    SPEX_type type,               // Type of output desired
        -:   53:                                  // Must be SPEX_MPQ, SPEX_MPFR, or SPEX_FP64
        -:   54:    const SPEX_matrix *A,         // Input matrix
        -:   55:    const SPEX_matrix *b,         // Right hand side vector(s)
        -:   56:    const SPEX_options* option    // Command options
        -:   57:)
        -:   58:{
        -:   59:
        -:   60:    //-------------------------------------------------------------------------
        -:   61:    // check inputs
        -:   62:    //-------------------------------------------------------------------------
        -:   63:
        -:   64:    SPEX_info info ;
    1905*:   65:    if (!spex_initialized ( )) return (SPEX_PANIC) ;
        -:   66:
     1905:   67:    if (X_handle == NULL)
        -:   68:    {
        2:   69:        return SPEX_INCORRECT_INPUT;
        -:   70:    }
     1903:   71:    (*X_handle) = NULL;
        -:   72:
     1903:   73:    if (type != SPEX_MPQ && type != SPEX_FP64 && type != SPEX_MPFR)
        -:   74:    {
        2:   75:        return SPEX_INCORRECT_INPUT;
        -:   76:    }
        -:   77:
    1901*:   78:    SPEX_REQUIRE (A, SPEX_CSC,   SPEX_MPZ) ;
    1901*:   79:    SPEX_REQUIRE (b, SPEX_DENSE, SPEX_MPZ) ;
        -:   80:
     1901:   81:    SPEX_matrix *L = NULL ;
     1901:   82:    SPEX_matrix *U = NULL ;
     1901:   83:    SPEX_matrix *x = NULL;
     1901:   84:    int64_t *pinv = NULL ;
     1901:   85:    SPEX_matrix *rhos = NULL ;
     1901:   86:    SPEX_LU_analysis *S = NULL;
        -:   87:
        -:   88:    //--------------------------------------------------------------------------
        -:   89:    // Symbolic Analysis
        -:   90:    //--------------------------------------------------------------------------
        -:   91:
     1901:   92:    SPEX_CHECK(SPEX_LU_analyze(&S, A, option));
        -:   93:
        -:   94:    //--------------------------------------------------------------------------
        -:   95:    // LU Factorization
        -:   96:    //--------------------------------------------------------------------------
        -:   97:
     1877:   98:    SPEX_CHECK(SPEX_Left_LU_factorize(&L, &U, &rhos, &pinv, A, S, option));
        -:   99:
        -:  100:    //--------------------------------------------------------------------------
        -:  101:    // Solve
        -:  102:    //--------------------------------------------------------------------------
        -:  103:
      391:  104:    SPEX_CHECK (SPEX_Left_LU_solve (&x, b, A,
        -:  105:        (const SPEX_matrix *) L,
        -:  106:        (const SPEX_matrix *) U,
        -:  107:        (const SPEX_matrix *) rhos,
        -:  108:        S,
        -:  109:        (const int64_t *) pinv,
        -:  110:        option)) ;
        -:  111:
        -:  112:    //--------------------------------------------------------------------------
        -:  113:    // Now, x contains the exact solution of the linear system in mpq_t
        -:  114:    // precision set the output.
        -:  115:    //--------------------------------------------------------------------------
        -:  116:
       42:  117:    if (type == SPEX_MPQ)
        -:  118:    {
       30:  119:        (*X_handle) = x ;
        -:  120:    }
        -:  121:    else
        -:  122:    {
       12:  123:        SPEX_matrix* x2 = NULL ;
       12:  124:        SPEX_CHECK (SPEX_matrix_copy (&x2, SPEX_DENSE, type, x, option)) ;
        4:  125:        (*X_handle) = x2 ;
        4:  126:        SPEX_matrix_free (&x, NULL) ;
        -:  127:    }
        -:  128:
        -:  129:    //--------------------------------------------------------------------------
        -:  130:    // Free memory
        -:  131:    //--------------------------------------------------------------------------
        -:  132:
       34:  133:    SPEX_FREE_WORK ;
       34:  134:    return (SPEX_OK) ;
        -:  135:}
        -:  136:
