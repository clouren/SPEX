        -:    0:Source:spex_expand_double_array.c
        -:    0:Graph:spex_expand_double_array.gcno
        -:    0:Data:spex_expand_double_array.gcda
        -:    0:Runs:9
        -:    1://------------------------------------------------------------------------------
        -:    2:// SPEX_Util/spex_expand_double_array: convert double vector to mpz
        -:    3://------------------------------------------------------------------------------
        -:    4:
        -:    5:// SPEX_Util: (c) 2019-2021, Chris Lourenco (US Naval Academy), Jinhao Chen,
        -:    6:// Erick Moreno-Centeno, Timothy A. Davis, Texas A&M.  All Rights Reserved.
        -:    7:// SPDX-License-Identifier: GPL-2.0-or-later or LGPL-3.0-or-later
        -:    8:
        -:    9://------------------------------------------------------------------------------
        -:   10:
        -:   11:/* Purpose: This function converts a double array of size n to an appropriate
        -:   12: * mpz array of size n. To do this, the number is multiplied by an appropriate
        -:   13: * power, then, the GCD is found. This function allows the use of matrices in
        -:   14: * double precision to work with SPEX.
        -:   15: *
        -:   16: */
        -:   17:
        -:   18:#define SPEX_FREE_ALL               \
        -:   19:    SPEX_MPZ_CLEAR(gcd);            \
        -:   20:    SPEX_MPZ_CLEAR(one);            \
        -:   21:    SPEX_MPQ_CLEAR(temp);           \
        -:   22:    SPEX_matrix_free(&x3, NULL);    \
        -:   23:
        -:   24:#include "spex_util_internal.h"
        -:   25:
     4597:   26:SPEX_info spex_expand_double_array
        -:   27:(
        -:   28:    mpz_t* x_out,           // integral final array
        -:   29:    double* x,              // double array that needs to be made integral
        -:   30:    mpq_t scale,            // the scaling factor used (x_out = scale * x)
        -:   31:    int64_t n,              // size of x
        -:   32:    const SPEX_options* option // Command options
        -:   33:)
        -:   34:{
        -:   35:
        -:   36:    //--------------------------------------------------------------------------
        -:   37:    // check inputs
        -:   38:    //--------------------------------------------------------------------------
        -:   39:
        -:   40:    // inputs have been checked in the only caller spex_cast_array
        -:   41:
        -:   42:    //--------------------------------------------------------------------------
        -:   43:
        -:   44:    int64_t i, k ;
     4597:   45:    int r1, r2 = 1;
     4597:   46:    bool nz_found = false;
        -:   47:    SPEX_info info ;
        -:   48:    // Double precision accurate to about 2e-16. We multiply by 10e17 to convert
        -:   49:    // (overestimate to be safe)
     4597:   50:    double expon = pow(10, 17);
        -:   51:    // Quad precision in case input is huge
     4597:   52:    SPEX_matrix* x3 = NULL;
     4597:   53:    mpz_t gcd, one; SPEX_MPZ_SET_NULL(gcd); SPEX_MPZ_SET_NULL(one);
     4597:   54:    mpq_t temp; SPEX_MPQ_SET_NULL(temp);
        -:   55:
    4597*:   56:    mpfr_rnd_t round = SPEX_OPTION_ROUND (option) ;
        -:   57:
    4597*:   58:    SPEX_CHECK(SPEX_mpq_init(temp));
    4571*:   59:    SPEX_CHECK(SPEX_mpz_init(gcd));
    4558*:   60:    SPEX_CHECK(SPEX_mpz_init(one));
        -:   61:
     4545:   62:    SPEX_CHECK (SPEX_matrix_allocate(&x3, SPEX_DENSE, SPEX_MPFR, n, 1, n,
        -:   63:        false, true, option));
        -:   64:
     4364:   65:    SPEX_CHECK(SPEX_mpq_set_d(scale, expon));           // scale = 10^17
    56134:   66:    for (i = 0; i < n; i++)
        -:   67:    {
        -:   68:        // Set x3[i] = x[i]
   52138*:   69:        SPEX_CHECK(SPEX_mpfr_set_d(x3->x.mpfr[i], x[i], round));
        -:   70:
        -:   71:        // x3[i] = x[i] * 10^17
   52138*:   72:        SPEX_CHECK(SPEX_mpfr_mul_d(x3->x.mpfr[i], x3->x.mpfr[i], expon, round));
        -:   73:
        -:   74:        // x_out[i] = x3[i]
    52138:   75:        SPEX_CHECK(SPEX_mpfr_get_z(x_out[i], x3->x.mpfr[i], round));
        -:   76:    }
        -:   77:
        -:   78:    //--------------------------------------------------------------------------
        -:   79:    // Compute the GCD to reduce the size of scale
        -:   80:    //--------------------------------------------------------------------------
        -:   81:
    3996*:   82:    SPEX_CHECK(SPEX_mpz_set_ui(one, 1));
        -:   83:    // Find an initial GCD
    51385:   84:    for (i = 0; i < n; i++)
        -:   85:    {
    47887:   86:        if (!nz_found)
        -:   87:        {
    7182*:   88:            SPEX_CHECK(SPEX_mpz_cmp_ui(&r1, x_out[i], 0)); // Check if x[i] == 0
     7182:   89:            if (r1 != 0)
        -:   90:            {
     3678:   91:                nz_found = true;
     3678:   92:                k = i;
    3678*:   93:                SPEX_CHECK(SPEX_mpz_set(gcd, x_out[i]));
        -:   94:            }
        -:   95:        }
        -:   96:        else
        -:   97:        {
        -:   98:            // Compute the GCD, stop if gcd == 1
   40705*:   99:            SPEX_CHECK(SPEX_mpz_gcd(gcd, gcd, x_out[i]));
   40705*:  100:            SPEX_CHECK(SPEX_mpz_cmp(&r2, gcd, one));
    40705:  101:            if (r2 == 0)
        -:  102:            {
      498:  103:                break;
        -:  104:            }
        -:  105:        }
        -:  106:    }
        -:  107:
     3996:  108:    if (!nz_found)     // Array is all zeros
        -:  109:    {
      318:  110:        SPEX_FREE_ALL;
      318:  111:        SPEX_mpq_set_z(scale, one);
      318:  112:        return SPEX_OK;
        -:  113:    }
        -:  114:
        -:  115:    //--------------------------------------------------------------------------
        -:  116:    // Scale all entries to make as small as possible
        -:  117:    //--------------------------------------------------------------------------
        -:  118:
     3678:  119:    if (r2 != 0)             // If gcd == 1 then stop
        -:  120:    {
    46283:  121:        for (i = k; i < n; i++)
        -:  122:        {
   43103*:  123:            SPEX_CHECK(SPEX_mpz_divexact(x_out[i], x_out[i], gcd));
        -:  124:        }
    3180*:  125:        SPEX_CHECK(SPEX_mpq_set_z(temp, gcd));
     3180:  126:        SPEX_CHECK(SPEX_mpq_div(scale, scale, temp));
        -:  127:    }
     3668:  128:    SPEX_FREE_ALL;
     3668:  129:    return SPEX_OK;
        -:  130:}
        -:  131:
