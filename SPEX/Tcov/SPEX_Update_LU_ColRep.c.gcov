        -:    0:Source:SPEX_Update_LU_ColRep.c
        -:    0:Graph:SPEX_Update_LU_ColRep.gcno
        -:    0:Data:SPEX_Update_LU_ColRep.gcda
        -:    0:Runs:3
        -:    1://------------------------------------------------------------------------------
        -:    2:// SPEX_Update/SPEX_Update_LU_ColRep.c: perform LU update for column replacement
        -:    3://------------------------------------------------------------------------------
        -:    4:
        -:    5:// SPEX_Update: (c) 2020-2021, Jinhao Chen, Timothy A. Davis, Erick
        -:    6:// Moreno-Centeno, Texas A&M University.  All Rights Reserved.  See
        -:    7:// SPEX_Update/License for the license.
        -:    8:
        -:    9://------------------------------------------------------------------------------
        -:   10:
        -:   11:// Purpose: This function is to perform LU update for column replacement.
        -:   12:// L and UT are modified regardless of success or failure.
        -:   13:// In the output, vk will be swapped with A->v[k].
        -:   14:
        -:   15:#define SPEX_FREE_ALL                \
        -:   16:    SPEX_FREE(h);                    \
        -:   17:    SPEX_FREE(h_for_vk);             \
        -:   18:    SPEX_FREE(map);                  \
        -:   19:    SPEX_FREE(Lr_offdiag);           \
        -:   20:    SPEX_FREE(Uc_offdiag);           \
        -:   21:    SPEX_FREE(Uci);                  \
        -:   22:    SPEX_FREE(Ucx);                  \
        -:   23:    spex_scattered_vector_free(&Lk_dense_col, option);\
        -:   24:    spex_scattered_vector_free(&Uk_dense_row, option);\
        -:   25:    spex_scattered_vector_free(&vk_dense, option);
        -:   26:
        -:   27:#include "spex_update_internal.h"
        -:   28:
        -:   29:#define SL(k) (L->v[(k)]->scale)
        -:   30:#define SU(k) (UT->v[(k)]->scale)
        -:   31:
    13510:   32:SPEX_info SPEX_Update_LU_ColRep
        -:   33:(
        -:   34:    SPEX_matrix *A,         // n-by-n original matrix in dynamic_CSC form
        -:   35:    SPEX_matrix *L,         // n-by-n lower triangular factorization of A in
        -:   36:                            // dynamic_CSC form. The rows of L are in the same
        -:   37:                            // order as the rows of A, while the columns of L
        -:   38:                            // are permuted such that L->v[j] (i.e., j-th
        -:   39:                            // column of L) contains the j-th pivot, which
        -:   40:                            // would be L->v[j]->x[0], (i.e., L->v[j]->i[0] ==
        -:   41:                            // P[j]). This matrix will be modified during the
        -:   42:                            // update process. Therefore, if this function
        -:   43:                            // fails for any reason, the returned L should be
        -:   44:                            // considered as undefined.
        -:   45:    SPEX_matrix *UT,        // The transpose of U in dynamic_CSC form, where U
        -:   46:                            // is the n-by-n upper triangular factorization of
        -:   47:                            // A. The columns of U (or the rows of UT) are in
        -:   48:                            // the same order as the columns of A, while the
        -:   49:                            // rows of U (or the columns of UT) are permuted
        -:   50:                            // such that UT->v[j] (i.e., j-th column of UT, or
        -:   51:                            // j-th row of U) contains the j-th pivot, which
        -:   52:                            // would be UT->v[j]->x[0], (i.e., UT->v[j]->i[0]
        -:   53:                            // == Q[j]). This matrix will be modified during
        -:   54:                            // the update process. Therefore, if this function
        -:   55:                            // fails for any reason, the returned UT should be
        -:   56:                            // considered as undefined.
        -:   57:    SPEX_matrix *rhos,      // n-by-1 dense matrix for the array of pivots
        -:   58:    int64_t *P,             // Row permutation
        -:   59:    int64_t *P_inv,         // Inverse of row permutation
        -:   60:    int64_t *Q,             // Column permutation
        -:   61:    int64_t *Q_inv,         // Inverse of column permutation
        -:   62:    SPEX_vector **vk,       // Pointer to the inserted column in the compressed
        -:   63:                            // column form, the rows of vk are in the same order
        -:   64:                            // as A. This vector will be swapped with A->v[k]
        -:   65:                            // in the output upon return, regardless of failure.
        -:   66:    int64_t k,              // The column index that vk will be inserted
        -:   67:    const SPEX_options *option// Command parameters
        -:   68:)
        -:   69:{
        -:   70:    //--------------------------------------------------------------------------
        -:   71:    // check inputs
        -:   72:    //--------------------------------------------------------------------------
   13510*:   73:    if (!spex_initialized()) {return SPEX_PANIC;}
   13510*:   74:    SPEX_REQUIRE(A , SPEX_DYNAMIC_CSC, SPEX_MPZ);
   13510*:   75:    SPEX_REQUIRE(L , SPEX_DYNAMIC_CSC, SPEX_MPZ);
   13510*:   76:    SPEX_REQUIRE(UT, SPEX_DYNAMIC_CSC, SPEX_MPZ);
   13510*:   77:    SPEX_REQUIRE(rhos, SPEX_DENSE, SPEX_MPZ);
    13510:   78:    if (L->n  != L->m || rhos->m != L->m ||
    13510:   79:        UT->m != L->m || UT->n   != L->m ||
    13510:   80:        A->m  != L->m || A->n    != L->m ||
    13491:   81:        !vk || !(*vk) || (*vk)->nz <= 0 || !((*vk)->x) || !((*vk)->i) ||
    13491:   82:        !P || !P_inv  || !Q || !Q_inv || k < 0 || k >= L->m)
        -:   83:    {
       19:   84:        return SPEX_INCORRECT_INPUT;
        -:   85:    }
        -:   86:
        -:   87:    //--------------------------------------------------------------------------
        -:   88:    // initialize workspace
        -:   89:    //--------------------------------------------------------------------------
        -:   90:    SPEX_info info;
        -:   91:    int sgn_vkk, sgn_vkn, r;
    13491:   92:    int64_t ks, p, i, j, inext, jnext, n = L->n;
    13491:   93:    int64_t *h = NULL, *h_for_vk = NULL, *Lr_offdiag = NULL, *Uc_offdiag = NULL,
    13491:   94:        *Uci = NULL, *Ucx = NULL, *map = NULL;
    13491:   95:    spex_scattered_vector *Lk_dense_col = NULL, *Uk_dense_row = NULL,
    13491:   96:        *vk_dense = NULL;
    13491:   97:    mpz_t *sd = rhos->x.mpz;
        -:   98:
        -:   99:    //--------------------------------------------------------------------------
        -:  100:    // allocate space for workspace
        -:  101:    //--------------------------------------------------------------------------
    13491:  102:    h          = (int64_t*) SPEX_calloc(n, sizeof(int64_t));
    13491:  103:    h_for_vk   = (int64_t*) SPEX_calloc(n, sizeof(int64_t));
    13491:  104:    Uc_offdiag = (int64_t*) SPEX_malloc(n* sizeof(int64_t));
    13491:  105:    Lr_offdiag = (int64_t*) SPEX_malloc(n* sizeof(int64_t));
    13491:  106:    Uci        = (int64_t*) SPEX_malloc(n* sizeof(int64_t));
    13491:  107:    Ucx        = (int64_t*) SPEX_malloc(n* sizeof(int64_t));
    13491:  108:    map        = (int64_t*) SPEX_malloc(n* sizeof(int64_t));
    13491:  109:    if (!h || !h_for_vk || !Uci || !Ucx || !map)
        -:  110:    {
      336:  111:        SPEX_FREE_ALL;
      336:  112:        return SPEX_OUT_OF_MEMORY;
        -:  113:    }
        -:  114:
        -:  115:    //--------------------------------------------------------------------------
        -:  116:    // initialize environment for the inserted column
        -:  117:    //--------------------------------------------------------------------------
    13155:  118:    SPEX_CHECK(spex_update_get_scattered_v(&vk_dense, NULL, *vk, n, n, NULL,
        -:  119:        true, option));
        -:  120:    //index of column of L used to perform IPGE for vk
    12627:  121:    int64_t last_update = -1;
        -:  122:    // the index of last nnz in vk(P[last_update+1,n-2])
    12627:  123:    int64_t vk_2ndlastnz = -1;
        -:  124:    // P_inv[vk->i[0...vk_top-1]] <= last_update
    12627:  125:    int64_t vk_top = 0;
    12627:  126:    int64_t maximum, last_max_ks, LU_scaned, Uc_jnext_nz = 0;
    12627:  127:    int use_col_n = 0; // 0: unknown; 1: use; -1: don't use
    51439:  128:    for (p = 0; p < vk_dense->nz; p++)
        -:  129:    {
    38812:  130:        i = vk_dense->i[p];
    38812:  131:        if (P_inv[i] > vk_2ndlastnz && P_inv[i] != n-1)
        -:  132:        {
    31001:  133:            vk_2ndlastnz = P_inv[i];
        -:  134:        }
    38812:  135:        h_for_vk[i] = -1;
        -:  136:    }
        -:  137:
        -:  138:    // update column k of A by swapping A->v[k] with vk
        -:  139:    SPEX_vector *tmpv;
    12627:  140:    tmpv = *vk; *vk = A->v[k]; A->v[k] = tmpv;
        -:  141:
        -:  142:    //--------------------------------------------------------------------------
        -:  143:    // initialize for the while loop
        -:  144:    //--------------------------------------------------------------------------
    12627:  145:    LU_scaned = Q_inv[k];
        -:  146:    // remove column k of U
    45625:  147:    for (i = 0; i < LU_scaned; i++)
        -:  148:    {
    64402:  149:        for (p = 1 ; p < UT->v[i]->nz; p++)
        -:  150:        {
    50232:  151:            j = UT->v[i]->i[p];
    50232:  152:            if (j == k)
        -:  153:            {
        -:  154:                // move the last entry to current position
    18828:  155:                UT->v[i]->nz--;
   18828*:  156:                SPEX_CHECK(SPEX_mpz_swap(UT->v[i]->x[p],
        -:  157:                                         UT->v[i]->x[UT->v[i]->nz]));
    18828:  158:                UT->v[i]->i[p] = UT->v[i]->i[UT->v[i]->nz];
    18828:  159:                break;
        -:  160:            }
        -:  161:        }
        -:  162:    }
    12627:  163:    k = LU_scaned; // = Q_inv[k];
    12627:  164:    last_max_ks = k;
        -:  165:    // initialize entries k+1:n
    42802:  166:    for (i = k+1; i < n ; i++)
        -:  167:    {
    30175:  168:        Lr_offdiag[i] = -1;
    30175:  169:        Uc_offdiag[i] = -1;
        -:  170:    }
        -:  171:
    12627:  172:    if (k < n-1)
        -:  173:    {
        -:  174:        // build Lk_dense_col and Uk_dense_row, remove explicit 0, search for
        -:  175:        // inext and jnext
    11091:  176:        SPEX_CHECK(spex_update_get_scattered_v(&Lk_dense_col, &inext, L->v[k],
        -:  177:            n, k, P_inv, false, option));
    10640:  178:        SPEX_CHECK(spex_update_get_scattered_v(&Uk_dense_row, &jnext, UT->v[k],
        -:  179:            n, k, Q_inv, false, option));
        -:  180:    }
        -:  181:
        -:  182:    //--------------------------------------------------------------------------
        -:  183:    // push column k to position n-1
        -:  184:    //--------------------------------------------------------------------------
    24931:  185:    while (k < n-1)
        -:  186:    {
        -:  187:#ifdef SPEX_DEBUG
        -:  188:        // check for L and Lk_dense_col
        -:  189:        for (int64_t ii = 0; ii < n; ii++)
        -:  190:        {
        -:  191:            // check if the first entry of all L->v is the pivot
        -:  192:            if (ii != k && L->v[ii]->i[0] != P[ii])
        -:  193:            {
        -:  194:                printf("Incorrect col %ld of L\n",ii);
        -:  195:                SPEX_CHECK(SPEX_PANIC);
        -:  196:            }
        -:  197:
        -:  198:            // check if Lk_dense_col has nonzero entry but not in nnz pattern
        -:  199:            SPEX_CHECK(SPEX_mpz_sgn(&r, Lk_dense_col->x[ii]));
        -:  200:            if (r != 0)
        -:  201:            {
        -:  202:                bool gotcha = false;
        -:  203:                for (int64_t pp = 0; pp < Lk_dense_col->nz; pp++)
        -:  204:                {
        -:  205:                    if (Lk_dense_col->i[pp] == ii)
        -:  206:                    {
        -:  207:                        gotcha = true;
        -:  208:                        break;
        -:  209:                    }
        -:  210:                }
        -:  211:                if (gotcha == false)
        -:  212:                {
        -:  213:                    printf("file %s line %d\n",__FILE__,__LINE__);
        -:  214:                    for (int64_t pp = 0; pp < Lk_dense_col->nz; pp++)
        -:  215:                    {
        -:  216:                        printf("%ld ", Lk_dense_col->i[pp]);
        -:  217:                    }
        -:  218:                    SPEX_CHECK(SPEX_gmp_printf("\nLk(%ld)=%Zd\n",
        -:  219:                        ii, Lk_dense_col->x[ii]));
        -:  220:                    SPEX_CHECK(SPEX_PANIC);
        -:  221:                }
        -:  222:            }
        -:  223:        }
        -:  224:
        -:  225:        // check for UT and Uk_dense_row
        -:  226:        for (int64_t ii =0;ii<n;ii++)
        -:  227:        {
        -:  228:            // check if the first entry of all UT->v is the pivot
        -:  229:            if (ii != k && UT->v[ii]->i[0] != Q[ii])
        -:  230:            {
        -:  231:                printf("Incorrect row %ld of U\n",ii);
        -:  232:                SPEX_CHECK(SPEX_PANIC);
        -:  233:            }
        -:  234:
        -:  235:            // check if Uk_dense_row has nonzero entry but not in nnz pattern
        -:  236:            SPEX_CHECK(SPEX_mpz_sgn(&r, Uk_dense_row->x[ii]));
        -:  237:            if (r != 0)
        -:  238:            {
        -:  239:                bool gotcha = false;
        -:  240:                for(int64_t pp = 0; pp < Uk_dense_row->nz; pp++)
        -:  241:                {
        -:  242:                    if (Uk_dense_row->i[pp] == ii)
        -:  243:                    {
        -:  244:                        gotcha = true;
        -:  245:                        break;
        -:  246:                    }
        -:  247:                }
        -:  248:                if (gotcha == false)
        -:  249:                {
        -:  250:                    printf("file %s line %d\n",__FILE__,__LINE__);
        -:  251:                    for (int64_t pp = 0; pp < Uk_dense_row->nz; pp++)
        -:  252:                    {
        -:  253:                        printf("%ld ", Uk_dense_row->i[pp]);
        -:  254:                    }
        -:  255:                    SPEX_CHECK(SPEX_gmp_printf("\nUk(%ld)=%Zd\n",
        -:  256:                        ii, Uk_dense_row->x[ii]));
        -:  257:                    SPEX_CHECK(SPEX_PANIC);
        -:  258:                }
        -:  259:            }
        -:  260:        }
        -:  261:
        -:  262:        // check for sd and h
        -:  263:        for (int64_t ii = 0; ii < n; ii++)
        -:  264:        {
        -:  265:            // check if any pivot is zero
        -:  266:            SPEX_CHECK(SPEX_mpz_sgn(&r, sd[ii]));
        -:  267:            if (r == 0)
        -:  268:            {
        -:  269:                printf("sd[%ld]=0 at file %s line %d\n",ii,__FILE__,__LINE__);
        -:  270:                SPEX_CHECK(SPEX_PANIC);
        -:  271:            }
        -:  272:
        -:  273:            // check if any entry in history vector is out of range
        -:  274:            if (h[ii] < -1)
        -:  275:            {
        -:  276:                printf("h[%ld]=%ld at file %s line %d\n", ii, h[ii],
        -:  277:                    __FILE__, __LINE__);
        -:  278:                SPEX_CHECK(SPEX_PANIC);
        -:  279:            }
        -:  280:        }
        -:  281:
        -:  282:        if (jnext < n)
        -:  283:        {
        -:  284:            ASSERT (jnext > k);
        -:  285:            SPEX_CHECK(SPEX_mpz_sgn(&r, Uk_dense_row->x[Q[jnext]]));
        -:  286:            ASSERT (r != 0);
        -:  287:        }
        -:  288:        else // jnext == n, i.e., only 1 nnz in row k of U
        -:  289:        {
        -:  290:            // explicit zero is always removed from nnz pattern of Uk_dense_row
        -:  291:            // but not for Lk_dense_col
        -:  292:            ASSERT(Uk_dense_row->nz == 1);
        -:  293:        }
        -:  294:        if (inext < n)
        -:  295:        {
        -:  296:            ASSERT (inext > k);
        -:  297:            SPEX_CHECK(SPEX_mpz_sgn(&r, Lk_dense_col->x[P[inext]]));
        -:  298:            ASSERT (r != 0);
        -:  299:        }
        -:  300:#endif
        -:  301:
        -:  302:        //----------------------------------------------------------------------
        -:  303:        // get the (k-1)-th IPGE update of inserted column, so that vk
        -:  304:        // will be ready to be inserted as column k if needed
        -:  305:        //----------------------------------------------------------------------
    20467:  306:        SPEX_CHECK(spex_update_triangular_solve(vk_dense, &vk_top, h_for_vk,
        -:  307:            &last_update, &vk_2ndlastnz, k, L, UT,
        -:  308:            (const SPEX_matrix*)rhos, P, P_inv));
   20015*:  309:        SPEX_CHECK(SPEX_mpz_sgn(&sgn_vkk, vk_dense->x[P[k]]));
   20015*:  310:        SPEX_CHECK(SPEX_mpz_sgn(&sgn_vkn, vk_dense->x[P[n-1]]));
        -:  311:
        -:  312:        //----------------------------------------------------------------------
        -:  313:        // check for singularity
        -:  314:        //----------------------------------------------------------------------
        -:  315:        // report singular if 
        -:  316:        // - remaining entries in current row of U are 0s and the current row
        -:  317:        //   of vk is also 0.
        -:  318:        // - OR all entries below (k-1)-th row in vk are zeros
        -:  319:        // - OR all off-diagonal entries below (k-1)-th row in vk
        -:  320:        //   and column n-1 of U are zeros
        -:  321:        // That is, report singular for any of the following case
        -:  322:        // x 0 0 0 0 0          x . . . . 0          x . . . 0 0   <- row k
        -:  323:        // . x . . . .          . x . . . 0          . x . . 0 0
        -:  324:        // . . x . . .    or    . . x . . 0    or    . . x . 0 0
        -:  325:        // . . . x . .          . . . x . 0          . . . x 0 0
        -:  326:        // . . . . x .          . . . . x 0          . . . . x x
        -:  327:        //           ^                    ^                    ^
        -:  328:        //           |                    |                    |
        -:  329:        //          vk                    vk                   vk
        -:  330:        // case 1
    20015:  331:        if (jnext == n && sgn_vkk == 0 )
        -:  332:        {
        5:  333:            SPEX_FREE_ALL;
        5:  334:            return SPEX_SINGULAR;
        -:  335:        }
        -:  336:        // case 2
    20010:  337:        if (vk_2ndlastnz == -1 && sgn_vkn == 0)
        -:  338:        {
        2:  339:            SPEX_FREE_ALL;
        2:  340:            return SPEX_SINGULAR;
        -:  341:        }
        -:  342:        // case 3, check only when whole U is scaned 
    20008:  343:        if (vk_2ndlastnz == -1 && LU_scaned == n-1 && Uc_offdiag[n-1] <= k)
        -:  344:        {
     143*:  345:            SPEX_CHECK(SPEX_mpz_sgn(&r, Uk_dense_row->x[Q[n-1]]));
      143:  346:            if (r == 0)
        -:  347:            {
        1:  348:                SPEX_FREE_ALL;
        1:  349:                return SPEX_SINGULAR;
        -:  350:            }
        -:  351:        }
        -:  352:
        -:  353:        //----------------------------------------------------------------------
        -:  354:        // see if we can finish the update here with column swapping
        -:  355:        //----------------------------------------------------------------------
        -:  356:        // if the next nnz in current row is in vk, then use vk, which will
        -:  357:        // help to avoid performing extra ipge iterations for vk
    20007:  358:        if (jnext == n)
        -:  359:        {
        -:  360:            // if jnext == n, swapping columns k and vk will be more efficient,
        -:  361:            // since there is no need to backtrack vk (i.e., col n) (we just
        -:  362:            // perform k-th IPGE iteration for column n), and column n-1 can be
        -:  363:            // updated by scaling after CPPU.
     2602:  364:            ks = n;
     2602:  365:            SPEX_CHECK(spex_update_finalize_and_insert_vk(vk_dense, h_for_vk,
        -:  366:                UT, L, (const SPEX_matrix*)rhos, Q, P_inv, k, k, option));
        -:  367:
     2567:  368:            SPEX_CHECK(spex_update_cppu(L, UT, rhos, Lk_dense_col,
        -:  369:                Uk_dense_row, &inext, &jnext, h, Q, Q_inv,
        -:  370:                P, P_inv, NULL, NULL, 0, k, ks, option));
     2489:  371:            break;
        -:  372:        }
        -:  373:#ifdef SPEX_DEBUG
        -:  374:        printf("k(%ld) inext(%ld) jnext(%ld)\n",k, inext,jnext);
        -:  375:#endif
        -:  376:
        -:  377:        //----------------------------------------------------------------------
        -:  378:        // if L(:,k) has zero off-diagonal, then only perform dppu, which will
        -:  379:        // maintain the sparsity of L(:,k). Use dppu1 if possible.
        -:  380:        // When arriving the last iteration, always use the inserted column
        -:  381:        // if possible, since we can perform less IPGE iterations for it.
        -:  382:        //----------------------------------------------------------------------
    17405:  383:        if (inext == n)
        -:  384:        {
     4677:  385:            if (Lk_dense_col->nz != 1)
        -:  386:            {
        1:  387:                Lk_dense_col->nz = 1;
        1:  388:                Lk_dense_col->i[0] = P[k];
        -:  389:            }
        -:  390:
        -:  391:            // scan L(:, k+1:n-1) and U(k+1:n-1, :)
     4677:  392:            if (LU_scaned < n-1)
        -:  393:            {
     9379:  394:                for (j = k+1; j < n; j++)
        -:  395:                {
        -:  396:#ifdef SPEX_DEBUG
        -:  397:                    // the first entry should be the corresponding pivot
        -:  398:                    ASSERT(P_inv[L->v[j]->i[0]] == j);
        -:  399:                    int sgn;
        -:  400:                    SPEX_CHECK(SPEX_mpz_sgn(&sgn, L->v[j]->x[0]));
        -:  401:                    ASSERT (sgn != 0);
        -:  402:#endif
     7994:  403:                    for (p = 1; p < L->v[j]->nz; p++)
        -:  404:                    {
        -:  405:                        // row index
     1981:  406:                        i = P_inv[L->v[j]->i[p]];
        -:  407:
        -:  408:                        // get the last row-wise off-diagonal entries
     1981:  409:                        Lr_offdiag[i] = j; // get the column index
        -:  410:                    }
        -:  411:                }
        -:  412:
     9379:  413:                for (i = k+1; i < n; i++)
        -:  414:                {
        -:  415:                    ASSERT(Q_inv[UT->v[i]->i[0]] == i);
     7633:  416:                    for (p = 1 ; p < UT->v[i]->nz; p++)
        -:  417:                    {
     1620:  418:                        j = Q_inv[UT->v[i]->i[p]];
     1620:  419:                        Uc_offdiag[j] = i;
        -:  420:                    }
        -:  421:                }
        -:  422:
     3366:  423:                LU_scaned = n-1;
        -:  424:            }
        -:  425:
        -:  426:            // build the map to find ks if current map is out of date.
        -:  427:            // all the swaps (i.e., pivot updates) except the last one
        -:  428:            // using this map will not change the nnz patter of current
        -:  429:            // frame, since only scaling will be involved.
        -:  430:            // x 0 0 0 0 0 0 0 0 x 
        -:  431:            // 0 x . 0 . . . . . .
        -:  432:            // 0 . x 0 . . . . . .
        -:  433:            // 0 0 0 x 0 . . . . .
        -:  434:            // 0 . . . x 0 0 0 0 .
        -:  435:            // 0 . . . 0 x . . 0 .
        -:  436:            // 0 . . . 0 . x . 0 .
        -:  437:            // 0 . . . 0 . . x 0 .
        -:  438:            // 0 . . . . 0 0 0 x .
        -:  439:            // 0 . . . . . . . . x
        -:  440:            // ^     ^ ^       ^
        -:  441:            // |     | |       |
        -:  442:            // 2     5 6       10
        -:  443:            // we will swap 2 and 5 first, then with 6, and with 10
        -:  444:            // sequencially, which can be found from the map eazily
     4677:  445:            if (n-2 > last_max_ks)
        -:  446:            {
     5026:  447:                for (j = k+1; j <= n-2; j++)
        -:  448:                {
     2647:  449:                    maximum = SPEX_MAX(Lr_offdiag[j], Uc_offdiag[j]);
     2760:  450:                    for (i = k; i < j;)
        -:  451:                    {
     2760:  452:                        if (maximum <= i)
        -:  453:                        {
     2647:  454:                            map[i] = j;
     2647:  455:                            break;
        -:  456:                        }
      113:  457:                        i = map[i];
        -:  458:                    }
        -:  459:                }
     2379:  460:                last_max_ks = n-2;
        -:  461:            }
        -:  462:
        -:  463:            // Check if we should use the inserted column when either column
        -:  464:            // Q[n-1] or vk could be used
        -:  465:            //        x . . . . .          x . . . . .  <- row k
        -:  466:            //        0 x . . . 0          0 x . . 0 .
        -:  467:            //        0 . x . . 0    or    0 . x . 0 .
        -:  468:            //        0 . . x . 0          0 . . x 0 .
        -:  469:            //        0 0 0 0 x x          0 0 0 0 x .
     4677:  470:            if (use_col_n == 0 && Lr_offdiag[n-1] <= k &&
     2812:  471:                (vk_2ndlastnz <= k /*vk could be used*/ ||
      264:  472:                 Uc_offdiag[n-1] <= k /*col Q[n-1] could be used*/))
        -:  473:            {
     2811:  474:                if (sgn_vkn == 0)// vk_dense[P[n-1]] == 0
        -:  475:                {
        -:  476:                    // the inserted column cannot be used
     1597:  477:                    use_col_n = -1;
        -:  478:                }
        -:  479:                else
        -:  480:                {
        -:  481:                    // use vk only when the index of off diagonal entry in
        -:  482:                    // column Q(n-1) of U is larger than vk_2ndlastnz, that is
        -:  483:                    //        x . . . . .  <- row k
        -:  484:                    //        0 x . . . 0
        -:  485:                    //        0 . x . x 0
        -:  486:                    //        0 . . x 0 0
        -:  487:                    //        0 0 0 0 x x
        -:  488:                    //                  ^
        -:  489:                    //                  |
        -:  490:                    //                 vk at (k-1)-th IPGE
     1214:  491:                    if (Uc_offdiag[n-1] > vk_2ndlastnz && vk_2ndlastnz <= k)
        -:  492:                    {
        5:  493:                        use_col_n = 1;
        -:  494:                    }
        -:  495:                    else
        -:  496:                    {
     1209:  497:                        use_col_n = -1;
        -:  498:                    }
        -:  499:                }
     2811:  500:                if (use_col_n == -1)
        -:  501:                {
     2806:  502:                    maximum = SPEX_MAX(Lr_offdiag[n-1], Uc_offdiag[n-1]);
        -:  503:                }
        -:  504:                else
        -:  505:                {
        5:  506:                    maximum = SPEX_MAX(Lr_offdiag[n-1], vk_2ndlastnz);
        -:  507:                }
     2812:  508:                for (i = k; i < n-1;)
        -:  509:                {
     2812:  510:                    if (maximum <= i)
        -:  511:                    {
     2811:  512:                        map[i] = n-1;
     2811:  513:                        break;
        -:  514:                    }
        1:  515:                    i = map[i];
        -:  516:                }
        -:  517:
     2811:  518:                last_max_ks = n-1;
        -:  519:            }
        -:  520:
        -:  521:            // get ks from the map
     4677:  522:            ks = map[k];
        -:  523:            ASSERT(ks > k);
     4677:  524:            if (ks == n-1 && use_col_n == 1)
        -:  525:            {
       5*:  526:                SPEX_CHECK(spex_update_finalize_and_insert_vk(vk_dense,
        -:  527:                    h_for_vk, UT, L, (const SPEX_matrix*)rhos, Q, P_inv, k,
        -:  528:                    n-1, option));
        5:  529:                ks = n;
        -:  530:            }
     4677:  531:            if (jnext > ks || (ks == n && jnext >= n-1 && sgn_vkk == 0))
        -:  532:            {
      289:  533:                SPEX_CHECK(spex_update_dppu1(L, UT, rhos, Lk_dense_col,
        -:  534:                    Uk_dense_row, &inext, h, Q, Q_inv, P, P_inv, k, ks,
        -:  535:                    option));
        -:  536:            }
        -:  537:            else
        -:  538:            {
     4388:  539:                SPEX_CHECK(spex_update_dppu2(L, UT, rhos, Lk_dense_col,
        -:  540:                    Uk_dense_row, &jnext, h, Q, Q_inv, P, P_inv, k, ks,
        -:  541:                    option));
        -:  542:            }
        -:  543:        }
        -:  544:        else // if L(:,k) has more than 1 nnz
        -:  545:        {
        -:  546:            // scan L(:, k+1:jnext) and U(k+1:jnext, :)
    12728:  547:            if (LU_scaned < jnext && (jnext > k+1 || jnext == n-1))
        -:  548:            {
    15809:  549:                for (j = k+1; j <= jnext; j++)
        -:  550:                {
        -:  551:#ifdef SPEX_DEBUG
        -:  552:                    // the first entry should be the corresponding pivot
        -:  553:                    ASSERT(P_inv[L->v[j]->i[0]] == j);
        -:  554:                    int sgn;
        -:  555:                    SPEX_CHECK(SPEX_mpz_sgn(&sgn, L->v[j]->x[0]));
        -:  556:                    ASSERT (sgn != 0);
        -:  557:#endif
    17340:  558:                    for (p = 1; p < L->v[j]->nz; p++)
        -:  559:                    {
        -:  560:                        // row index
     7344:  561:                        i = P_inv[L->v[j]->i[p]];
     7344:  562:                        if (i > jnext) {continue;}
        -:  563:
        -:  564:                        // get the last row-wise off-diagonal entries
     3225:  565:                        Lr_offdiag[i] = j; // get the column index
        -:  566:                    }
        -:  567:                }
        -:  568:
     5813:  569:                Uc_jnext_nz = 0; // # of nnz in U(k+1:jnext-1, jnext)
    15809:  570:                for (i = k+1; i <= jnext; i++)
        -:  571:                {
        -:  572:                    ASSERT(Q_inv[UT->v[i]->i[0]] == i);
    17247:  573:                    for (p = 1 ; p < UT->v[i]->nz; p++)
        -:  574:                    {
     7251:  575:                        j = Q_inv[UT->v[i]->i[p]];
     7251:  576:                        if (j > jnext) {continue;}
     4013:  577:                        else if (j == jnext)
        -:  578:                        {
     3686:  579:                            Uci[Uc_jnext_nz] = i;
     3686:  580:                            Ucx[Uc_jnext_nz] = p;
     3686:  581:                            Uc_jnext_nz++;
        -:  582:                        }
     4013:  583:                        Uc_offdiag[j] = i;
        -:  584:                    }
        -:  585:                }
        -:  586:
     5813:  587:                LU_scaned = jnext;
        -:  588:            }
        -:  589:
        -:  590:            // The case when jnext == n (that is, the remaining entries in the
        -:  591:            // current row except the n-th column (vk) are all zeroes) is
        -:  592:            // handled. And the case when all remaining entries in current
        -:  593:            // row are zeroes will cause singularity. Therefore, the cases
        -:  594:            // left to consider here are U(k,Q(n-1:n))=[x,0] and
        -:  595:            // U(k,Q(n-1:n)) = [x,x]
    12728:  596:            if (jnext == n-1)
        -:  597:            {
     3774:  598:                if (sgn_vkk == 0) // U(k,n) = vk[P[k]] == 0
        -:  599:                {
        -:  600:                    // if jnext == n-1 and U(k,n) == 0, use dppu1 with column n
        -:  601:                    // only when we see the following pattern
        -:  602:                    //
        -:  603:                    //             x 0 0 0 x 0
        -:  604:                    //             0 x . . . 0
        -:  605:                    //             0 . x . . 0
        -:  606:                    //             0 . . x . 0
        -:  607:                    //             . 0 0 0 x x
        -:  608:                    //                       ^
        -:  609:                    //                       |
        -:  610:                    //                   col n or vk
        -:  611:                    //
      224:  612:                    if (vk_2ndlastnz == -1/*then vk[P[n-1]] must != 0*/  &&
        2:  613:                        Lr_offdiag[n-1] <= k && inext >= n-1)
        -:  614:                    {
        -:  615:                        // perform diagnal swapping with columns n
        2:  616:                        ks = n;
       2*:  617:                        SPEX_CHECK(spex_update_finalize_and_insert_vk(vk_dense,
        -:  618:                            h_for_vk, UT, L, (const SPEX_matrix*)rhos, Q,
        -:  619:                            P_inv, k, n-1, option));
       2*:  620:                        SPEX_CHECK(spex_update_dppu1(L, UT, rhos, Lk_dense_col,
        -:  621:                            Uk_dense_row, &inext, h, Q, Q_inv, P,
        -:  622:                            P_inv, k, ks, option));
        2:  623:                        break;
        -:  624:                    }
        -:  625:                }
        -:  626:                else
        -:  627:                {
        -:  628:                    // if jnext == n-1 and U(k,n) != 0, swapping columns k and
        -:  629:                    // n will be more efficient, since no matter column n or
        -:  630:                    // n-1 is swapped, column n needs n IPGE iterations, while
        -:  631:                    // if column n-1 is swapped, additional backtracking for
        -:  632:                    // column n-1 needs to be performed.
     3550:  633:                    ks = n;
     3550:  634:                    SPEX_CHECK(spex_update_finalize_and_insert_vk(vk_dense,
        -:  635:                        h_for_vk, UT, L, (const SPEX_matrix*)rhos, Q,
        -:  636:                        P_inv, k, k, option));
     3537:  637:                    SPEX_CHECK(spex_update_cppu(L, UT, rhos, Lk_dense_col,
        -:  638:                        Uk_dense_row, &inext, &jnext, h, Q, Q_inv, P, P_inv,
        -:  639:                        NULL, NULL, 0, k, ks, option));
     3433:  640:                    break;
        -:  641:                }
        -:  642:            }
        -:  643:
        -:  644:            // Since Uc_offdiag is obtained before the updating process, and
        -:  645:            // therefore does not include any potential fillins added to
        -:  646:            // row k of U during this process. For this reason, even if the
        -:  647:            // index of 1st offdiag in column jnext of U is less than k, we
        -:  648:            // will use cppu to swap k and jnext, since we have checked
        -:  649:            // Uk_dense_row->x[Q[jnext]] != 0
     9176:  650:            if (inext == k+1 || jnext == k+1 || Uc_offdiag[jnext] <= k)
        -:  651:            {
     8576:  652:                if (jnext == k+1 || Uc_offdiag[jnext] <= k)
        -:  653:                {
     7077:  654:                    Uc_jnext_nz = 0;
        -:  655:                }
        -:  656:                // use cppu if we see one of the following patterns
        -:  657:                // x . . . .            x 0 0 0 x
        -:  658:                // x x . . .            . x . . 0
        -:  659:                // . . x . .     or     . . x . 0
        -:  660:                // . . . x .            . . . x 0
        -:  661:                // . . . . x            . . . . x
        -:  662:                // These implicitly include the case of jnext == k+1.
        -:  663:                // jnext < n holds since jnext == n has been handled,
     8576:  664:                ks = jnext;
     8576:  665:                SPEX_CHECK(spex_update_cppu(L, UT, rhos, Lk_dense_col,
        -:  666:                    Uk_dense_row, &inext, &jnext, h, Q, Q_inv, P, P_inv, Uci,
        -:  667:                    Ucx, Uc_jnext_nz, k, ks, option));
        -:  668:            }
        -:  669:            else
        -:  670:            {
     600*:  671:                ks = SPEX_MIN(n-2, (inext < jnext) ? inext: jnext-1);
        -:  672:                // build the map to find ks if current map is out of date.
        -:  673:                // all the swaps (i.e., pivot updates) except the last one
        -:  674:                // using this map will not change the nnz patter of current
        -:  675:                // frame, since only scaling will be involved.
        -:  676:                // x 0 0 0 0 0 0 0 0 x 
        -:  677:                // 0 x . 0 . . . . . .
        -:  678:                // 0 . x 0 . . . . . .
        -:  679:                // 0 0 0 x 0 . . . . .
        -:  680:                // 0 . . . x 0 0 0 0 .
        -:  681:                // 0 . . . 0 x . . 0 .
        -:  682:                // 0 . . . 0 . x . 0 .
        -:  683:                // 0 . . . 0 . . x 0 .
        -:  684:                // 0 . . . . 0 0 0 x .
        -:  685:                // 0 . . . . . . . . x
        -:  686:                // ^     ^ ^       ^
        -:  687:                // |     | |       |
        -:  688:                // 2     5 6       10
        -:  689:                // we will swap 2 and 5 first, then with 6, and with 10
        -:  690:                // sequencially, which can be found from the map eazily
      600:  691:                if (ks > last_max_ks)
        -:  692:                {
        -:  693:                    ASSERT(k+1 >= last_max_ks);
     1312:  694:                    for (j = k+1; j <= ks; j++)
        -:  695:                    {
      712:  696:                        maximum = SPEX_MAX(Lr_offdiag[j], Uc_offdiag[j]);
      714:  697:                        for (i = k; i < j;)
        -:  698:                        {
      714:  699:                            if (maximum <= i)
        -:  700:                            {
      712:  701:                                map[i] = j;
      712:  702:                                break;
        -:  703:                            }
        2:  704:                            i = map[i];
        -:  705:                        }
        -:  706:                    }
      600:  707:                    last_max_ks = ks;
        -:  708:                }
        -:  709:
        -:  710:                // get ks from the map
      600:  711:                ks = map[k];
      600:  712:                SPEX_CHECK(spex_update_dppu1(L, UT, rhos, Lk_dense_col,
        -:  713:                    Uk_dense_row, &inext, h, Q, Q_inv, P, P_inv, k, ks,
        -:  714:                    option));
        -:  715:            }
        -:  716:        }
        -:  717:
        -:  718:        // update k
        -:  719:        ASSERT(ks > k);
    13210:  720:        if(ks != n)
        -:  721:        {
    13206:  722:            k = ks;
        -:  723:        }
        -:  724:        else
        -:  725:        {
        4:  726:            break;
        -:  727:        }
        -:  728:    }
        -:  729:
        -:  730:    //--------------------------------------------------------------------------
        -:  731:    // perform any remaining work to finish the update
        -:  732:    //--------------------------------------------------------------------------
        -:  733:    // k will be the column index where vk is inserted
    10392:  734:    if (k == n-1)
        -:  735:    {
     4464:  736:        SPEX_CHECK(spex_update_triangular_solve(vk_dense, &vk_top, h_for_vk, 
        -:  737:            &last_update, NULL /*&vk_2ndlastnz*/, k, L, UT,
        -:  738:            (const SPEX_matrix*)rhos, P, P_inv));
        -:  739:        // check again in case k is initially n-1
    4352*:  740:        SPEX_CHECK(SPEX_mpz_sgn(&sgn_vkn, vk_dense->x[P[n-1]]));
     4352:  741:        if (sgn_vkn == 0)
        -:  742:        {
        4:  743:            SPEX_FREE_ALL;
        4:  744:            return SPEX_SINGULAR;
        -:  745:        }
     4348:  746:        SPEX_CHECK(spex_update_finalize_and_insert_vk(vk_dense, h_for_vk, UT, L,
        -:  747:            (const SPEX_matrix*)rhos, Q, P_inv, k, k, option));
        -:  748:        // sd[n-1]       = L(P(n-1),n-1)
    4304*:  749:        SPEX_CHECK(SPEX_mpz_set(sd[n-1],         L->v[n-1]->x[0]));
        -:  750:        // U(n-1,Q(n-1)) = L(P(n-1),n-1)
    4304*:  751:        SPEX_CHECK(SPEX_mpz_set(UT->v[n-1]->x[0], L->v[n-1]->x[0]));
     4304:  752:        UT->v[n-1]->i[0] = Q[n-1];
     4304:  753:        UT->v[n-1]->nz = 1;
        -:  754:    }
        -:  755:    else
        -:  756:    {
        -:  757:        // insert U(k,Q(k)) as the first entry in U->v[k]
     5928:  758:        p = UT->v[k]->nz;
     5928:  759:        if (p != 0)
        -:  760:        {
     3439:  761:            if (UT->v[k]->nzmax <= p)
        -:  762:            {
        -:  763:                // realloc one more entry for U(k,Q[k])
       6*:  764:                SPEX_CHECK(SPEX_vector_realloc(UT->v[k], UT->v[k]->nzmax+1,
        -:  765:                    option));
        -:  766:            }
        -:  767:            // append U(k,Q[k]) to the end of U->v[k] and swap with the
        -:  768:            // first entry
    3439*:  769:            SPEX_CHECK(SPEX_mpz_set(UT->v[k]->x[p], sd[k]));
    3439*:  770:            SPEX_CHECK(SPEX_mpz_swap(UT->v[k]->x[p], UT->v[k]->x[0]));
     3439:  771:            UT->v[k]->i[p] = UT->v[k]->i[0];
     3439:  772:            UT->v[k]->i[0] = Q[k];
     3439:  773:            UT->v[k]->nz = p+1;
        -:  774:        }
        -:  775:        else
        -:  776:        {
    2489*:  777:            SPEX_CHECK(SPEX_mpz_set(UT->v[k]->x[0], sd[k]));
     2489:  778:            UT->v[k]->i[0] = Q[k];
     2489:  779:            UT->v[k]->nz = 1;
        -:  780:        }
        -:  781:    }
        -:  782:    // S(:,k)=[1;1]
   10232*:  783:    SPEX_CHECK(SPEX_mpq_set_ui(SL(k), 1, 1));
   10232*:  784:    SPEX_CHECK(SPEX_mpq_set_ui(SU(k), 1, 1));
        -:  785:
        -:  786:    //--------------------------------------------------------------------------
        -:  787:    // check if A=LD^(-1)U
        -:  788:    //--------------------------------------------------------------------------
    10232:  789:    bool check = SPEX_OPTION_CHECK (option) ;//TODO is this ok?
    10232:  790:    if (check)
        -:  791:    {
     3367:  792:        SPEX_CHECK(spex_update_verify(L, UT, A, h,
        -:  793:        (const SPEX_matrix*)rhos, P, Q_inv, option));
        -:  794:    }
        -:  795:
     9527:  796:    SPEX_FREE_ALL;
     9527:  797:    return SPEX_OK;
        -:  798:}
