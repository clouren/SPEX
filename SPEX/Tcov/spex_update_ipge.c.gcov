        -:    0:Source:spex_update_ipge.c
        -:    0:Graph:spex_update_ipge.gcno
        -:    0:Data:spex_update_ipge.gcda
        -:    0:Runs:3
        -:    1://------------------------------------------------------------------------------
        -:    2:// SPEX_Update/spex_update_ipge.c: perform one iteration of IPGE and perform
        -:    3:// skipped any scaling process.
        -:    4://------------------------------------------------------------------------------
        -:    5:
        -:    6:// SPEX_Update: (c) 2020-2021, Jinhao Chen, Timothy A. Davis, Erick
        -:    7:// Moreno-Centeno, Texas A&M University.  All Rights Reserved.  See
        -:    8:// SPEX_Update/License for the license.
        -:    9:
        -:   10://------------------------------------------------------------------------------
        -:   11:
        -:   12:// Purpose: This function is to perform one iteration of IPGE. If the
        -:   13:// involving vector has pending scale factor(s), then it will be scaled and
        -:   14:// these factor(s) will be set to 1.
        -:   15:// In addition, this function should be used in successive IPGE
        -:   16:// updates, where history update could be involved for certain entry. Therefore,
        -:   17:// a history vector is required as a input/output. In case of a single IPGE
        -:   18:// iteration with no need for history update, this function should not be used
        -:   19:// (since the scaling for vector v can be skipped, refer to spex_update_dppu1).
        -:   20:// This function is called by the following functions:
        -:   21:// spex_update_dppu2: successive IPGE update for row k of U after swapping with
        -:   22://                   row ks of U.
        -:   23:// spex_update_cppu: compute the (n-1)-th IPGE update of column k after vk is
        -:   24://                   inserted.
        -:   25:// spex_update_triangular_solve: the REF triangular solve for LDx=v when L and
        -:   26://                   v are sparse.
        -:   27:// spex_update_forward_sub: the forward substitution when solving LDUx=b, which
        -:   28://                   is essensially REF triangular solve for LDx=b when b is
        -:   29://                   dense.
        -:   30://
        -:   31:// Algorithm explanation:
        -:   32:// Consider when performing the j-th IPGE update for x[i], and the j-th pivot
        -:   33:// is sd[j] and the j-th vector (row/column) is v. When all entries in v have
        -:   34:// no pending scale factor, v(perm[j])=sd[j], and we can perform IPGE for x[i]
        -:   35:// as
        -:   36:// x[i] = (x[i]*sd[j]-v[i]*x[perm[j]])/sd[j-1].
        -:   37:// This equation holds regardless of pending scaling factor x_scale is 1 or
        -:   38:// not.  However, when calling this function, x should have no pending scale.
        -:   39:// Otherwise, the result of IPGE update is not guaranteed to be in integer
        -:   40:// domain.
        -:   41://
        -:   42:// In addition, in case of history update is needed before the IPGE update for
        -:   43:// x[i] and/or x[perm[j]], the equation becomes
        -:   44:// x[i] = x[i]*sd[j]/sd[h[i]]- v(i)*x[perm[j]]/sd[h[perm[j]]].
        -:   45://
        -:   46:// When the IPGE update finished, all entries x[perm[1:j]] will be final,
        -:   47:// while x[perm[j+1:n]] need further update. All entries in vector x have common
        -:   48:// factor x_scale.
        -:   49:
        -:   50:
        -:   51:#define SPEX_FREE_ALL                \
        -:   52:    SPEX_MPQ_CLEAR(pending_scale);   \
        -:   53:    SPEX_MPZ_CLEAR(tmpz);
        -:   54:
        -:   55:#include "spex_update_internal.h"
        -:   56:
    48425:   57:SPEX_info spex_update_ipge // perform IPGE on x based on v
        -:   58:(
        -:   59:    spex_scattered_vector *sv_x,// array of size n for x in the scattered form.
        -:   60:                    // x could be dense if sv_x->i = NULL.
        -:   61:    int64_t *h,     // history vector for x, x[i] was last updated in the
        -:   62:                    // SPEX_FLIP(h[i])-th iteration
        -:   63:    int64_t *prev,  // prev is the index of the found previous entry of the last
        -:   64:                    // one (i.e., 2nd last entry) in v(perm). update if !prev
        -:   65:    SPEX_vector *v, // v is the vector that contains the j-th pivot
        -:   66:                    // used to compute x in the j-th IPGE iteration, which is
        -:   67:                    // the vector v in the equations mentioned above
        -:   68:    const int64_t *perm, // permutation
        -:   69:    const int64_t *perm_inv, // inverse of perm, can be NULL if prev == NULL
        -:   70:    const SPEX_matrix *rhos,// array of scaled pivots
        -:   71:    const int64_t j // column index of v
        -:   72:)
        -:   73:{
        -:   74:    SPEX_info info;
        -:   75:    int sgn;
        -:   76:    // the first entry of v must be the pivot, which must be nonzero
    48425:   77:    info = SPEX_mpz_sgn(&sgn, v->x[0]);
    48425:   78:    if (info != SPEX_OK || sgn == 0 || v->i[0] != perm[j])
        -:   79:    {
       19:   80:        return SPEX_INCORRECT_INPUT;
        -:   81:    }
        -:   82:
    48406:   83:    mpq_t pending_scale; SPEX_MPQ_SET_NULL(pending_scale);
    48406:   84:    mpz_t tmpz; SPEX_MPZ_SET_NULL(tmpz);
    48406:   85:    mpz_t *sd = rhos->x.mpz;
    48406:   86:    int64_t perm_j = perm[j];
        -:   87:
        -:   88:    // check if v has only 1 entry in the diagonal. If so, perform history
        -:   89:    // update if needed and return SPEX_OK
    48406:   90:    int64_t real_hj = SPEX_FLIP(h[perm_j]);
    48406:   91:    h[perm_j] = real_hj;
    48406:   92:    if (v->nz == 1)
        -:   93:    {
    12936:   94:        if (j-1 > real_hj) // require history update
        -:   95:        {
    4965*:   96:            SPEX_CHECK(SPEX_mpz_mul(sv_x->x[perm_j],
        -:   97:                                    sv_x->x[perm_j], sd[j-1]));
     4958:   98:            if (real_hj > -1)
        -:   99:            {
    3211*:  100:                SPEX_CHECK(SPEX_mpz_divexact(sv_x->x[perm_j],
        -:  101:                                             sv_x->x[perm_j], sd[real_hj]));
        -:  102:            }
        -:  103:        }
    12929:  104:        return SPEX_OK;
        -:  105:    }
        -:  106:
        -:  107:    int64_t p, i, real_hi;
    35470:  108:    int vscale = 0; // 1: v_scale == 1; -1: v_scale == -1; 0 none of above
   35470*:  109:    SPEX_CHECK(SPEX_mpq_init(pending_scale));
   35176*:  110:    SPEX_CHECK(SPEX_mpz_init(tmpz));
        -:  111:
   35029*:  112:    SPEX_CHECK(SPEX_mpz_cmp_ui(&sgn, SPEX_MPQ_DEN(v->scale), 1));
    35029:  113:    if (sgn == 0) // den(v_scale) == 1
        -:  114:    {
   35029*:  115:        SPEX_CHECK(SPEX_mpz_cmpabs_ui(&sgn, SPEX_MPQ_NUM(v->scale), 1));
    35029:  116:        if (sgn == 0)
        -:  117:        {
   34514*:  118:            SPEX_CHECK(SPEX_mpz_sgn(&sgn, SPEX_MPQ_NUM(v->scale)));
    34514:  119:            vscale = sgn < 0 ? -1 : 1;
        -:  120:        }
        -:  121:    }
        -:  122:
        -:  123:    // pending_scale = x[perm[j]]/sd[h[perm[j]]]
   35029*:  124:    SPEX_CHECK(SPEX_mpq_set_z(pending_scale, sv_x->x[perm_j]));
    35029:  125:    if (real_hj > -1)
        -:  126:    {
   15131*:  127:        SPEX_CHECK(SPEX_mpq_set_den(pending_scale, sd[real_hj]));
   15131*:  128:        SPEX_CHECK(SPEX_mpq_canonicalize(pending_scale));
        -:  129:    }
        -:  130:
        -:  131:    // The pivot in vector v is v->p[0], simple apply scale to it if needed
    35029:  132:    if (vscale != 1)
        -:  133:    {
     815*:  134:        SPEX_CHECK(SPEX_mpz_set(v->x[0], sd[j]));
        -:  135:    }
        -:  136:    // perform IPGE for x if the corresponding entry in v != 0, skip x(perm[j])
        -:  137:    // NOTE: this could cause fillin in x 
   102169:  138:    for (p = 1; p < v->nz; p++)
        -:  139:    {
   67404*:  140:        SPEX_CHECK(SPEX_mpz_sgn(&sgn, v->x[p]));
    67404:  141:        if (sgn == 0)    // v[i] == 0
        -:  142:        {
       66:  143:            continue;
        -:  144:        }
        -:  145:
        -:  146:        // column/row index in v
    67338:  147:        i = v->i[p];
    67338:  148:        real_hi = SPEX_FLIP(h[i]);
        -:  149:
        -:  150:        // apply scale factor to v(i): v(i) = v(i)*v_scale
    67338:  151:        if (vscale == 0)
        -:  152:        {
     515*:  153:            SPEX_CHECK(SPEX_mpz_divexact(v->x[p],
        -:  154:                                         v->x[p], SPEX_MPQ_DEN(v->scale)));
     515*:  155:            SPEX_CHECK(SPEX_mpz_mul     (v->x[p],
        -:  156:                                         v->x[p], SPEX_MPQ_NUM(v->scale)));
        -:  157:        }
    66823:  158:        else if (vscale == -1)
        -:  159:        {
     305*:  160:            SPEX_CHECK(SPEX_mpz_neg(v->x[p], v->x[p]));
        -:  161:        }
        -:  162:
        -:  163:        // x[i] = x[i]*sd[j]
   67338*:  164:        SPEX_CHECK(SPEX_mpz_sgn(&sgn, sv_x->x[i]));
    67338:  165:        if (sgn != 0)    // x[i] != 0
        -:  166:        {
        -:  167:            // x[i] = x[i]*sd[j]
    46061:  168:            SPEX_CHECK(SPEX_mpz_mul(sv_x->x[i], sv_x->x[i], sd[j]));
        -:  169:        }
    21277:  170:        else if (sv_x->i != NULL && h[i] >= -1)
        -:  171:        {
        -:  172:            ASSERT(sv_x->nz < sv_x->nzmax);
        -:  173:            // this entry was not in nnz pattern, so we add it to nnz pattern
    19123:  174:            sv_x->i[sv_x->nz] = i;
    19123:  175:            sv_x->nz ++;
        -:  176:
        -:  177:            // update prev if needed
    19123:  178:            if (prev != NULL && perm_inv != NULL && perm_inv[i] > *prev &&
    10825:  179:                perm_inv[i] != sv_x->nzmax-1)
        -:  180:            {
     6746:  181:                *prev = perm_inv[i];
        -:  182:            }
        -:  183:        }
        -:  184:
    67222:  185:        if (real_hi != real_hj)
        -:  186:        {
        -:  187:            // -----------------------------------------------------------------
        -:  188:            // x[i] = x[i]/sd[h[i]]- v(i)*x[perm[j]]/sd[h[perm[j]]].
        -:  189:            // -----------------------------------------------------------------
        -:  190:            // tmpz = floor(v(i)*pending_scale)
    34531:  191:            SPEX_CHECK(SPEX_mpz_mul(tmpz, v->x[p],
        -:  192:                                    SPEX_MPQ_NUM(pending_scale)));
   34448*:  193:            SPEX_CHECK(SPEX_mpz_fdiv_q(tmpz, tmpz,
        -:  194:                                    SPEX_MPQ_DEN(pending_scale)));
        -:  195:
        -:  196:            // x[i] = floor(x[i]/sd[h[i]])
    34448:  197:            if (real_hi > -1)
        -:  198:            {
    8581*:  199:                SPEX_CHECK(SPEX_mpz_fdiv_q(sv_x->x[i], sv_x->x[i],sd[real_hi]));
        -:  200:            }
        -:  201:
        -:  202:            // x[i] = x[i]- tmpz
    34448:  203:            SPEX_CHECK(SPEX_mpz_sub(sv_x->x[i], sv_x->x[i], tmpz));
        -:  204:        }
        -:  205:        else
        -:  206:        {
        -:  207:            // -----------------------------------------------------------------
        -:  208:            // x[i] = (x[i]-v[i]*x[perm[j]])/sd[h[i]].
        -:  209:            // -----------------------------------------------------------------
   32691*:  210:            SPEX_CHECK(SPEX_mpz_submul(sv_x->x[i], v->x[p], sv_x->x[perm_j]));
    32691:  211:            if (real_hi > -1)
        -:  212:            {
   14997*:  213:                SPEX_CHECK(SPEX_mpz_divexact(sv_x->x[i],
        -:  214:                                             sv_x->x[i], sd[real_hi]));
        -:  215:            }
        -:  216:        }
        -:  217:
        -:  218:        // update h[i] and last_nz_b4_ks
    67074:  219:        h[i] = SPEX_FLIP(j);
        -:  220:    }
        -:  221:
        -:  222:    // reset v_scale to 1
   34765*:  223:    SPEX_CHECK(SPEX_mpq_set_ui(v->scale, 1, 1));
        -:  224:
    34765:  225:    if (j-1 > real_hj) // require history update
        -:  226:    {
    15680:  227:        SPEX_CHECK(SPEX_mpz_mul(sv_x->x[perm_j],
        -:  228:                                sv_x->x[perm_j], sd[j-1]));
    15629:  229:        if (real_hj > -1)
        -:  230:        {
    3952*:  231:            SPEX_CHECK(SPEX_mpz_divexact(sv_x->x[perm_j],
        -:  232:                                         sv_x->x[perm_j], sd[real_hj]));
        -:  233:        }
        -:  234:    }
        -:  235:
    34714:  236:    SPEX_FREE_ALL;
    34714:  237:    return SPEX_OK;
        -:  238:}
