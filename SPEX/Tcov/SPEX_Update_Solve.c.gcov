        -:    0:Source:SPEX_Update_Solve.c
        -:    0:Graph:SPEX_Update_Solve.gcno
        -:    0:Data:SPEX_Update_Solve.gcda
        -:    0:Runs:3
        -:    1://------------------------------------------------------------------------------
        -:    2:// SPEX_Update/SPEX_Update_Solve: find the exact solution for Ax=b
        -:    3://------------------------------------------------------------------------------
        -:    4:
        -:    5:// SPEX_Update: (c) 2020-2021, Jinhao Chen, Timothy A. Davis, Erick
        -:    6:// Moreno-Centeno, Texas A&M University.  All Rights Reserved.  See
        -:    7:// SPEX_Update/License for the license.
        -:    8:
        -:    9://------------------------------------------------------------------------------
        -:   10:
        -:   11:/* Purpose: This function solves the linear system L(P,:)D^(-1)U(:,Q) x = b. It
        -:   12: * essnetially serves as a wrapper for all forward and backward substitution
        -:   13: * routines. This function always returns the solution matrix x as a mpz_t
        -:   14: * matrix with additional pending scale factor. If a user desires to have
        -:   15: * each value for each entries with pending scale factor applied, simply
        -:   16: * compute x->v[j]->x[i]/x->scale and convert to double or mpfr output as
        -:   17: * desired.
        -:   18: *
        -:   19: * Input/output arguments:
        -:   20: *
        -:   21: * x_handle: A pointer to the solution vectors. If x_handle = &b, then
        -:   22: *           solution of the system will overwrite original b and return it
        -:   23: *           as *x_handle. Otherwise, memory space will be allocated for
        -:   24: *           x_handle to store the exact solution of the system
        -:   25: *
        -:   26: * b:        Set of RHS vectors
        -:   27: *
        -:   28: * L:        Lower triangular matrix. Unmodified on input/output
        -:   29: *
        -:   30: * UT:       Transpose of upper triangular matrix. Unmodified on input/output
        -:   31: *
        -:   32: * A_scale:  Scale of the input matrix. Unmodified on input/output
        -:   33: *
        -:   34: * h:        array of n scalars, each entry should be >= -1
        -:   35: *
        -:   36: * rhos:     n-by-1 matrix that contains pivots
        -:   37: *
        -:   38: * P & Q_inv: the permutation vectors. unmodified on input/output.
        -:   39: *
        -:   40: * option:   command options
        -:   41: */
        -:   42:
        -:   43:#define SPEX_FREE_WORK                  \
        -:   44:    SPEX_vector_free(&v, option);
        -:   45:
        -:   46:#define SPEX_FREE_ALL                   \
        -:   47:    SPEX_FREE_WORK                      \
        -:   48:    if (overwrite_b)  {(*x_handle) = x;}\
        -:   49:    else {SPEX_matrix_free (&x, option);}
        -:   50:
        -:   51:#include "spex_update_internal.h"
        -:   52:
     3204:   53:SPEX_info SPEX_Update_Solve // solves Ax = b via REF LU factorization of A
        -:   54:(
        -:   55:    // Output
        -:   56:    SPEX_matrix **x_handle, // a n*m dense matrix contains the solution to
        -:   57:                            // the system. If users wish to overwrite the
        -:   58:                            // solution to the right-hand-side matrix b, this
        -:   59:                            // can be provided as &b. Otherwise, new space will
        -:   60:                            // be allocated for x_handle
        -:   61:    // input:
        -:   62:    SPEX_matrix *b,         // a n*m dense matrix contains the right hand
        -:   63:                            // side vector
        -:   64:    const SPEX_matrix *L,   // a n*n dynamic_CSC matrix that gives the lower
        -:   65:                            // triangular matrix
        -:   66:    const SPEX_matrix *UT,  // a n*n dynamic_CSC matrix that gives the transpose
        -:   67:                            // of the upper triangular matrix
        -:   68:    const mpq_t A_scale,    // scale of the input matrix
        -:   69:    int64_t *h,             // history vector// TODO create a wrapper without h?
        -:   70:    const SPEX_matrix *rhos,// a n*1 dense matrix that gives the array of pivots
        -:   71:    const int64_t *P,       // row permutation
        -:   72:    const int64_t *Q_inv,   // inverse of column permutation
        -:   73:    const SPEX_options* option // Command options
        -:   74:)
        -:   75:{
        -:   76:
        -:   77:    //--------------------------------------------------------------------------
        -:   78:    // check inputs
        -:   79:    //--------------------------------------------------------------------------
        -:   80:
        -:   81:    SPEX_info info ;
    3204*:   82:    if (!spex_initialized ( )) return (SPEX_PANIC) ;
        -:   83:
    3204*:   84:    SPEX_REQUIRE(L,  SPEX_DYNAMIC_CSC, SPEX_MPZ);
    3204*:   85:    SPEX_REQUIRE(UT, SPEX_DYNAMIC_CSC, SPEX_MPZ);
    3204*:   86:    SPEX_REQUIRE(rhos, SPEX_DENSE, SPEX_MPZ);
    3204*:   87:    SPEX_REQUIRE(b,    SPEX_DENSE, SPEX_MPZ);
     3204:   88:    if (!x_handle || !h || !P || !Q_inv ||
     3185:   89:        rhos->m != L->m || L->n  != L->m ||
     3185:   90:        UT->m   != L->m || UT->n != L->m || L->m != b->m)
        -:   91:    {
       19:   92:        return SPEX_INCORRECT_INPUT;
        -:   93:    }
        -:   94:
        -:   95:    //--------------------------------------------------------------------------
        -:   96:    // Declare and initialize workspace
        -:   97:    //--------------------------------------------------------------------------
        -:   98:
     3185:   99:    int64_t i, j, n = L->n;
     3185:  100:    bool overwrite_b = (*x_handle == b); // indicate if b will be overwriten
     3185:  101:    SPEX_matrix *x = NULL;               // final solution
     3185:  102:    SPEX_vector *v = NULL;
        -:  103:
        -:  104:    // allocate space for v and initialize
     3185:  105:    v = (SPEX_vector*) SPEX_malloc(sizeof(SPEX_vector));
     3185:  106:    if (!v)   { return SPEX_OUT_OF_MEMORY; }
     3175:  107:    v->x = NULL;
     3175:  108:    v->i = NULL;
     3175:  109:    v->nzmax = n;
     3175:  110:    v->nz = n;
     3175:  111:    SPEX_MPQ_SET_NULL(v->scale);         // will not be used
        -:  112:
        -:  113:    // allocate space for v->x
     3175:  114:    v->x = spex_create_mpz_array(n);
     3175:  115:    if (v->x == NULL)
        -:  116:    {
       70:  117:        SPEX_FREE(v);
       70:  118:        return SPEX_OUT_OF_MEMORY;
        -:  119:    }
        -:  120:
        -:  121:    //--------------------------------------------------------------------------
        -:  122:    // allocate space for x if needed
        -:  123:    //--------------------------------------------------------------------------
     3105:  124:    if (overwrite_b)
        -:  125:    {
       19:  126:        x = b;
       19:  127:        b = NULL;
        -:  128:    }
        -:  129:    else
        -:  130:    {
     3086:  131:        *x_handle = NULL;
        -:  132:        // make a copy of b as x
    3086*:  133:        SPEX_CHECK(SPEX_matrix_copy(&x, SPEX_DENSE, SPEX_MPZ, b, option));
        -:  134:    }
        -:  135:
        -:  136:    //--------------------------------------------------------------------------
        -:  137:    // solve each column of b seperately
        -:  138:    //--------------------------------------------------------------------------
     5786:  139:    for (j = 0; j < x->n; j++)
        -:  140:    {
        -:  141:        // swap entries in j-th column of x with v
    21034:  142:        for (i = 0; i < n; i++)
        -:  143:        {
   18029*:  144:            SPEX_CHECK(SPEX_mpz_swap(v->x[i], x->x.mpz[i+n*j]));
        -:  145:        }
        -:  146:
        -:  147:        // solve y for LD^(-1)y(P)=b, via forward substitution
     3005:  148:        SPEX_CHECK(spex_update_forward_sub(v, L, P, rhos, h));
        -:  149:
        -:  150:        // solve x for Ux(Q_inv) = y(P), via backward substitution
    2811*:  151:        SPEX_CHECK(spex_update_backward_sub(v, UT, rhos, P, Q_inv));
        -:  152:
        -:  153:        // permute v->x using P and Q_inv, and swap with x
    19419:  154:        for (i = 0; i < n; i++)
        -:  155:        {
   16638*:  156:            SPEX_CHECK(SPEX_mpz_swap(x->x.mpz[i+n*j], v->x[P[Q_inv[i]]]));
        -:  157:        }
        -:  158:    }
        -:  159:
        -:  160:    //--------------------------------------------------------------------------
        -:  161:    // update the scale for the solution.
        -:  162:    //--------------------------------------------------------------------------
        -:  163:    // set the scaling factor x->scale *= rhos[n-1] / A_scale
        -:  164:    // the real solution is obtained by x->v[j]->x[i]/x->scale
    2781*:  165:    SPEX_CHECK(SPEX_mpz_mul(SPEX_MPQ_NUM(x->scale),
        -:  166:                            SPEX_MPQ_NUM(x->scale), rhos->x.mpz[n-1]));
    2771*:  167:    SPEX_CHECK(SPEX_mpq_canonicalize(x->scale));
    2771*:  168:    SPEX_CHECK(SPEX_mpq_div(x->scale, x->scale, A_scale));
        -:  169:
        -:  170:    //--------------------------------------------------------------------------
        -:  171:    // free workspace and return result
        -:  172:    //--------------------------------------------------------------------------
        -:  173:
     2761:  174:    SPEX_FREE_WORK ;
     2761:  175:    (*x_handle) = x ;
     2761:  176:    return (SPEX_OK) ;
        -:  177:}
