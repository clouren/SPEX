        -:    0:Source:spex_left_lu_dfs.c
        -:    0:Graph:spex_left_lu_dfs.gcno
        -:    0:Data:spex_left_lu_dfs.gcda
        -:    0:Runs:6
        -:    1://------------------------------------------------------------------------------
        -:    2:// SPEX_Left_LU/spex_left_lu_dfs: depth-first search
        -:    3://------------------------------------------------------------------------------
        -:    4:
        -:    5:// SPEX_Left_LU: (c) 2019-2021, Chris Lourenco (US Naval Academy), Jinhao Chen,
        -:    6:// Erick Moreno-Centeno, Timothy A. Davis, Texas A&M.  All Rights Reserved.
        -:    7:// SPDX-License-Identifier: GPL-2.0-or-later or LGPL-3.0-or-later
        -:    8:
        -:    9://------------------------------------------------------------------------------
        -:   10:
        -:   11:/* Purpose: This function performs a depth first search of the graph of the
        -:   12: * matrix starting at node j. The output of this function is the set of nonzero
        -:   13: * indices in the xi vector.  This function is modified from CSparse/cs_dfs.
        -:   14: */
        -:   15:
        -:   16:#include "spex_left_lu_internal.h"
        -:   17:
     9705:   18:void spex_left_lu_dfs // performs a dfs of the graph of the matrix starting at node j
        -:   19:(
        -:   20:    int64_t *top,          // beginning of stack
        -:   21:    int64_t j,             // What node to start DFS at
        -:   22:    SPEX_matrix* L,        // matrix which represents the Graph of L
        -:   23:    int64_t* xi,           // the nonzero pattern
        -:   24:    int64_t* pstack,       // workspace vector
        -:   25:    const int64_t* pinv    // row permutation
        -:   26:)
        -:   27:{
        -:   28:
        -:   29:    //--------------------------------------------------------------------------
        -:   30:    // check inputs
        -:   31:    //--------------------------------------------------------------------------
        -:   32:
        -:   33:    ASSERT_KIND (L, SPEX_CSC) ;
        -:   34:
        -:   35:    // top xi etc already checked in the caller function
        -:   36:
        -:   37:    //--------------------------------------------------------------------------
        -:   38:
     9705:   39:    int64_t i, p, p2, done, jnew, head = 0;
        -:   40:
        -:   41:    // Initialize the recursion stack
     9705:   42:    xi[0] = j;
        -:   43:
    79908:   44:    while (head >= 0)
        -:   45:    {
        -:   46:        // The j value of the nonzero
    70203:   47:        j = xi[head];
        -:   48:        // The relative j value
    70203:   49:        jnew = pinv[j];
        -:   50:
        -:   51:        //----------------------------------------------------------------------
        -:   52:        // Mark L->p[j] if not marked yet
        -:   53:        //----------------------------------------------------------------------
    70203:   54:        if (!SPEX_MARKED (L->p,j))
        -:   55:        {
    39954:   56:            SPEX_MARK(L->p,j);
   39954*:   57:            pstack[head] = (jnew < 0) ? 0 : SPEX_UNFLIP(L->p[jnew]);
        -:   58:        }
        -:   59:        // Node j is done if no unvisited neighbors
    70203:   60:        done = 1;
        -:   61:
   70203*:   62:        p2 = (jnew < 0) ? 0 : SPEX_UNFLIP(L->p[jnew+1]);
        -:   63:
        -:   64:        //----------------------------------------------------------------------
        -:   65:        // Examine all neighbors of j
        -:   66:        //----------------------------------------------------------------------
   756811:   67:        for (p = pstack[head]; p < p2; p++)
        -:   68:        {
        -:   69:            // Looking at neighbor node i
   716857:   70:            i = L->i[p];
        -:   71:            // Skip already visited node
   716857:   72:            if (SPEX_MARKED(L->p,i))  {continue;}
        -:   73:
        -:   74:            // pause DFS of node j
    30249:   75:            pstack[head] = p;
        -:   76:            // Start DFS at node i
    30249:   77:            xi[++head] = i;
        -:   78:            // node j is not done
    30249:   79:            done = 0;
        -:   80:            // break to start dfs i
    30249:   81:            break;
        -:   82:        }
    70203:   83:        if (done != 0)
        -:   84:        {
    39954:   85:            head--;
    39954:   86:            xi[--(*top)] = j;
        -:   87:        }
        -:   88:    }
     9705:   89:    return;
        -:   90:}
