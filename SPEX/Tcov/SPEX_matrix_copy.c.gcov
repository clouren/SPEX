        -:    0:Source:SPEX_matrix_copy.c
        -:    0:Graph:SPEX_matrix_copy.gcno
        -:    0:Data:SPEX_matrix_copy.gcda
        -:    0:Runs:9
        -:    1://------------------------------------------------------------------------------
        -:    2:// SPEX_Util/SPEX_matrix_copy: create a copy of a matrix
        -:    3://------------------------------------------------------------------------------
        -:    4:
        -:    5:// SPEX_Util: (c) 2019-2021, Chris Lourenco (US Naval Academy), Jinhao Chen,
        -:    6:// Erick Moreno-Centeno, Timothy A. Davis, Texas A&M.  All Rights Reserved.
        -:    7:// SPDX-License-Identifier: GPL-2.0-or-later or LGPL-3.0-or-later
        -:    8:
        -:    9://------------------------------------------------------------------------------
        -:   10:
        -:   11:// SPEX_matrix_copy creates a SPEX_matrix C that is a modified copy of a
        -:   12:// SPEX_matrix A.  The new matrix C can have a different kind and type
        -:   13:// than A.
        -:   14:
        -:   15:// The input matrix A is assumed to be valid.  It can be checked first with
        -:   16:// SPEX_matrix_check, if desired.  If the input matrix A is not valid, results
        -:   17:// are undefined.
        -:   18:
        -:   19:#define SPEX_FREE_WORK                  \
        -:   20:    SPEX_matrix_free (&T, option) ;     \
        -:   21:    SPEX_matrix_free (&Y, option) ;     \
        -:   22:    SPEX_FREE (W) ;
        -:   23:
        -:   24:#define SPEX_FREE_ALL                   \
        -:   25:    SPEX_FREE_WORK ;                    \
        -:   26:    SPEX_matrix_free (&C, option) ;
        -:   27:
        -:   28:#include "spex_util_internal.h"
        -:   29:
    81497:   30:SPEX_info SPEX_matrix_copy
        -:   31:(
        -:   32:    SPEX_matrix **C_handle, // matrix to create (never shallow)
        -:   33:    // inputs, not modified:
        -:   34:    SPEX_kind C_kind,       // C->kind: CSC, triplet, dense, or dynamic_CSC
        -:   35:    SPEX_type C_type,       // C->type: mpz_t, mpq_t, mpfr_t, int64_t, or double
        -:   36:    SPEX_matrix *A,         // matrix to make a copy of (may be shallow)
        -:   37:    const SPEX_options *option
        -:   38:)
        -:   39:{
        -:   40:
        -:   41:    //--------------------------------------------------------------------------
        -:   42:    // check inputs
        -:   43:    //--------------------------------------------------------------------------
        -:   44:
        -:   45:    SPEX_info info ;
   81497*:   46:    if (!spex_initialized ( )) return (SPEX_PANIC) ;
        -:   47:
        -:   48:    int64_t nz;
    81497:   49:    SPEX_matrix *C = NULL ;
    81497:   50:    SPEX_matrix *Y = NULL ;
    81497:   51:    SPEX_matrix *T = NULL ;
    81497:   52:    int64_t *W = NULL ;
        -:   53:
   81497*:   54:    SPEX_CHECK (SPEX_matrix_nnz (&nz, A, option)) ;
        -:   55:    ASSERT( nz >= 0);
    81497:   56:    if (C_handle == NULL || nz < 0 ||
        -:   57:      //checked in SPEX_matrix_nnz
        -:   58:      //A == NULL || A->kind < SPEX_CSC || A->kind > SPEX_DYNAMIC_CSC ||
    81497:   59:        A->type < SPEX_MPZ || A->type > SPEX_FP64  ||
    81497:   60:        C_kind  < SPEX_CSC || C_kind  > SPEX_DYNAMIC_CSC ||
    81445:   61:        C_type  < SPEX_MPZ || C_type  > SPEX_FP64 ||
    81445:   62:        (A->kind == SPEX_DYNAMIC_CSC && A->type != SPEX_MPZ) ||
      323:   63:        (C_kind  == SPEX_DYNAMIC_CSC && C_type  != SPEX_MPZ))
        -:   64:    {
       52:   65:        return (SPEX_INCORRECT_INPUT) ;
        -:   66:    }
    81445:   67:    (*C_handle) = NULL ;
    81445:   68:    int64_t m = A->m ;
    81445:   69:    int64_t n = A->n ;
   81445*:   70:    mpfr_rnd_t round = SPEX_OPTION_ROUND (option) ;
        -:   71:
        -:   72:    //--------------------------------------------------------------------------
        -:   73:    // copy and convert A into C
        -:   74:    //--------------------------------------------------------------------------
        -:   75:
    81445:   76:    switch (C_kind)
        -:   77:    {
        -:   78:
        -:   79:        //----------------------------------------------------------------------
        -:   80:        // C is CSC
        -:   81:        //----------------------------------------------------------------------
        -:   82:
    43611:   83:        case SPEX_CSC:
        -:   84:        {
        -:   85:
    43611:   86:            switch (A->kind)
        -:   87:            {
        -:   88:
        -:   89:                //--------------------------------------------------------------
        -:   90:                // A is CSC, C is CSC
        -:   91:                //--------------------------------------------------------------
        -:   92:
    14456:   93:                case SPEX_CSC:
        -:   94:                {
        -:   95:                    // allocate C
    14456:   96:                    SPEX_CHECK (SPEX_matrix_allocate (&C, SPEX_CSC, C_type,
        -:   97:                        m, n, nz, false, true, option)) ;
        -:   98:                    // copy the pattern of A into C
    13863:   99:                    memcpy (C->p, A->p, (n+1) * sizeof (int64_t)) ;
    13863:  100:                    memcpy (C->i, A->i, nz * sizeof (int64_t)) ;
        -:  101:                    // copy and typecast A->x into C->x
    13863:  102:                    SPEX_CHECK (spex_cast_array (SPEX_X (C), C->type,
        -:  103:                        SPEX_X (A), A->type, nz, C->scale, A->scale, option)) ;
        -:  104:                }
    13311:  105:                break ;
        -:  106:
        -:  107:                //--------------------------------------------------------------
        -:  108:                // A is triplet, C is CSC
        -:  109:                //--------------------------------------------------------------
        -:  110:
    10551:  111:                case SPEX_TRIPLET:
        -:  112:                {
        -:  113:
        -:  114:                    // Y = typecast the values of A into the type of C
        -:  115:                    // (not the pattern; Y is SPEX_DENSE)
    10551:  116:                    SPEX_CHECK (spex_cast_matrix (&Y, C_type, A, option)) ;
        -:  117:
        -:  118:                    // allocate workspace
    10044:  119:                    W = (int64_t *) SPEX_calloc (n, sizeof (int64_t)) ;
    10044:  120:                    if (W == NULL)
        -:  121:                    {
       25:  122:                        SPEX_FREE_ALL ;
       25:  123:                        return (SPEX_OUT_OF_MEMORY) ;
        -:  124:                    }
        -:  125:
        -:  126:                    // allocate C
    10019:  127:                    SPEX_CHECK (SPEX_matrix_allocate (&C, SPEX_CSC,
        -:  128:                        C_type, m, n, nz, false, true, option)) ;
        -:  129:
        -:  130:                    // Scaling factor of C is currently in Y, set it
        -:  131:                    // here
     9649:  132:                    SPEX_mpq_set(C->scale, Y->scale);
        -:  133:                    
        -:  134:                    // count the # of entries in each column
   133933:  135:                    for (int64_t k = 0 ; k < nz ; k++)
        -:  136:                    {
   124284:  137:                        W [A->j [k]]++ ;
        -:  138:                    }
        -:  139:
        -:  140:                    // C->p = cumulative sum of W
     9649:  141:                    SPEX_cumsum (C->p, W, n) ;
        -:  142:
        -:  143:                    // build the matrix
     9649:  144:                    switch (C->type)
        -:  145:                    {
     2380:  146:                        case SPEX_MPZ:
    46705:  147:                            for (int64_t k = 0 ; k < nz ; k++)
        -:  148:                            {
    44325:  149:                                int64_t p = W [A->j [k]]++ ;
    44325:  150:                                C->i [p] = A->i [k] ;
   44325*:  151:                                SPEX_CHECK (SPEX_mpz_set (
        -:  152:                                    SPEX_1D (C, p, mpz),
        -:  153:                                    SPEX_1D (Y, k, mpz))) ;
        -:  154:                            }
     2380:  155:                            break ;
        -:  156:
     2002:  157:                        case SPEX_MPQ:
    24024:  158:                            for (int64_t k = 0 ; k < nz ; k++)
        -:  159:                            {
    22022:  160:                                int64_t p = W [A->j [k]]++ ;
    22022:  161:                                C->i [p] = A->i [k] ;
   22022*:  162:                                SPEX_CHECK (SPEX_mpq_set (
        -:  163:                                    SPEX_1D (C, p, mpq),
        -:  164:                                    SPEX_1D (Y, k, mpq))) ;
        -:  165:                            }
     2002:  166:                            break ;
        -:  167:
     1822:  168:                        case SPEX_MPFR:
    21864:  169:                            for (int64_t k = 0 ; k < nz ; k++)
        -:  170:                            {
    20042:  171:                                int64_t p = W [A->j [k]]++ ;
    20042:  172:                                C->i [p] = A->i [k] ;
   20042*:  173:                                SPEX_CHECK (SPEX_mpfr_set (
        -:  174:                                    SPEX_1D (C, p, mpfr),
        -:  175:                                    SPEX_1D (Y, k, mpfr),
        -:  176:                                    round)) ;
        -:  177:                            }
     1822:  178:                            break ;
        -:  179:
     1752:  180:                        case SPEX_INT64:
    21024:  181:                            for (int64_t k = 0 ; k < nz ; k++)
        -:  182:                            {
    19272:  183:                                int64_t p = W [A->j [k]]++ ;
    19272:  184:                                C->i [p] = A->i [k] ;
    19272:  185:                                SPEX_1D (C, p, int64) =
    19272:  186:                                    SPEX_1D (Y, k, int64) ;
        -:  187:                            }
     1752:  188:                            break ;
        -:  189:
     1693:  190:                        case SPEX_FP64:
    20316:  191:                            for (int64_t k = 0 ; k < nz ; k++)
        -:  192:                            {
    18623:  193:                                int64_t p = W [A->j [k]]++ ;
    18623:  194:                                C->i [p] = A->i [k] ;
    18623:  195:                                SPEX_1D (C, p, fp64) =
    18623:  196:                                    SPEX_1D (Y, k, fp64) ;
        -:  197:                            }
     1693:  198:                            break ;
        -:  199:
        -:  200:                    }
        -:  201:
     9649:  202:                }
     9649:  203:                break ;
        -:  204:
        -:  205:                //--------------------------------------------------------------
        -:  206:                // A is dense, C is CSC
        -:  207:                //--------------------------------------------------------------
        -:  208:
    18079:  209:                case SPEX_DENSE:
        -:  210:                {
        -:  211:                    // Y = typecast the values of A into the type of C
    18819:  212:                    SPEX_CHECK (spex_cast_matrix (&Y, C_type, A, option)) ;
        -:  213:                    int s ;
        -:  214:
        -:  215:                    // count the actual nonzeros in Y
    17065:  216:                    int64_t actual = 0 ;
    17065:  217:                    switch (Y->type)
        -:  218:                    {
        -:  219:
     4425:  220:                        case SPEX_MPZ:
    69020:  221:                            for (int64_t k = 0 ; k < nz ; k++)
        -:  222:                            {
   64595*:  223:                                SPEX_CHECK (SPEX_mpz_sgn (&s,
        -:  224:                                    SPEX_1D (Y, k, mpz))) ;
    64595:  225:                                if (s != 0) actual++ ;
        -:  226:                            }
     4425:  227:                            break ;
        -:  228:
     3807:  229:                        case SPEX_MPQ:
    45684:  230:                            for (int64_t k = 0 ; k < nz ; k++)
        -:  231:                            {
   41877*:  232:                                SPEX_CHECK (SPEX_mpq_sgn (&s,
        -:  233:                                    SPEX_1D (Y, k, mpq))) ;
    41877:  234:                                if (s != 0) actual++ ;
        -:  235:                            }
     3807:  236:                            break ;
        -:  237:
     3207:  238:                        case SPEX_MPFR:
    38484:  239:                            for (int64_t k = 0 ; k < nz ; k++)
        -:  240:                            {
   35277*:  241:                                SPEX_CHECK (SPEX_mpfr_sgn (&s,
        -:  242:                                    SPEX_1D (Y, k, mpfr))) ;
    35277:  243:                                if (s != 0) actual++ ;
        -:  244:                            }
     3207:  245:                            break ;
        -:  246:
     2882:  247:                        case SPEX_INT64:
    34584:  248:                            for (int64_t k = 0 ; k < nz ; k++)
        -:  249:                            {
    31702:  250:                                if (SPEX_1D (Y, k, int64) != 0) actual++ ;
        -:  251:                            }
     2882:  252:                            break ;
        -:  253:
     2744:  254:                        case SPEX_FP64:
    32928:  255:                            for (int64_t k = 0 ; k < nz ; k++)
        -:  256:                            {
    30184:  257:                                if (SPEX_1D (Y, k, fp64) != 0) actual++ ;
        -:  258:                            }
     2744:  259:                            break ;
        -:  260:
        -:  261:                    }
        -:  262:                    // allocate C
    17065:  263:                    SPEX_CHECK (SPEX_matrix_allocate (&C, SPEX_CSC, C_type,
        -:  264:                        m, n, actual, false, true, option)) ;
        -:  265:                        
        -:  266:                    // C's scaling factor is currently in Y. Set it here
    16325:  267:                    SPEX_mpq_set(C->scale, Y->scale);
        -:  268:
        -:  269:                    // Construct C
    16325:  270:                    nz = 0 ;
    16325:  271:                    switch (C->type)
        -:  272:                    {
        -:  273:
     4255:  274:                        case SPEX_MPZ:
     9220:  275:                            for (int64_t j = 0 ; j < n ; j++)
        -:  276:                            {
     4965:  277:                                C->p [j] = nz ;
    67690:  278:                                for (int64_t i = 0 ; i < m ; i++)
        -:  279:                                {
   62725*:  280:                                    SPEX_CHECK( SPEX_mpz_sgn( &s,
        -:  281:                                        Y->x.mpz[ i + j*A->m]));
    62725:  282:                                    if (s != 0)
        -:  283:                                    {
    60405:  284:                                        C->i [nz] = i ;
   60405*:  285:                                        SPEX_CHECK( SPEX_mpz_set (
        -:  286:                                            SPEX_1D (C, nz, mpz),
        -:  287:                                            Y->x.mpz[ i + j*A->m] ));
    60405:  288:                                        nz++ ;
        -:  289:                                    }
        -:  290:                                }
        -:  291:                            }
     4255:  292:                            break ;
        -:  293:
     3527:  294:                        case SPEX_MPQ:
     7054:  295:                            for (int64_t j = 0 ; j < n ; j++)
        -:  296:                            {
     3527:  297:                                C->p [j] = nz ;
    42324:  298:                                for (int64_t i = 0 ; i < m ; i++)
        -:  299:                                {
   38797*:  300:                                    SPEX_CHECK (SPEX_mpq_sgn (&s,
        -:  301:                                        Y->x.mpq[ i + j*A->m])) ;
    38797:  302:                                    if (s != 0)
        -:  303:                                    {
    38797:  304:                                        C->i [nz] = i ;
   38797*:  305:                                        SPEX_CHECK(SPEX_mpq_set (
        -:  306:                                            SPEX_1D(C, nz, mpq),
        -:  307:                                            Y->x.mpq[ i + j*A->m]));
    38797:  308:                                        nz++ ;
        -:  309:                                    }
        -:  310:                                }
        -:  311:                            }
     3527:  312:                            break ;
        -:  313:
     3037:  314:                        case SPEX_MPFR:
     6074:  315:                            for (int64_t j = 0 ; j < n ; j++)
        -:  316:                            {
     3037:  317:                                C->p [j] = nz ;
    36444:  318:                                for (int64_t i = 0 ; i < m ; i++)
        -:  319:                                {
   33407*:  320:                                    SPEX_CHECK (SPEX_mpfr_sgn (&s,
        -:  321:                                        Y->x.mpfr[i + j*A->m])) ;
    33407:  322:                                    if (s != 0)
        -:  323:                                    {
    33407:  324:                                        C->i [nz] = i ;                                        
   33407*:  325:                                        SPEX_CHECK (SPEX_mpfr_set (
        -:  326:                                            SPEX_1D (C, nz, mpfr),
        -:  327:                                            Y->x.mpfr[i + j*A->m],
        -:  328:                                            round)) ;
        -:  329:                                        
    33407:  330:                                        nz++ ;
        -:  331:                                    }
        -:  332:                                }
        -:  333:                            }
     3037:  334:                            break ;
        -:  335:
     2822:  336:                        case SPEX_INT64:
     5644:  337:                            for (int64_t j = 0 ; j < n ; j++)
        -:  338:                            {
     2822:  339:                                C->p [j] = nz ;
    33864:  340:                                for (int64_t i = 0 ; i < m ; i++)
        -:  341:                                {
    31042:  342:                                    if ( Y->x.int64[i +j*A->m] != 0)
        -:  343:                                    {
    31042:  344:                                        C->i [nz] = i ;
    31042:  345:                                        SPEX_1D (C, nz, int64) =
    31042:  346:                                            Y->x.int64[i +j*A->m] ;
    31042:  347:                                        nz++ ;
        -:  348:                                    }
        -:  349:                                }
        -:  350:                            }
     2822:  351:                            break ;
        -:  352:
     2684:  353:                        case SPEX_FP64:
     5368:  354:                            for (int64_t j = 0 ; j < n ; j++)
        -:  355:                            {
     2684:  356:                                C->p [j] = nz ;
    32208:  357:                                for (int64_t i = 0 ; i < m ; i++)
        -:  358:                                {
    29524:  359:                                    if ( Y->x.fp64[i +j*A->m] != 0)
        -:  360:                                    {
    29524:  361:                                        C->i [nz] = i ;
    29524:  362:                                        SPEX_1D (C, nz, fp64) =
    29524:  363:                                            Y->x.fp64[i +j*A->m];
    29524:  364:                                        nz++ ;
        -:  365:                                    }
        -:  366:                                }
        -:  367:                            }
     2684:  368:                            break ;
        -:  369:                    }
    16325:  370:                    C->p [n] = nz ;
        -:  371:                }
    16325:  372:                break ;
        -:  373:
        -:  374:                //--------------------------------------------------------------
        -:  375:                // A is dynamic_CSC, C is CSC
        -:  376:                //--------------------------------------------------------------
        -:  377:
      525:  378:                case SPEX_DYNAMIC_CSC:
        -:  379:                {
        -:  380:                    // convert A to a SPEX_CSC x SPEX_MPZ matrix T
      525:  381:                    SPEX_CHECK(spex_dynamic_to_CSC_mpz(&T, A, nz, option));
        -:  382:
      468:  383:                    if (C_type == SPEX_MPZ)
        -:  384:                    {
      392:  385:                        C = T;
      392:  386:                        T = NULL;
        -:  387:                    }
        -:  388:                    else
        -:  389:                    {
      76*:  390:                        SPEX_CHECK (SPEX_matrix_copy (&C, SPEX_CSC, C_type,
        -:  391:                            T, option)) ;
        -:  392:                    }
      468:  393:                    SPEX_matrix_free (&T, option) ;
        -:  394:                }
      468:  395:                break;
        -:  396:            }
        -:  397:
    39753:  398:        }
    39753:  399:        break ;
        -:  400:
        -:  401:        //----------------------------------------------------------------------
        -:  402:        // C is triplet
        -:  403:        //----------------------------------------------------------------------
        -:  404:
    25247:  405:        case SPEX_TRIPLET:
        -:  406:        {
        -:  407:
    25247:  408:            switch (A->kind)
        -:  409:            {
        -:  410:
        -:  411:                //--------------------------------------------------------------
        -:  412:                // A is CSC, C is triplet
        -:  413:                //--------------------------------------------------------------
        -:  414:
    12310:  415:                case SPEX_CSC:
        -:  416:                {
        -:  417:                    // allocate C
    12310:  418:                    SPEX_CHECK (SPEX_matrix_allocate (&C, SPEX_TRIPLET, C_type,
        -:  419:                        m, n, nz, false, true, option)) ;
        -:  420:                    // copy and typecast A->x into C->x
    11554:  421:                    SPEX_CHECK (spex_cast_array (SPEX_X (C), C->type,
        -:  422:                        SPEX_X (A), A->type, nz, C->scale, A->scale, option)) ;
        -:  423:                    // copy the row indices A->i into C->i
    11318:  424:                    memcpy (C->i, A->i, nz * sizeof (int64_t)) ;
        -:  425:                    // construct C->j
    41985:  426:                    for (int64_t j = 0 ; j < n ; j++)
        -:  427:                    {
   170695:  428:                        for (int64_t p = A->p [j] ; p < A->p [j+1] ; p++)
        -:  429:                        {
   140028:  430:                            C->j [p] = j ;
        -:  431:                        }
        -:  432:                    }
        -:  433:                    // set C->nz
    11318:  434:                    C->nz = nz;
        -:  435:                }
    11318:  436:                break ;
        -:  437:
        -:  438:                //--------------------------------------------------------------
        -:  439:                // A is triplet, C is triplet
        -:  440:                //--------------------------------------------------------------
        -:  441:
     6585:  442:                case SPEX_TRIPLET:
        -:  443:                {
        -:  444:                    // allocate C
     6585:  445:                    SPEX_CHECK (SPEX_matrix_allocate (&C, SPEX_TRIPLET, C_type,
        -:  446:                        m, n, nz, false, true, option)) ;
        -:  447:                    // copy the pattern of A into C
     6215:  448:                    memcpy (C->j, A->j, nz * sizeof (int64_t)) ;
     6215:  449:                    memcpy (C->i, A->i, nz * sizeof (int64_t)) ;
        -:  450:                    // copy and typecast A->x into C->x
     6215:  451:                    SPEX_CHECK (spex_cast_array (SPEX_X (C), C->type,
        -:  452:                        SPEX_X (A), A->type, nz, C->scale, A->scale, option)) ;
        -:  453:                    // set C->nz
     5979:  454:                    C->nz = nz;
        -:  455:                }
     5979:  456:                break ;
        -:  457:
        -:  458:                //--------------------------------------------------------------
        -:  459:                // A is dense, C is triplet
        -:  460:                //--------------------------------------------------------------
        -:  461:
     6257:  462:                case SPEX_DENSE:
        -:  463:                {
        -:  464:                    // convert A to a temporary CSC matrix
     6257:  465:                    SPEX_CHECK (SPEX_matrix_copy (&T, SPEX_CSC, C_type,
        -:  466:                        A, option)) ;
        -:  467:                    // convert T from CSC to triplet
     5380:  468:                    SPEX_CHECK (SPEX_matrix_copy (&C, SPEX_TRIPLET, C_type,
        -:  469:                        T, option)) ;
     5010:  470:                    SPEX_matrix_free (&T, option) ;
        -:  471:                    // set C->nz
     5010:  472:                    C->nz = nz;
        -:  473:                }
     5010:  474:                break ;
        -:  475:
        -:  476:                //--------------------------------------------------------------
        -:  477:                // A is dynamic_CSC, C is triplet
        -:  478:                //--------------------------------------------------------------
        -:  479:
       95:  480:                case SPEX_DYNAMIC_CSC:
        -:  481:                {
        -:  482:                    // convert A to a SPEX_CSC x SPEX_MPZ matrix T
      95*:  483:                    SPEX_CHECK(spex_dynamic_to_CSC_mpz(&T, A, nz, option));
        -:  484:
      95*:  485:                    SPEX_CHECK (SPEX_matrix_copy (&C, SPEX_TRIPLET, C_type,
        -:  486:                        T, option)) ;
       95:  487:                    SPEX_matrix_free (&T, option) ;
        -:  488:                }
       95:  489:                break;
        -:  490:
        -:  491:            }
        -:  492:
    22402:  493:        }
    22402:  494:        break ;
        -:  495:
        -:  496:        //----------------------------------------------------------------------
        -:  497:        // C is dense
        -:  498:        //----------------------------------------------------------------------
        -:  499:
    12264:  500:        case SPEX_DENSE:
        -:  501:        {
        -:  502:
    12264:  503:            switch (A->kind)
        -:  504:            {
        -:  505:
        -:  506:                //--------------------------------------------------------------
        -:  507:                // A is CSC, C is dense
        -:  508:                //--------------------------------------------------------------
        -:  509:
     2827:  510:                case SPEX_CSC:
        -:  511:                {
        -:  512:                    // allocate C
     2827:  513:                    SPEX_CHECK (SPEX_matrix_allocate (&C, SPEX_DENSE, C_type,
        -:  514:                        m, n, nz, false, true, option)) ;
        -:  515:
        -:  516:                    // Y = typecast the values of A into the type of C
     2399:  517:                    SPEX_CHECK (spex_cast_matrix (&Y, C->type, A, option)) ;
        -:  518:                    
        -:  519:                    // Set C's scaling factor
     1892:  520:                    SPEX_mpq_set(C->scale, Y->scale);
        -:  521:
     1892:  522:                    switch (C->type)
        -:  523:                    {
        -:  524:
      766:  525:                        case SPEX_MPZ:
     3915:  526:                            for (int64_t j = 0 ; j < n ; j++)
        -:  527:                            {
    14681:  528:                                for (int64_t p = A->p [j] ; p < A->p [j+1] ;p++)
        -:  529:                                {
    11532:  530:                                    int64_t i = A->i [p] ;
   11532*:  531:                                    SPEX_CHECK (SPEX_mpz_set (
        -:  532:                                        SPEX_2D (C, i, j, mpz),
        -:  533:                                        SPEX_1D (Y, p, mpz))) ;
        -:  534:                                }
        -:  535:                            }
      766:  536:                            break ;
        -:  537:
      457:  538:                        case SPEX_MPQ:
     2370:  539:                            for (int64_t j = 0 ; j < n ; j++)
        -:  540:                            {
     9660:  541:                                for (int64_t p = A->p [j] ; p < A->p [j+1] ;p++)
        -:  542:                                {
     7747:  543:                                    int64_t i = A->i [p] ;
    7747*:  544:                                    SPEX_CHECK (SPEX_mpq_set (
        -:  545:                                        SPEX_2D (C, i, j, mpq),
        -:  546:                                        SPEX_1D (Y, p, mpq))) ;
        -:  547:                                }
        -:  548:                            }
      457:  549:                            break ;
        -:  550:
      272:  551:                        case SPEX_MPFR:
     1445:  552:                            for (int64_t j = 0 ; j < n ; j++)
        -:  553:                            {
     6885:  554:                                for (int64_t p = A->p [j] ; p < A->p [j+1] ;p++)
        -:  555:                                {
     5712:  556:                                    int64_t i = A->i [p] ;
    5712*:  557:                                    SPEX_CHECK (SPEX_mpfr_set (
        -:  558:                                        SPEX_2D (C, i, j, mpfr),
        -:  559:                                        SPEX_1D (Y, p, mpfr),
        -:  560:                                        round)) ;
        -:  561:                                }
        -:  562:                            }
      272:  563:                            break ;
        -:  564:
      222:  565:                        case SPEX_INT64:
     1195:  566:                            for (int64_t j = 0 ; j < n ; j++)
        -:  567:                            {
     6135:  568:                                for (int64_t p = A->p [j] ; p < A->p [j+1] ;p++)
        -:  569:                                {
     5162:  570:                                    int64_t i = A->i [p] ;
     5162:  571:                                    SPEX_2D (C, i, j, int64) =
     5162:  572:                                        SPEX_1D (Y, p, int64) ;
        -:  573:                                }
        -:  574:                            }
      222:  575:                            break ;
        -:  576:
      175:  577:                        case SPEX_FP64:
      960:  578:                            for (int64_t j = 0 ; j < n ; j++)
        -:  579:                            {
     5430:  580:                                for (int64_t p = A->p [j] ; p < A->p [j+1] ;p++)
        -:  581:                                {
     4645:  582:                                    int64_t i = A->i [p] ;
     4645:  583:                                    SPEX_2D (C, i, j, fp64) =
     4645:  584:                                        SPEX_1D (Y, p, fp64) ;
        -:  585:                                }
        -:  586:                            }
      175:  587:                            break ;
        -:  588:
        -:  589:                    }
        -:  590:
     1892:  591:                }
     1892:  592:                break ;
        -:  593:
        -:  594:                //--------------------------------------------------------------
        -:  595:                // A is triplet, C is dense
        -:  596:                //--------------------------------------------------------------
        -:  597:
     2562:  598:                case SPEX_TRIPLET:
        -:  599:                {
        -:  600:                    // allocate C
     2562:  601:                    SPEX_CHECK (SPEX_matrix_allocate (&C, SPEX_DENSE, C_type,
        -:  602:                        m, n, nz, false, true, option)) ;
        -:  603:
        -:  604:                    // Y = typecast the values of A into the type of C
     2142:  605:                    SPEX_CHECK (spex_cast_matrix (&Y, C->type, A, option)) ;
        -:  606:
        -:  607:                    // Set C's scaling factor
     1635:  608:                    SPEX_mpq_set(C->scale, Y->scale);
     1635:  609:                    switch (C->type)
        -:  610:                    {
        -:  611:
      713:  612:                        case SPEX_MPZ:
     8556:  613:                            for (int64_t k = 0 ; k < nz ; k++)
        -:  614:                            {
     7843:  615:                                int64_t i = A->i [k] ;
     7843:  616:                                int64_t j = A->j [k] ;
    7843*:  617:                                SPEX_CHECK (SPEX_mpz_set (
        -:  618:                                    SPEX_2D (C, i, j, mpz),
        -:  619:                                    SPEX_1D (Y, k, mpz))) ;
        -:  620:                            }
      713:  621:                            break ;
        -:  622:
      404:  623:                        case SPEX_MPQ:
     4848:  624:                            for (int64_t k = 0 ; k < nz ; k++)
        -:  625:                            {
     4444:  626:                                int64_t i = A->i [k] ;
     4444:  627:                                int64_t j = A->j [k] ;
    4444*:  628:                                SPEX_CHECK (SPEX_mpq_set (
        -:  629:                                    SPEX_2D (C, i, j, mpq),
        -:  630:                                    SPEX_1D (Y, k, mpq))) ;
        -:  631:                            }
      404:  632:                            break ;
        -:  633:
      219:  634:                        case SPEX_MPFR:
     2628:  635:                            for (int64_t k = 0 ; k < nz ; k++)
        -:  636:                            {
     2409:  637:                                int64_t i = A->i [k] ;
     2409:  638:                                int64_t j = A->j [k] ;
    2409*:  639:                                SPEX_CHECK (SPEX_mpfr_set (
        -:  640:                                    SPEX_2D (C, i, j, mpfr),
        -:  641:                                    SPEX_1D (Y, k, mpfr),
        -:  642:                                    round)) ;
        -:  643:                            }
      219:  644:                            break ;
        -:  645:
      169:  646:                        case SPEX_INT64:
     2028:  647:                            for (int64_t k = 0 ; k < nz ; k++)
        -:  648:                            {
     1859:  649:                                int64_t i = A->i [k] ;
     1859:  650:                                int64_t j = A->j [k] ;
     1859:  651:                                SPEX_2D (C, i, j, int64) =
     1859:  652:                                    SPEX_1D (Y, k, int64) ;
        -:  653:                            }
      169:  654:                            break ;
        -:  655:
      130:  656:                        case SPEX_FP64:
     1560:  657:                            for (int64_t k = 0 ; k < nz ; k++)
        -:  658:                            {
     1430:  659:                                int64_t i = A->i [k] ;
     1430:  660:                                int64_t j = A->j [k] ;
     1430:  661:                                SPEX_2D (C, i, j, fp64) =
     1430:  662:                                    SPEX_1D (Y, k, fp64) ;
        -:  663:                            }
      130:  664:                            break ;
        -:  665:
        -:  666:                    }
     1635:  667:                }
     1635:  668:                break ;
        -:  669:
        -:  670:                //--------------------------------------------------------------
        -:  671:                // A is dense, C is dense
        -:  672:                //--------------------------------------------------------------
        -:  673:
     6780:  674:                case SPEX_DENSE:
        -:  675:                {
        -:  676:                    // allocate C
     6780:  677:                    SPEX_CHECK (SPEX_matrix_allocate (&C, SPEX_DENSE, C_type,
        -:  678:                        m, n, nz, false, true, option)) ;
        -:  679:
        -:  680:                    // copy and typecast A->x into C->x
     6288:  681:                    SPEX_CHECK (spex_cast_array (SPEX_X (C), C->type,
        -:  682:                        SPEX_X (A), A->type, nz, C->scale, A->scale, option)) ;
        -:  683:                }
     5888:  684:                break ;
        -:  685:
        -:  686:                //--------------------------------------------------------------
        -:  687:                // A is dynamic_CSC, C is dense
        -:  688:                //--------------------------------------------------------------
        -:  689:
       95:  690:                case SPEX_DYNAMIC_CSC:
        -:  691:                {
        -:  692:                    // convert A to a SPEX_CSC x SPEX_MPZ matrix T
      95*:  693:                    SPEX_CHECK(spex_dynamic_to_CSC_mpz(&T, A, nz, option));
        -:  694:
      95*:  695:                    SPEX_CHECK (SPEX_matrix_copy (&C, SPEX_DENSE, C_type,
        -:  696:                        T, option)) ;
       95:  697:                    SPEX_matrix_free (&T, option) ;
        -:  698:                }
       95:  699:                break;
        -:  700:
        -:  701:            }
        -:  702:
     9510:  703:        }
     9510:  704:        break ;
        -:  705:
        -:  706:        //----------------------------------------------------------------------
        -:  707:        // C is dynamic_CSC
        -:  708:        //----------------------------------------------------------------------
        -:  709:
      323:  710:        case SPEX_DYNAMIC_CSC:
        -:  711:        {
      323:  712:            if (A->kind != SPEX_DYNAMIC_CSC)
        -:  713:            {
      285:  714:                if (A->kind == SPEX_CSC && A->type == SPEX_MPZ)
        -:  715:                {
        -:  716:                    // A is already a CSC x MPZ matrix
      19*:  717:                    SPEX_CHECK(spex_CSC_mpz_to_dynamic(&C, A, option));
        -:  718:                }
        -:  719:                else
        -:  720:                {
        -:  721:                    // convert A to a SPEX_CSC x SPEX_MPZ matrix T
     266*:  722:                    SPEX_CHECK (SPEX_matrix_copy (&T, SPEX_CSC, SPEX_MPZ,
        -:  723:                        A, option)) ;
     266*:  724:                    SPEX_CHECK(spex_CSC_mpz_to_dynamic(&C, T, option));
      266:  725:                    SPEX_matrix_free (&T, option) ;
        -:  726:                }
        -:  727:            }
        -:  728:            else // make a exact same copy
        -:  729:            {
        -:  730:                // allocate space for C
      38*:  731:                SPEX_CHECK (SPEX_matrix_allocate (&C, SPEX_DYNAMIC_CSC,
        -:  732:                    C_type, m, n, 0, false, true, option)) ;
        -:  733:                // copy A->x into C->x
      360:  734:                for (int64_t j = 0; j < n; j++)
        -:  735:                {
      322:  736:                    int64_t Aj_nz = A->v[j]->nz;
        -:  737:                    // reallocate space for each column of C
     322*:  738:                    SPEX_CHECK(SPEX_vector_realloc(C->v[j], Aj_nz, option));
      322:  739:                    memcpy (C->v[j]->i, A->v[j]->i, Aj_nz*sizeof (int64_t));
        -:  740:
     6180:  741:                    for (int64_t p = 0; p < Aj_nz; p++)
        -:  742:                    {
    5858*:  743:                        SPEX_CHECK(SPEX_mpz_set(C->v[j]->x[p],
        -:  744:                            A->v[j]->x[p]));
        -:  745:                    }
      322:  746:                    C->v[j]->nz = Aj_nz;
        -:  747:                }
        -:  748:            }
        -:  749:
        -:  750:        }
      323:  751:        break ;
        -:  752:
        -:  753:    }
        -:  754:
        -:  755:    //--------------------------------------------------------------------------
        -:  756:    // free workspace and return result
        -:  757:    //--------------------------------------------------------------------------
        -:  758:
    71988:  759:    SPEX_FREE_WORK ;
    71988:  760:    (*C_handle) = C ;
        -:  761:
    71988:  762:    return (SPEX_OK) ;
        -:  763:}
        -:  764:
