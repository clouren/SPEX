        -:    0:Source:../SPEX_Util/Source/spex_util_internal.h
        -:    0:Graph:spex_cast_array.gcno
        -:    0:Data:spex_cast_array.gcda
        -:    0:Runs:9
        -:    1://------------------------------------------------------------------------------
        -:    2:// SPEX_Util/spex_util_internal: include file for internal use in SPEX_Utility functions
        -:    3://------------------------------------------------------------------------------
        -:    4:
        -:    5:// SPEX_Util: (c) 2019-2021, Chris Lourenco (US Naval Academy), Jinhao Chen,
        -:    6:// Erick Moreno-Centeno, Timothy A. Davis, Texas A&M.  All Rights Reserved.
        -:    7:// SPDX-License-Identifier: GPL-2.0-or-later or LGPL-3.0-or-later
        -:    8:
        -:    9://------------------------------------------------------------------------------
        -:   10:
        -:   11:// This file is not intended to be #include'd in user applications.  Use
        -:   12:// SPEX_Util.h instead.
        -:   13:
        -:   14:#ifndef SPEX_UTIL_INTERNAL_H
        -:   15:#define SPEX_UTIL_INTERNAL_H
        -:   16:
        -:   17:#pragma GCC diagnostic ignored "-Wunused-parameter"
        -:   18:#pragma GCC diagnostic ignored "-Wunused-value"
        -:   19:
        -:   20://------------------------------------------------------------------------------
        -:   21://------------------------------------------------------------------------------
        -:   22://-------------------------C Libraries------------------------------------------
        -:   23://------------------------------------------------------------------------------
        -:   24://------------------------------------------------------------------------------
        -:   25:
        -:   26:// Standard C libraries
        -:   27:#include <setjmp.h>
        -:   28:#include <math.h>
        -:   29:#include <stdarg.h>
        -:   30:#include <stdint.h>
        -:   31:#include <inttypes.h>
        -:   32:
        -:   33:// SuiteSparse headers
        -:   34:#include "SuiteSparse_config.h"
        -:   35:#include "colamd.h"
        -:   36:#include "amd.h"
        -:   37:
        -:   38://------------------------------------------------------------------------------
        -:   39:// debugging
        -:   40://------------------------------------------------------------------------------
        -:   41:
        -:   42:#ifdef SPEX_DEBUG
        -:   43:
        -:   44:#ifdef MATLAB_MEX_FILE
        -:   45:
        -:   46:#define ASSERT(x)                                                             \
        -:   47:{                                                                             \
        -:   48:    if (!(x))                                                                 \
        -:   49:    {                                                                         \
        -:   50:        mexErrMsgTxt ("assertion failed: %s line %d\n", __FILE__, __LINE__) ; \
        -:   51:    }                                                                         \
        -:   52:}
        -:   53:
        -:   54:#else
        -:   55:
        -:   56:#include <assert.h>
        -:   57:#define ASSERT(x) assert (x)
        -:   58:
        -:   59:#endif
        -:   60:
        -:   61:#else
        -:   62:
        -:   63:// debugging disabled
        -:   64:#define ASSERT(x)
        -:   65:
        -:   66:#endif
        -:   67:
        -:   68://------------------------------------------------------------------------------
        -:   69://-------------------------Common Macros----------------------------------------
        -:   70://------------------------------------------------------------------------------
        -:   71:
        -:   72:#ifdef MATLAB_MEX_FILE
        -:   73:#include "mex.h"
        -:   74:#include "matrix.h"
        -:   75:#endif
        -:   76:
        -:   77:#define SPEX_MAX(a,b) (((a) > (b)) ? (a) : (b))
        -:   78:#define SPEX_MIN(a,b) (((a) < (b)) ? (a) : (b))
        -:   79:#define SPEX_FLIP(i) (-(i)-2)
        -:   80:#define SPEX_UNFLIP(i) (((i) < 0) ? SPEX_FLIP(i) : (i))
        -:   81:#define SPEX_MARKED(Ap,j) (Ap [j] < 0)
        -:   82:#define SPEX_MARK(Ap,j) { Ap [j] = SPEX_FLIP (Ap [j]) ; }
        -:   83:
        -:   84:// SPEX_CHECK(method) is a macro that calls a SPEX method and checks the
        -:   85:// status; if a failure occurs, it frees all allocated workspace and returns
        -:   86:// the error status to the caller.  To use SPEX_CHECK, the #include'ing file
        -:   87:// must declare a SPEX_info info, and must define SPEX_FREE_ALL as a macro that
        -:   88:// frees all workspace if an error occurs. The method can be a scalar as well,
        -:   89:// so that SPEX_CHECK(info) works.
        -:   90:
        -:   91:// the default is to free nothing
        -:   92:#ifndef SPEX_FREE_ALL
        -:   93:#define SPEX_FREE_ALL
        -:   94:#endif
        -:   95:
        -:   96:#define SPEX_CHECK(method)      \
        -:   97:{                               \
        -:   98:    info = (method) ;           \
        -:   99:    if (info != SPEX_OK)        \
        -:  100:    {                           \
        -:  101:        SPEX_FREE_ALL ;         \
        -:  102:        return (info) ;         \
        -:  103:    }                           \
        -:  104:}
        -:  105:
        -:  106:#include "SPEX_Util.h"
        -:  107:
        -:  108://------------------------------------------------------------------------------
        -:  109:// printing control
        -:  110://------------------------------------------------------------------------------
        -:  111:
        -:  112:// SPEX uses SuiteSparse_config.printf_func instead of a mere call to printf
        -:  113:// (the default function is printf, or mexPrintf when in MATLAB).  If this
        -:  114:// function pointer is NULL, no printing is done.
        -:  115:
        -:  116:#define SPEX_PRINTF(...)                                    \
        -:  117:{                                                           \
        -:  118:    if (SuiteSparse_config.printf_func != NULL)             \
        -:  119:    {                                                       \
        -:  120:        SuiteSparse_config.printf_func (__VA_ARGS__) ;      \
        -:  121:    }                                                       \
        -:  122:}
        -:  123:
        -:  124:#define SPEX_PR1(...) { if (pr >= 1) SPEX_PRINTF (__VA_ARGS__) }
        -:  125:#define SPEX_PR2(...) { if (pr >= 2) SPEX_PRINTF (__VA_ARGS__) }
        -:  126:#define SPEX_PR3(...) { if (pr >= 3) SPEX_PRINTF (__VA_ARGS__) }
        -:  127:
        -:  128://------------------------------------------------------------------------------
        -:  129://------------------------------------------------------------------------------
        -:  130://-------------------------functions for GMP wrapper----------------------------
        -:  131://------------------------------------------------------------------------------
        -:  132://------------------------------------------------------------------------------
        -:  133:// uncomment this to print memory debugging info
        -:  134:// #define SPEX_GMP_MEMORY_DEBUG
        -:  135:
        -:  136:#ifdef SPEX_GMP_MEMORY_DEBUG
        -:  137:void spex_gmp_dump ( void ) ;
        -:  138:#endif
        -:  139:
        -:  140:extern int64_t spex_gmp_ntrials ;
        -:  141:
        -:  142:#ifndef SPEX_GMP_LIST_INIT
        -:  143:// A size of 32 ensures that the list never needs to be increased in size.
        -:  144:// The test coverage suite in SPEX_Left_LU/Tcov reduces this initial size to
        -:  145:// exercise the code, in SPEX_Left_LU/Tcov/Makefile.
        -:  146:#define SPEX_GMP_LIST_INIT 32
        -:  147:#endif
        -:  148:
        -:  149:
        -:  150:bool spex_gmp_init (void) ;
        -:  151:
        -:  152:void spex_gmp_finalize (void) ;
        -:  153:
        -:  154:void *spex_gmp_allocate (size_t size) ;
        -:  155:
        -:  156:void spex_gmp_free (void *p, size_t size) ;
        -:  157:
        -:  158:void *spex_gmp_reallocate (void *p_old, size_t old_size, size_t new_size );
        -:  159:
        -:  160:void spex_gmp_failure (int status) ;
        -:  161:
        -:  162:
        -:  163:// Tolerance used in the pivoting schemes. This number can be anything in
        -:  164:// between 0 and 1. A value of 0 selects the diagonal element exclusively and a
        -:  165:// value of 1 selects the smallest or largest pivot exclusively only in a
        -:  166:// tolerance pivoting based method
        -:  167:#define SPEX_DEFAULT_TOL 1
        -:  168:
        -:  169:// Check parameter. If this = 1 then the solution to the system is checked
        -:  170:// for accuracy
        -:  171:#define SPEX_DEFAULT_CHECK false
        -:  172:
        -:  173:// Pivoting scheme used for SPEX Left LU.
        -:  174://  SPEX_SMALLEST = 0,              Smallest pivot
        -:  175://  SPEX_DIAGONAL = 1,              Diagonal pivoting
        -:  176://  SPEX_FIRST_NONZERO = 2,         First nonzero per column chosen as pivot
        -:  177://  SPEX_TOL_SMALLEST = 3,          Diagonal pivoting with tolerance for small
        -:  178://  SPEX_TOL_LARGEST = 4,           Diagonal pivoting with tolerance for large
        -:  179://  SPEX_LARGEST = 5                Largest pivot
        -:  180:#define SPEX_DEFAULT_PIVOT SPEX_TOL_SMALLEST
        -:  181:
        -:  182:// Column ordering used.
        -:  183://  SPEX_NO_ORDERING = 0,           None: Not recommended for sparse matrices
        -:  184://  SPEX_COLAMD = 1,                COLAMD: Default
        -:  185://  SPEX_AMD = 2                    AMD
        -:  186:#define SPEX_DEFAULT_ORDER SPEX_COLAMD
        -:  187:
        -:  188:// Defines printing to be done
        -:  189:#define SPEX_DEFAULT_PRINT_LEVEL 0
        -:  190:
        -:  191:// MPFR precision used (quad is default)
        -:  192:#define SPEX_DEFAULT_PRECISION 128
        -:  193:
        -:  194://------------------------------------------------------------------------------
        -:  195:// Type of MPFR rounding used.
        -:  196://------------------------------------------------------------------------------
        -:  197:
        -:  198:// The MPFR library utilizes an internal rounding scheme. The options are
        -:  199://  MPFR_RNDN: round to nearest (roundTiesToEven in IEEE 754-2008),
        -:  200://  MPFR_RNDZ: round toward zero (roundTowardZero in IEEE 754-2008),
        -:  201://  MPFR_RNDU: round toward plus infinity (roundTowardPositive in
        -:  202://             IEEE 754-2008),
        -:  203://  MPFR_RNDD: round toward minus infinity (roundTowardNegative in
        -:  204://             IEEE 754-2008),
        -:  205://  MPFR_RNDA: round away from zero.
        -:  206://  MPFR_RNDF: faithful rounding. This is not stable
        -:  207://
        -:  208:// SPEX utilizes MPFR_RNDN by default.
        -:  209:
        -:  210:#define SPEX_DEFAULT_MPFR_ROUND MPFR_RNDN
        -:  211:
        -:  212://------------------------------------------------------------------------------
        -:  213:// Macros to utilize the default if option is NULL
        -:  214://------------------------------------------------------------------------------
        -:  215:
        -:  216:#define SPEX_OPTION(option,parameter,default_value) \
        -:  217:    ((option == NULL) ? (default_value) : (option->parameter))
        -:  218:
        -:  219:#define SPEX_OPTION_TOL(option) \
        -:  220:    SPEX_OPTION (option, tol, SPEX_DEFAULT_TOL)
        -:  221:
        -:  222:#define SPEX_OPTION_CHECK(option) \
        -:  223:    SPEX_OPTION (option, check, false)
        -:  224:
        -:  225:#define SPEX_OPTION_PIVOT(option) \
        -:  226:    SPEX_OPTION (option, pivot, SPEX_DEFAULT_PIVOT)
        -:  227:
        -:  228:#define SPEX_OPTION_ORDER(option) \
        -:  229:    SPEX_OPTION (option, order, SPEX_DEFAULT_ORDER)
        -:  230:
        -:  231:#define SPEX_OPTION_PREC(option) \
        -:  232:    SPEX_OPTION (option, prec, SPEX_DEFAULT_PRECISION)
        -:  233:
        -:  234:#define SPEX_OPTION_PRINT_LEVEL(option) \
        -:  235:    SPEX_OPTION (option, print_level, SPEX_DEFAULT_PRINT_LEVEL)
        -:  236:
        -:  237:#define SPEX_OPTION_ROUND(option) \
        -:  238:    SPEX_OPTION (option, round, SPEX_DEFAULT_MPFR_ROUND)
        -:  239:
        -:  240://------------------------------------------------------------------------------
        -:  241:// Field access macros for MPZ/MPQ/MPFR struct
        -:  242://------------------------------------------------------------------------------
        -:  243:
        -:  244:// FUTURE: make these accessible to the end user?
        -:  245:
        -:  246:// (similar definition in gmp-impl.h and mpfr-impl.h)
        -:  247:
        -:  248:#define SPEX_MPZ_SIZ(x)   ((x)->_mp_size)
        -:  249:#define SPEX_MPZ_PTR(x)   ((x)->_mp_d)
        -:  250:#define SPEX_MPZ_ALLOC(x) ((x)->_mp_alloc)
        -:  251:#define SPEX_MPQ_NUM(x)   mpq_numref(x)
        -:  252:#define SPEX_MPQ_DEN(x)   mpq_denref(x)
        -:  253:#define SPEX_MPFR_MANT(x) ((x)->_mpfr_d)
        -:  254:#define SPEX_MPFR_EXP(x)  ((x)->_mpfr_exp)
        -:  255:#define SPEX_MPFR_PREC(x) ((x)->_mpfr_prec)
        -:  256:#define SPEX_MPFR_SIGN(x) ((x)->_mpfr_sign)
        -:  257:
        -:  258:/*re-define but same result: */
        -:  259:#define SPEX_MPFR_REAL_PTR(x) (&((x)->_mpfr_d[-1]))
        -:  260:
        -:  261:/* Invalid exponent value (to track bugs...) */
        -:  262:#define SPEX_MPFR_EXP_INVALID \
        -:  263: ((mpfr_exp_t) 1 << (GMP_NUMB_BITS*sizeof(mpfr_exp_t)/sizeof(mp_limb_t)-2))
        -:  264:
        -:  265:/* Macros to set the pointer in mpz_t/mpq_t/mpfr_t variable to NULL. It is best
        -:  266: * practice to call these macros immediately after mpz_t/mpq_t/mpfr_t variable
        -:  267: * is declared, and before the mp*_init function is called. It would help to
        -:  268: * prevent error when SPEX_MP*_CLEAR is called before the variable is
        -:  269: * successfully initialized.
        -:  270: */
        -:  271:
        -:  272:#define SPEX_MPZ_SET_NULL(x)                \
        -:  273:    SPEX_MPZ_PTR(x) = NULL;                 \
        -:  274:    SPEX_MPZ_SIZ(x) = 0;                    \
        -:  275:    SPEX_MPZ_ALLOC(x) = 0;
        -:  276:
        -:  277:#define SPEX_MPQ_SET_NULL(x)                     \
        -:  278:    SPEX_MPZ_PTR(SPEX_MPQ_NUM(x)) = NULL;        \
        -:  279:    SPEX_MPZ_SIZ(SPEX_MPQ_NUM(x)) = 0;           \
        -:  280:    SPEX_MPZ_ALLOC(SPEX_MPQ_NUM(x)) = 0;         \
        -:  281:    SPEX_MPZ_PTR(SPEX_MPQ_DEN(x)) = NULL;        \
        -:  282:    SPEX_MPZ_SIZ(SPEX_MPQ_DEN(x)) = 0;           \
        -:  283:    SPEX_MPZ_ALLOC(SPEX_MPQ_DEN(x)) = 0;
        -:  284:
        -:  285:#define SPEX_MPFR_SET_NULL(x)               \
        -:  286:    SPEX_MPFR_MANT(x) = NULL;               \
        -:  287:    SPEX_MPFR_PREC(x) = 0;                  \
        -:  288:    SPEX_MPFR_SIGN(x) = 1;                  \
        -:  289:    SPEX_MPFR_EXP(x) = SPEX_MPFR_EXP_INVALID;
        -:  290:
        -:  291:/* GMP does not give a mechanism to tell a user when an mpz, mpq, or mpfr
        -:  292: * item has been cleared; thus, if mp*_clear is called on an object that
        -:  293: * has already been cleared, gmp will crash. It is also not possible to
        -:  294: * set a mp*_t = NULL. Thus, this mechanism modifies the internal GMP
        -:  295: * size of entries to avoid crashing in the case that a mp*_t is cleared
        -:  296: * multiple times.
        -:  297: */
        -:  298:
        -:  299:#define SPEX_MPZ_CLEAR(x)                        \
        -:  300:{                                                \
        -:  301:    if ((x) != NULL && SPEX_MPZ_PTR(x) != NULL)  \
        -:  302:    {                                            \
        -:  303:        mpz_clear(x);                            \
        -:  304:        SPEX_MPZ_SET_NULL(x);                    \
        -:  305:    }                                            \
        -:  306:}
        -:  307:
        -:  308:#define SPEX_MPQ_CLEAR(x)                   \
        -:  309:{                                           \
        -:  310:    SPEX_MPZ_CLEAR(SPEX_MPQ_NUM(x));        \
        -:  311:    SPEX_MPZ_CLEAR(SPEX_MPQ_DEN(x));        \
        -:  312:}
        -:  313:
        -:  314:#define SPEX_MPFR_CLEAR(x)                        \
        -:  315:{                                                 \
        -:  316:    if ((x) != NULL && SPEX_MPFR_MANT(x) != NULL) \
        -:  317:    {                                             \
        -:  318:        mpfr_clear(x);                            \
        -:  319:        SPEX_MPFR_SET_NULL(x);                    \
        -:  320:    }                                             \
        -:  321:}
        -:  322:
        -:  323:
        -:  324:// ============================================================================
        -:  325://                           Internal Functions
        -:  326:// ============================================================================
        -:  327:
        -:  328:
        -:  329:// check if SPEX_initialize* has been called
        -:  330:bool spex_initialized ( void ) ;        // true if called, false if not
        -:  331:void spex_set_initialized (bool s) ;    // set global initialzed flag to s
        -:  332:
        -:  333://------------------------------------------------------------------------------
        -:  334:// spex_create_mpfr_array: create a 1D mpfr_t array
        -:  335://------------------------------------------------------------------------------
        -:  336:
        -:  337:// Creates a simple 1D array, where A[i] is an entry of type mpfr_t.
        -:  338:
        -:  339:/* Purpose: This function creates a MPFR array of desired precision*/
        -:  340:mpfr_t* spex_create_mpfr_array
        -:  341:(
        -:  342:    int64_t n,     // size of the array
        -:  343:    const SPEX_options* option
        -:  344:);
        -:  345:
        -:  346://------------------------------------------------------------------------------
        -:  347:// spex_create_mpq_array: Creates a 1D array, whose entries are all mpq_t type.
        -:  348://------------------------------------------------------------------------------
        -:  349:
        -:  350:// Creates a simple 1D array, where A[i] is an entry of type mpq_t.
        -:  351:
        -:  352:/* Purpose: This function creates an mpq array of size n.
        -:  353: * This function must be called for all mpq arrays created.
        -:  354: */
        -:  355:mpq_t* spex_create_mpq_array
        -:  356:(
        -:  357:    int64_t n              // size of the array
        -:  358:);
        -:  359:
        -:  360:
        -:  361://------------------------------------------------------------------------------
        -:  362:// spex_create_mpz_array: create a 1D mpz_t array
        -:  363://------------------------------------------------------------------------------
        -:  364:
        -:  365:// Creates a simple 1D array, where A[i] is an entry of type mpz_t.
        -:  366:
        -:  367:/* Purpose: This function creates an mpz array of size n and allocates
        -:  368: * default size.
        -:  369: */
        -:  370:mpz_t* spex_create_mpz_array
        -:  371:(
        -:  372:    int64_t n              // Size of x
        -:  373:);
        -:  374:
        -:  375:
        -:  376://------------------------------------------------------------------------------
        -:  377:// spex_delete_mpz_array: delete a 1D mpz_t array
        -:  378://------------------------------------------------------------------------------
        -:  379:
        -:  380:// Delete a simple 1D array, where A[i] is an entry of type mpz_t.
        -:  381:
        -:  382:/* Purpose: This function deletes a mpz array of size n
        -:  383: */
        -:  384:void spex_delete_mpz_array
        -:  385:(
        -:  386:    mpz_t **x,      // mpz array to be deleted
        -:  387:    int64_t n       // Size of x
        -:  388:);
        -:  389:
        -:  390:
        -:  391:
        -:  392:/* Purpose: This function converts a double array of size n to an appropriate
        -:  393: * mpz array of size n. To do this, the number is multiplied by 10^17 then, the
        -:  394: * GCD is found. This function allows the use of matrices in double precision
        -:  395: * to work with SPEX.
        -:  396: */
        -:  397:SPEX_info spex_expand_double_array
        -:  398:(
        -:  399:    mpz_t *x_out,   // integral final array
        -:  400:    double* x,      // double array that needs to be made integral
        -:  401:    mpq_t scale,    // the scaling factor used (x_out = scale * x)
        -:  402:    int64_t n,      // size of x
        -:  403:    const SPEX_options* option
        -:  404:);
        -:  405:
        -:  406:/* Purpose: This function converts a mpfr array of size n and precision prec to
        -:  407: * an appropriate mpz array of size n. To do this, the number is multiplied by
        -:  408: * the appropriate power of 10 then the gcd is found. This function allows mpfr
        -:  409: * arrays to be used within SPEX.
        -:  410: */
        -:  411:SPEX_info spex_expand_mpfr_array
        -:  412:(
        -:  413:    mpz_t *x_out,   // integral final array
        -:  414:    mpfr_t* x,      // mpfr array to be expanded
        -:  415:    mpq_t scale,    // scaling factor used (x_out = scale*x)
        -:  416:    int64_t n,      // size of x
        -:  417:    const SPEX_options *option // command options containing the prec for mpfr
        -:  418:);
        -:  419:
        -:  420:/* Purpose: This function converts a mpq array of size n into an appropriate mpz
        -:  421: * array of size n. To do this, the lcm of the denominators is found as a
        -:  422: * scaling factor. This function allows mpq arrays to be used in SPEX
        -:  423: */
        -:  424:SPEX_info spex_expand_mpq_array
        -:  425:(
        -:  426:    mpz_t *x_out, // integral final array
        -:  427:    mpq_t* x,     // mpq array that needs to be converted
        -:  428:    mpq_t scale,  // scaling factor. x_out = scale*x
        -:  429:    int64_t n,     // size of x
        -:  430:    const SPEX_options* option // Command options
        -:  431:);
        -:  432:
        -:  433:/* Purpose: This function converts a mpq matrix of size m*n into an appropriate
        -:  434: * mpz matrix of size m*n. To do this, the lcm of the denominators is found as a
        -:  435: * scaling factor. This function allows mpq matrix to be used in SPEX.
        -:  436: * on output, x2 is modified.
        -:  437: */
        -:  438:SPEX_info spex_expand_mpq_mat
        -:  439:(
        -:  440:    mpz_t **x_out,// integral final mat
        -:  441:    mpq_t **x,    // mpq mat that needs to be converted
        -:  442:    mpq_t scale,  // scaling factor. x_out = scale*x
        -:  443:    int64_t m,    // number of rows of x
        -:  444:    int64_t n     // number of columns of x
        -:  445:);
        -:  446:
        -:  447:
        -:  448:// typecast a double value to int64, accounting for Infs and Nans
    52822:  449:static inline int64_t spex_cast_double_to_int64 (double x)
        -:  450:{
    52822:  451:    if (isnan (x))
        -:  452:    {
      389:  453:        return (0) ;
        -:  454:    }
    52433:  455:    else if (x > INT64_MAX)
        -:  456:    {
      389:  457:        return (INT64_MAX) ;
        -:  458:    }
    52044:  459:    else if (x < INT64_MIN)
        -:  460:    {
      389:  461:        return (INT64_MIN) ;
        -:  462:    }
        -:  463:    else
        -:  464:    {
    51655:  465:        return ((int64_t) (x)) ;
        -:  466:    }
        -:  467:}
        -:  468:
        -:  469:SPEX_info spex_cast_array
        -:  470:(
        -:  471:    void *Y,                // output array, of size n
        -:  472:    SPEX_type ytype,        // type of Y
        -:  473:    void *X,                // input array, of size n
        -:  474:    SPEX_type xtype,        // type of X
        -:  475:    int64_t n,              // size of Y and X
        -:  476:    mpq_t y_scale,          // scale factor applied if y is mpz_t
        -:  477:    mpq_t x_scale,          // scale factor applied if x is mpz_t
        -:  478:    const SPEX_options *option
        -:  479:) ;
        -:  480:
        -:  481:SPEX_info spex_cast_matrix
        -:  482:(
        -:  483:    SPEX_matrix **Y_handle,     // nz-by-1 dense matrix to create
        -:  484:    SPEX_type Y_type,           // type of Y
        -:  485:    SPEX_matrix *A,             // matrix with nz entries
        -:  486:    const SPEX_options *option
        -:  487:) ;
        -:  488:
        -:  489:SPEX_info spex_CSC_mpz_to_dynamic
        -:  490:(
        -:  491:    SPEX_matrix **A_handle,       // converted SPEX_mat matrix
        -:  492:    const SPEX_matrix *B,         // original matrix
        -:  493:    const SPEX_options *option
        -:  494:);
        -:  495:
        -:  496:SPEX_info spex_dynamic_to_CSC_mpz
        -:  497:(
        -:  498:    SPEX_matrix **A_handle,       // converted CSC matrix
        -:  499:    const SPEX_matrix *B,         // original matrix
        -:  500:    const int64_t nnz,            // number of nonzeros in B
        -:  501:    const SPEX_options *option
        -:  502:);
        -:  503:
        -:  504:/* Purpose: This function collapses a SPEX matrix. Essentially it shrinks the
        -:  505: * size of x and i. so that they only take up the number of elements in the
        -:  506: * matrix. For example if A->nzmax = 1000 but nnz(A) = 500, i and x are of size
        -:  507: * 1000, so this function shrinks them to size 500.
        -:  508: */
        -:  509:SPEX_info spex_sparse_collapse
        -:  510:(
        -:  511:    SPEX_matrix* A // matrix to be shrunk
        -:  512:);
        -:  513:
        -:  514:/* Purpose: This function expands a SPEX matrix by doubling its size. It
        -:  515: * merely expands x and i and does not initialize/allocate the values.
        -:  516: */
        -:  517:SPEX_info spex_sparse_realloc
        -:  518:(
        -:  519:    SPEX_matrix* A // the matrix to be expanded
        -:  520:);
        -:  521:
        -:  522:// (void *) pointer to the values of A.  A must be non-NULL with a valid type
        -:  523:#define SPEX_X(A)                                                           \
        -:  524:    ((A->type == SPEX_MPZ  ) ? (void *) A->x.mpz   :                        \
        -:  525:    ((A->type == SPEX_MPQ  ) ? (void *) A->x.mpq   :                        \
        -:  526:    ((A->type == SPEX_MPFR ) ? (void *) A->x.mpfr  :                        \
        -:  527:    ((A->type == SPEX_INT64) ? (void *) A->x.int64 : (void *) A->x.fp64))))
        -:  528:
        -:  529:
        -:  530:// return an error if A->kind (csc, triplet, dense) is wrong
        -:  531:#define SPEX_REQUIRE_KIND(A,required_kind) \
        -:  532:    if (A == NULL || A->kind != required_kind) return (SPEX_INCORRECT_INPUT) ;
        -:  533:
        -:  534:#define ASSERT_KIND(A,required_kind) \
        -:  535:    ASSERT (A != NULL && A->kind == required_kind)
        -:  536:
        -:  537:// return an error if A->type (mpz, mpq, mpfr, int64, or double) is wrong
        -:  538:#define SPEX_REQUIRE_TYPE(A,required_type) \
        -:  539:    if (A == NULL || A->type != required_type) return (SPEX_INCORRECT_INPUT) ;
        -:  540:
        -:  541:#define ASSERT_TYPE(A,required_type) \
        -:  542:    ASSERT (A != NULL && A->type == required_type)
        -:  543:
        -:  544:// return an error if A->kind or A->type is wrong
        -:  545:#define SPEX_REQUIRE(A,required_kind,required_type)     \
        -:  546:    SPEX_REQUIRE_KIND (A,required_kind) ;               \
        -:  547:    SPEX_REQUIRE_TYPE (A,required_type) ;
        -:  548:
        -:  549:#define ASSERT_MATRIX(A,required_kind,required_type)    \
        -:  550:    ASSERT_KIND (A,required_kind) ;                     \
        -:  551:    ASSERT_TYPE (A,required_type) ;
        -:  552:
        -:  553:#endif
        -:  554:
        -:  555:
        -:  556:    
