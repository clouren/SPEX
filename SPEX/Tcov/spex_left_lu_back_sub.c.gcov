        -:    0:Source:spex_left_lu_back_sub.c
        -:    0:Graph:spex_left_lu_back_sub.gcno
        -:    0:Data:spex_left_lu_back_sub.gcda
        -:    0:Runs:6
        -:    1://------------------------------------------------------------------------------
        -:    2:// SPEX_Left_LU/spex_left_lu_back_sub: sparse REF backward substitution (x = U\x)
        -:    3://------------------------------------------------------------------------------
        -:    4:
        -:    5:// SPEX_Left_LU: (c) 2019-2021, Chris Lourenco (US Naval Academy), Jinhao Chen,
        -:    6:// Erick Moreno-Centeno, Timothy A. Davis, Texas A&M.  All Rights Reserved.
        -:    7:// SPDX-License-Identifier: GPL-2.0-or-later or LGPL-3.0-or-later
        -:    8:
        -:    9://------------------------------------------------------------------------------
        -:   10:
        -:   11:/* Purpose: This function performs sparse REF backward substitution, solving
        -:   12: * the system Ux = b. Note that prior to this, x is multiplied by
        -:   13: * the determinant of A.
        -:   14: *
        -:   15: * U is a sparse mpz matrix, and bx is a dense mpz matrix.  The diagonal entry
        -:   16: * of U must appear as the last entry in each column.
        -:   17: *
        -:   18: * The input argument bx contains b on input, and it is overwritten on output
        -:   19: * by the solution x.
        -:   20: */
        -:   21:
        -:   22:#include "spex_left_lu_internal.h"
        -:   23:
      275:   24:SPEX_info spex_left_lu_back_sub  // performs sparse REF backward substitution
        -:   25:(
        -:   26:    const SPEX_matrix *U,   // input upper triangular matrix
        -:   27:    SPEX_matrix *bx         // right hand side matrix
        -:   28:)
        -:   29:{
        -:   30:
        -:   31:    //--------------------------------------------------------------------------
        -:   32:    // check inputs
        -:   33:    //--------------------------------------------------------------------------
        -:   34:
        -:   35:    SPEX_info info ;
     275*:   36:    SPEX_REQUIRE (U,  SPEX_CSC,   SPEX_MPZ) ;
     275*:   37:    SPEX_REQUIRE (bx, SPEX_DENSE, SPEX_MPZ) ;
        -:   38:
        -:   39:    //--------------------------------------------------------------------------
        -:   40:
        -:   41:    int sgn;
      275:   42:    mpz_t *Ux = U->x.mpz;
      275:   43:    int64_t *Ui = U->i;
      275:   44:    int64_t *Up = U->p;
        -:   45:
      546:   46:    for (int64_t k = 0; k < bx->n; k++)
        -:   47:    {
        -:   48:        // Start at bx[n]
     1877:   49:        for (int64_t j = U->n-1; j >= 0; j--)
        -:   50:        {
        -:   51:            // If bx[j] is zero skip this iteration
    1606*:   52:            SPEX_CHECK( SPEX_mpz_sgn( &sgn, SPEX_2D( bx, j, k, mpz)));
     1606:   53:            if (sgn == 0) {continue;}
        -:   54:
        -:   55:            // Obtain bx[j]
    1564*:   56:            SPEX_CHECK(SPEX_mpz_divexact( SPEX_2D(bx, j, k, mpz),
        -:   57:                                          SPEX_2D(bx, j, k, mpz),
        -:   58:                                          Ux[Up[j+1]-1]));
    18466:   59:            for (int64_t i = Up[j]; i < Up[j+1]-1; i++)
        -:   60:            {
   16907*:   61:                SPEX_CHECK(SPEX_mpz_sgn(&sgn, Ux[i]));
    16907:   62:                if (sgn == 0) {continue;}
        -:   63:                // bx[i] = bx[i] - Ux[i]*bx[j]
    12889:   64:                SPEX_CHECK(SPEX_mpz_submul( SPEX_2D(bx, Ui[i], k, mpz),
        -:   65:                                            Ux[i], SPEX_2D(bx, j, k, mpz)));
        -:   66:            }
        -:   67:        }
        -:   68:    }
        -:   69:
      270:   70:    return (SPEX_OK) ;
        -:   71:}
        -:   72:
