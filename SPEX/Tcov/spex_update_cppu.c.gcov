        -:    0:Source:spex_update_cppu.c
        -:    0:Graph:spex_update_cppu.gcno
        -:    0:Data:spex_update_cppu.gcda
        -:    0:Runs:3
        -:    1://------------------------------------------------------------------------------
        -:    2:// SPEX_Update/spex_update_cppu.c: perform column permutation pivot update
        -:    3://------------------------------------------------------------------------------
        -:    4:
        -:    5:// SPEX_Update: (c) 2020-2021, Jinhao Chen, Timothy A. Davis, Erick
        -:    6:// Moreno-Centeno, Texas A&M University.  All Rights Reserved.  See
        -:    7:// SPEX_Update/License for the license.
        -:    8:
        -:    9://------------------------------------------------------------------------------
        -:   10:
        -:   11:// Purpose: This function is called to perform column permutation pivot update
        -:   12:// when the submatrix (formed by rows and columns k to ks) has the following
        -:   13:// pattern
        -:   14://       x 0 0 0 x       <- row k
        -:   15://       . x . . .
        -:   16://       . . x . .
        -:   17://       . . . x .
        -:   18://       . . . . x       <- row ks
        -:   19://
        -:   20://       ^       ^
        -:   21://       |       |
        -:   22://     col k   col ks
        -:   23://       
        -:   24:// This function will swap columns k and ks in L and U. Noted that the columns
        -:   25:// of U are permuted implicitly via the permutation matrix based on Q.
        -:   26:
        -:   27:#define SPEX_FREE_ALL                \
        -:   28:    SPEX_MPZ_CLEAR(Uiks);            \
        -:   29:    SPEX_MPQ_CLEAR(pending_scale);   \
        -:   30:    SPEX_MPZ_CLEAR(tmpz);
        -:   31:
        -:   32:#include "spex_update_internal.h"
        -:   33:
        -:   34:#define SL(k) (L->v[(k)]->scale)
        -:   35:#define SU(k) (U->v[(k)]->scale)
        -:   36:
    14680:   37:SPEX_info spex_update_cppu
        -:   38:(
        -:   39:    SPEX_matrix *L,     // matrix L
        -:   40:    SPEX_matrix *U,     // matrix U
        -:   41:    SPEX_matrix *rhos,// array of scaled pivots
        -:   42:    spex_scattered_vector *Lk_dense_col,// scattered column k of L
        -:   43:    spex_scattered_vector *Uk_dense_row,// scattered column k of U
        -:   44:    int64_t *inext,  // the index of first off-diag entry in col k of L
        -:   45:    int64_t *jnext,  // the index of first off-diag entry in row k of U
        -:   46:    int64_t *h,      // allocated vector that can be used for history vector.
        -:   47:                     // All entries are maintained to be >= -1
        -:   48:    int64_t *Q,      // column permutation
        -:   49:    int64_t *Q_inv,  // inverse of column permutation
        -:   50:    int64_t *P,      // row permutation (unchanged on output)
        -:   51:    int64_t *P_inv,  // inverse of row permutation (unchanged on output)
        -:   52:
        -:   53:    // the col-wise nnz pattern of U can be NULL when ks == n
        -:   54:    const int64_t *Uci_ks,// the row index for nnz pattern of U(k+1:ks-1,Q[ks])
        -:   55:    const int64_t *Ucx_ks,// the value of i-th entry is found as
        -:   56:                     // U->v[Uci[i]]->x[Ucx[i]]
        -:   57:    const int64_t Uc_ks_nz,// # of nnz in U(k+1:ks-1,Q[ks])
        -:   58:    const int64_t k, // current column index 0 <= k < n
        -:   59:    const int64_t ks,// index of the diagonal to be swapped with, [0,n)
        -:   60:    const SPEX_options *option
        -:   61:)
        -:   62:{
        -:   63:#ifdef SPEX_DEBUG
        -:   64:    printf("using cppu swapping k(%ld) and ks(%ld), Uc_nz=%ld\n",k,ks,Uc_ks_nz);
        -:   65:#endif
        -:   66:    // initialize workspace
        -:   67:    SPEX_info info;
        -:   68:    int sgn, r;
    14680:   69:    int64_t pk, ck, pks, cks, pi, ci, i, j, n = U->n;
    14680:   70:    int64_t Lk_nz = 0;
        -:   71:    // the pointer for U(k,Q(ks)) = U->v[k]->x[Ucx[Ucp_k_ks]]
    14680:   72:    int64_t Ucp_k_ks = -1;
    14680:   73:    int64_t Qk = Q[k], Qks, Pk = P[k], Pks, Pi;
    14680:   74:    *inext = n;
    14680:   75:    *jnext = n;
    14680:   76:    mpz_t *sd = rhos->x.mpz;
        -:   77:
        -:   78:    mpq_t pending_scale;
    14680:   79:    SPEX_MPQ_SET_NULL(pending_scale);
    14680:   80:    mpz_t Uiks, tmpz; SPEX_MPZ_SET_NULL(Uiks); SPEX_MPZ_SET_NULL(tmpz);
   14680*:   81:    SPEX_CHECK(SPEX_mpq_init(pending_scale));
   14566*:   82:    SPEX_CHECK(SPEX_mpz_init(Uiks));
   14509*:   83:    SPEX_CHECK(SPEX_mpz_init(tmpz));
        -:   84:
    14452:   85:    if (ks == n)
        -:   86:    {
        -:   87:#ifdef SPEX_DEBUG
        -:   88:        printf("ks==n using cppu\n");
        -:   89:#endif
     6008:   90:        Qks = Q[n-1];
        -:   91:        // since the value in Uk_dense_row[Q[k]] will not be used, we use it to
        -:   92:        // hold the original value of sd[k] before swapping column k with
        -:   93:        // column n-1. Then we set sd[k] to the new pivot of column k of L
        -:   94:        // vk[P[k]], which is kept as first entry in the nnz list.
    6008*:   95:        SPEX_CHECK(SPEX_mpz_swap(Uk_dense_row->x[Qk], sd[k]));
    6008*:   96:        SPEX_CHECK(SPEX_mpz_set(sd[k], L->v[k]->x[0]));
        -:   97:
        -:   98:        // get the scale for entries between frames k and n-1
        -:   99:        // pending_scale = sd(k)/Uk_dense_row[Q[k]]
    6008*:  100:        SPEX_CHECK(SPEX_mpq_set_z(pending_scale, sd[k]));
    6008*:  101:        SPEX_CHECK(SPEX_mpq_set_den(pending_scale, Uk_dense_row->x[Qk]));
    6008*:  102:        SPEX_CHECK(SPEX_mpq_canonicalize(pending_scale));
        -:  103:
        -:  104:        // if the inserted column is used, we won't need to perform
        -:  105:        // backtracking. Instead, we just need to perform RwSOP.
        -:  106:        //
        -:  107:        // If U(k, Q[n-1]) == 0, RwSOP is simplified as pure scaling for all
        -:  108:        // frame from k+1:n-1. Otherwise (which won't happen due to heuristic),
        -:  109:        // we need to first compute the (n-1)-th IPGE iteration for the column
        -:  110:        // k, and use the result to perform RwSOP on column n-1 of U.
    6008*:  111:        SPEX_CHECK(SPEX_mpz_sgn(&sgn, Uk_dense_row->x[Qks]));
     6008:  112:        if (sgn == 0)
        -:  113:        {
        -:  114:            // just need to perform RwSOP by scaling all frame k+1:n-1
     6422:  115:            for (j = k+1; j < n; j++)
        -:  116:            {
        -:  117:                // S(:,k+1:n-1) = S(:,k+1:n-1)*pending_scale;
     3933:  118:                SPEX_CHECK(SPEX_mpq_mul(SL(j), SL(j), pending_scale));
     3917:  119:                SPEX_CHECK(SPEX_mpq_mul(SU(j), SU(j), pending_scale));
        -:  120:                // sd(k+1:n-1) = sd(k+1:n-1)*pending_scale;
    3902*:  121:                SPEX_CHECK(SPEX_mpz_divexact(sd[j],
        -:  122:                                        sd[j], SPEX_MPQ_DEN(pending_scale)));
     3902:  123:                SPEX_CHECK(SPEX_mpz_mul(sd[j],
        -:  124:                                        sd[j], SPEX_MPQ_NUM(pending_scale)));
        -:  125:            }
        -:  126:
        -:  127:            // move data from Uk_dense_row, but there is no entry that needs
        -:  128:            // to move
     2489:  129:            U->v[k]->nz = 0;
        -:  130:        }
        -:  131:        else
        -:  132:        {
        -:  133:            // apply pending scale to row k of U, which has 1 nnz U(k,Q[n-1])
        -:  134:            // U(k,Q[n-1]) = U(k, Q[n-1])*S(2,k)
    3481*:  135:            SPEX_CHECK(SPEX_mpz_divexact(Uk_dense_row->x[Qks],
        -:  136:                      Uk_dense_row->x[Qks], SPEX_MPQ_DEN(SU(k))));
     3481:  137:            SPEX_CHECK(SPEX_mpz_mul(Uk_dense_row->x[Qks],
        -:  138:                      Uk_dense_row->x[Qks], SPEX_MPQ_NUM(SU(k))));
        -:  139:            // S(:,k) will be set to 1 after calling this function in SPEX_LUU
        -:  140:
        -:  141:            // perform 1 IPGE iteration on Lk_dense_col using vk (which has
        -:  142:            // been inserted as L->v[k]) and update the history vector. Then
        -:  143:            // use L to perform the remaining IPGE update till (n-1)-th
        -:  144:            // iteration. Finally, use the result to update column n-1 of U.
        -:  145:            //
        -:  146:            // It should be noted that, since the resulted column in the
        -:  147:            // (n-1)-th IPGE iteration is computed using column k of L instead
        -:  148:            // of the inserted column, its sign should be flipped when applying
        -:  149:            // RwSOP.
        -:  150:            // tmz = gcd(numerator(S(1,k)), sd[k-1])
     3480:  151:            if (k > 0)
        -:  152:            {
    3480*:  153:                SPEX_CHECK(SPEX_mpz_gcd(tmpz, sd[k-1], SPEX_MPQ_NUM(SL(k))));
        -:  154:            }
    11462:  155:            for (pk = 0; pk < Lk_dense_col->nz; pk++)
        -:  156:            {
     7990:  157:                ck = Lk_dense_col->i[pk];
        -:  158:                // initialize history vector
     7990:  159:                h[ck] = SPEX_FLIP(k-1);
        -:  160:                // Instead of apply the real pending scale to Lk_dense_col
        -:  161:                // before using IPGE in order to maintain the result of
        -:  162:                // IPGE in the integer domain, we just multiply each entry
        -:  163:                // with tmpz, which will do the same work. In addition,
        -:  164:                // there is no need to update the pending scale for
        -:  165:                // Lk_dense_col, since it won't be needed nor used beyond
        -:  166:                // this point and Lk_dense_col will be cleared at the end
        -:  167:                // of LU update process.
        -:  168:                //SPEX_CHECK(SPEX_mpz_divexact(Lk_dense_col->x[ck],
        -:  169:                //          Lk_dense_col->x[ck], SPEX_MPQ_DEN(SL(k))));
        -:  170:                //SPEX_CHECK(SPEX_mpz_mul(Lk_dense_col->x[ck],
        -:  171:                //          Lk_dense_col->x[ck], SPEX_MPQ_NUM(SL(k))));
     7990:  172:                if (k > 0)
        -:  173:                {
        -:  174:                    // if k == 0, we have tmpz == 1, then this is skipped
     7990:  175:                    SPEX_CHECK(SPEX_mpz_mul(Lk_dense_col->x[ck],
        -:  176:                                            Lk_dense_col->x[ck], tmpz));
        -:  177:                }
        -:  178:            }
        -:  179:
        -:  180:            // skip updating L(P[k],k), so start from pk = 1
     7929:  181:            for (pk = 1; pk < L->v[k]->nz; pk++)
        -:  182:            {
     4457:  183:                ck = L->v[k]->i[pk];
        -:  184:                
        -:  185:#ifdef SPEX_DEBUG
        -:  186:                // all explicit zeros are removed when put into L->v[k]
        -:  187:                SPEX_CHECK(SPEX_mpz_sgn(&sgn, L->v[k]->x[pk]));
        -:  188:                ASSERT (sgn != 0);
        -:  189:#endif
        -:  190:
        -:  191:                // L(ck,k) = (L(ck, k)*vk(P[k])-L(P[k],k)*vk(ck))/sd[k-1]
    4457*:  192:                SPEX_CHECK(SPEX_mpz_sgn(&sgn, Lk_dense_col->x[ck]));
     4457:  193:                if (sgn != 0)
        -:  194:                {
    4040*:  195:                    SPEX_CHECK(SPEX_mpz_mul(Lk_dense_col->x[ck],
        -:  196:                                            Lk_dense_col->x[ck], sd[k]));
        -:  197:                }
      417:  198:                else if (h[ck] >= -1) //this entry wasn't in the nnz pattern
        -:  199:                {
        -:  200:                    // insert new entry in the nonzero pattern
      417:  201:                    Lk_dense_col->i[Lk_dense_col->nz] = ck;
      417:  202:                    Lk_dense_col->nz++;
        -:  203:                }
    4457*:  204:                SPEX_CHECK(SPEX_mpz_submul(Lk_dense_col->x[ck],
        -:  205:                                           Lk_dense_col->x[Pk],
        -:  206:                                           L->v[k]->x[pk]));
     4457:  207:                if (k > 0)
        -:  208:                {
    4457*:  209:                    SPEX_CHECK(SPEX_mpz_divexact(Lk_dense_col->x[ck],
        -:  210:                                                 Lk_dense_col->x[ck], sd[k-1]));
        -:  211:                }
     4457:  212:                h[ck] = SPEX_FLIP(k);
        -:  213:            }
        -:  214:
        -:  215:            // perform IPGE and RwSOP
     8656:  216:            for (i = k+1; i < n; i++)
        -:  217:            {
     5223:  218:                Pi = P[i];
        -:  219:                // S(:,i) = S(:, i)*pending_scale;
     5223:  220:                SPEX_CHECK(SPEX_mpq_mul(SL(i), SL(i), pending_scale));
     5215:  221:                SPEX_CHECK(SPEX_mpq_mul(SU(i), SU(i), pending_scale));
        -:  222:
    5210*:  223:                SPEX_CHECK(SPEX_mpz_sgn(&sgn, Lk_dense_col->x[Pi]));
        -:  224:                // we compute sd[n-1] differently
     5210:  225:                if (sgn == 0 || i != n-1)
        -:  226:                {
        -:  227:                    // sd[i] = sd[i]*pending_scale
     2297:  228:                    SPEX_CHECK(SPEX_mpz_mul(sd[i], sd[i],
        -:  229:                                            SPEX_MPQ_NUM(pending_scale)));
    2294*:  230:                    SPEX_CHECK(SPEX_mpz_divexact(sd[i], sd[i],
        -:  231:                                            SPEX_MPQ_DEN(pending_scale)));
        -:  232:
        -:  233:                    // skip if Lk_dense_col[P[i]] == 0
     2294:  234:                    if (sgn == 0)       {continue;}
        -:  235:                }
        -:  236:
        -:  237:                // perform i-th IPGE update for Lk_dense_col
     3666:  238:                SPEX_CHECK(spex_update_ipge(Lk_dense_col, h, NULL, L->v[i],
        -:  239:                    P, P_inv, (const SPEX_matrix*)rhos, i));
        -:  240:
        -:  241:                // perform RwSOP for row i with flipped-sign entries in
        -:  242:                // Lk_dense_col. All entries in row i of U must be SCALEUP such
        -:  243:                // that S(:,i)=[S(1,i);1]
     3660:  244:                int64_t p = 0; // the pointer to U(i,Q(n-1))
     3660:  245:                if ( i != n-1 )
        -:  246:                {
      747:  247:                    p = -1;
        -:  248:                    // set U(i, Q(i)) = sd[i]
     747*:  249:                    SPEX_CHECK(SPEX_mpz_set(U->v[i]->x[0], sd[i]));
        -:  250:
        -:  251:                    // iterate all nnz in row i of U
     1493:  252:                    for (pi = 1; pi < U->v[i]->nz; pi++)
        -:  253:                    {
      746:  254:                        ci = U->v[i]->i[pi];
      746:  255:                        if (ci == Qks)
        -:  256:                        {
      745:  257:                            p = pi;
        -:  258:                        }
        -:  259:                        else //if (Q_inv[ci] < n-1)
        -:  260:                        {
        -:  261:                            // apply S(2,i) to U(i,Q(i:n-2))
       1*:  262:                            SPEX_CHECK(SPEX_mpz_divexact(U->v[i]->x[pi],
        -:  263:                                U->v[i]->x[pi], SPEX_MPQ_DEN(SU(i))));
       1*:  264:                            SPEX_CHECK(SPEX_mpz_mul(U->v[i]->x[pi],
        -:  265:                                U->v[i]->x[pi], SPEX_MPQ_NUM(SU(i))));
        -:  266:                        }
        -:  267:                    }
        -:  268:                }
        -:  269:                // perform RwSOP to U(i,Q(n-1)), POSSIBLE FILLIN
        -:  270:                // sign is changed here due to column swap
        -:  271:                // U(i,Qks)= U(i,Qks)*S(2,i) +
        -:  272:                //        Lk_dense_col(P[i])*U(k,Qks)/Lk_dense_col[P[k]]
     3660:  273:                if (p > -1)
        -:  274:                {
     3658:  275:                    SPEX_CHECK(SPEX_mpz_mul(U->v[i]->x[p],
        -:  276:                               U->v[i]->x[p], SPEX_MPQ_NUM(SU(i))));
    3654*:  277:                    SPEX_CHECK(SPEX_mpz_fdiv_q(U->v[i]->x[p],
        -:  278:                               U->v[i]->x[p], SPEX_MPQ_DEN(SU(i))));
     3654:  279:                    SPEX_CHECK(SPEX_mpz_mul(tmpz,
        -:  280:                               Lk_dense_col->x[Pi], Uk_dense_row->x[Qks]));
    3643*:  281:                    SPEX_CHECK(SPEX_mpz_cdiv_q(tmpz, tmpz,
        -:  282:                               Lk_dense_col->x[Pk]));
    3643*:  283:                    SPEX_CHECK(SPEX_mpz_add(U->v[i]->x[p],U->v[i]->x[p], tmpz));
        -:  284:                }
        -:  285:                else // U(i,Q(n-1)) was not in the nnz pattern
        -:  286:                {
        2:  287:                    p = U->v[i]->nz;
        -:  288:                    // reallocate the nonzero pattern if needed
        2:  289:                    if (p == U->v[i]->nzmax)
        -:  290:                    {
       2*:  291:                        SPEX_CHECK(SPEX_vector_realloc(U->v[i],
        -:  292:                            SPEX_MIN(n, 2*(U->v[i]->nzmax)), option));
        -:  293:                    }
        -:  294:                    // insert new entry in the nonzero pattern
        2:  295:                    U->v[i]->i[p] = Qks;
        2:  296:                    U->v[i]->nz++;
        -:  297:
       2*:  298:                    SPEX_CHECK(SPEX_mpz_mul(U->v[i]->x[p],
        -:  299:                                  Lk_dense_col->x[Pi], Uk_dense_row->x[Qks]));
       2*:  300:                    SPEX_CHECK(SPEX_mpz_divexact(U->v[i]->x[p],
        -:  301:                                  U->v[i]->x[p], Lk_dense_col->x[Pk]));
        -:  302:                }
    3645*:  303:                SPEX_CHECK(SPEX_mpq_set_ui(SU(i), 1, 1));
        -:  304:                
     3645:  305:                if (i == n-1)
        -:  306:                {
        -:  307:                    // make sure U(n-1,Q(n-1)) != 0
    2900*:  308:                    SPEX_CHECK(SPEX_mpz_sgn(&sgn, U->v[n-1]->x[0]));
     2900:  309:                    if (sgn == 0)
        -:  310:                    {
        2:  311:                        SPEX_FREE_ALL;
        2:  312:                        return SPEX_SINGULAR;
        -:  313:                    }
        -:  314:
        -:  315:                    // L(P(n-1),n-1) = sd(n-1) = U(n-1, Q(n-1))
    2898*:  316:                    SPEX_CHECK(SPEX_mpz_set(L->v[n-1]->x[0], U->v[n-1]->x[0]));
    2898*:  317:                    SPEX_CHECK(SPEX_mpz_set(  sd[n-1]      , U->v[n-1]->x[0]));
        -:  318:                    // S(:,n-1) = ones
    2898*:  319:                    SPEX_CHECK(SPEX_mpq_set_ui(SL(n-1), 1, 1));
    2898*:  320:                    SPEX_CHECK(SPEX_mpq_set_ui(SU(n-1), 1, 1));
        -:  321:                }
        -:  322:            }
        -:  323:
        -:  324:            // move data from Uk_dense_row, there is only one entry that needs
        -:  325:            // to move, which is U(k,Q[n-1]) and has no pending scale
    3433*:  326:            SPEX_CHECK(SPEX_mpz_swap(U->v[k]->x[0], Uk_dense_row->x[Qks]));
     3433:  327:            U->v[k]->i[0] = Qks;
     3433:  328:            U->v[k]->nz = 1;
        -:  329:        }
        -:  330:
        -:  331:        // reset Uk_dense_row->x[Q[k]]=0
    5922*:  332:        SPEX_CHECK(SPEX_mpz_set_ui(Uk_dense_row->x[Qk], 0));
     5922:  333:        SPEX_FREE_ALL;
     5922:  334:        return SPEX_OK;
        -:  335:    }
        -:  336:    //-------------------------------------------------------------------------
        -:  337:    // Backtracking column ks of L and U, the backtracking result will be moved
        -:  338:    // to column k of L.
        -:  339:    //-------------------------------------------------------------------------
        -:  340:    // When U(k+1:ks-1,Q(ks)) are all zero(s), there is no need to make a copy
        -:  341:    // of Lk_dense_col. Instead, we can direct operate on Lk_dense_col.
        -:  342:    // Otherwise, Lk_dense_col will firstly be moved to L->v[k]->x in a
        -:  343:    // compressed-column form. Then Lk_dense_col will make a copy of ks-th
        -:  344:    // column of scaled L and scaled U(k:ks-1,Q(ks)). Backtracking will be
        -:  345:    // performed on Lk_dense_col for each nonzero in U(k:ks-1, Q(ks)).
        -:  346:    //-------------------------------------------------------------------------
     8444:  347:    Qks = Q[ks];
     8444:  348:    Pks = P[ks];
        -:  349:
     8444:  350:    if (Uc_ks_nz == 0)   // If U(k+1:ks-1,Q(ks)) are all zero(s).
        -:  351:    {
        -:  352:        // . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
        -:  353:        // backtracking jumbled sparse column ks of L using 'dense' column k of
        -:  354:        // L and store the result in Lk_dense_col. This will introduce new
        -:  355:        // entry to Lk_dense_col.
        -:  356:        //
        -:  357:        // When explicit zeros in L(:, ks) resulted from exact
        -:  358:        // cancellation in IPGE update were not removed (SLIP LU keeps those
        -:  359:        // zeros in output L and U), nonzero pattern of L(P(ks:n+1),k) should
        -:  360:        // be a subset of L(:,ks). Therefore, the backtracking will need to 
        -:  361:        // simply iterate all nonzero in the L(:,ks), and the final Lk_dense_col
        -:  362:        // will have mostly the same nnz pattern as L(:,ks), except L(P(k),k).
        -:  363:        //
        -:  364:        // However, since we assume the IPGE update results in exact
        -:  365:        // cancellation and the resulted zero is removed from L or U, the
        -:  366:        // subset relation of the nonzero pattern no longer holds. In this
        -:  367:        // case, we need to first update Lk_dense_col based on the nonzero
        -:  368:        // pattern of L(:,ks), and additionally iterate across all nonzeros in
        -:  369:        // Lk_dense_col to find if any entry in Lk_dense_col is untouched, then
        -:  370:        // perform the following
        -:  371:        // L(i,k) = L(i,k)*U(k, Q[ks])/L(P(k),k)
        -:  372:        // . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
        -:  373:        // pending_scale = sd[k-1]/sd[ks-1]
     6969:  374:        if (k > 0)
        -:  375:        {
    6818*:  376:            SPEX_CHECK(SPEX_mpq_set_z(pending_scale, sd[k-1]));
        -:  377:        }
        -:  378:        else
        -:  379:        {
     151*:  380:            SPEX_CHECK(SPEX_mpq_set_ui(pending_scale, 1, 1));
        -:  381:        }
    6969*:  382:        SPEX_CHECK(SPEX_mpq_set_den(pending_scale, sd[ks-1]));
        -:  383:        // remove common factor in mpq_den and mpq_num
    6969*:  384:        SPEX_CHECK(SPEX_mpq_canonicalize(pending_scale));
        -:  385:
        -:  386:        // pending_scale *= S(1,ks)
     6969:  387:        SPEX_CHECK(SPEX_mpq_mul(pending_scale, pending_scale, SL(ks)));
        -:  388:
        -:  389:        // U(k,Q[ks]) will be the new k-th pivot, so we update sd[k] and insert
        -:  390:        // it as the first nonzero in L->v[k]
        -:  391:        // sd[k] = U(k,Q(ks))*S(2,k)
    6915*:  392:        SPEX_CHECK(SPEX_mpz_divexact(sd[k], Uk_dense_row->x[Qks],
        -:  393:                                     SPEX_MPQ_DEN(SU(k))));
     6915:  394:        SPEX_CHECK(SPEX_mpz_mul(sd[k], sd[k], SPEX_MPQ_NUM(SU(k))));
        -:  395:        // update L(P(k),k) = sd[k], which will be the first entry in the list
    6904*:  396:        SPEX_CHECK(SPEX_mpz_set(L->v[k]->x[0], sd[k]));
     6904:  397:        L->v[k]->i[0] = Pk;
     6904:  398:        Lk_nz = 1; // Lk_nz is the # of nnz in L->v[k]
        -:  399:
        -:  400:        // perform backtracking for each nonzero in col ks of L and store
        -:  401:        // results in Lk_dense_col
        -:  402:        // NOTE: this will cause fillin in the k(th) column of L
        -:  403:        // make sure L->v[k] has enough space to hold all the nnz in L(:,ks) and
        -:  404:        // U(k,ks) that will be inserted
     6904:  405:        if (L->v[k]->nzmax < L->v[ks]->nz+1)
        -:  406:        {
     1256:  407:            SPEX_CHECK(SPEX_vector_realloc(L->v[k],
        -:  408:                SPEX_MIN(n, SPEX_MAX(2*(L->v[k]->nzmax), L->v[ks]->nz+1)),
        -:  409:                option));
        -:  410:        }
        -:  411:
        -:  412:        // update entries in L(:,k) for each nnz in L(:,ks)
        -:  413:        // Lk_untouched is the number of entries in Lk_dense_col that have not
        -:  414:        // been used to backtrack yet
     6884:  415:        int64_t Lk_untouched = Lk_dense_col->nz;
    20325:  416:        for (pks = 0; pks < L->v[ks]->nz; pks++)
        -:  417:        {
        -:  418:            // row index in column ks of L
    13494:  419:            cks = L->v[ks]->i[pks];
        -:  420:
        -:  421:            // . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
        -:  422:            // L(cks,k) = L(cks,k)*U(k,Q[ks])/L(P[k],k)+L(cks,ks)*pending_scale
        -:  423:            //          = L(cks,k)*  sd[k]   /L(P[k],k)+L(cks,ks)*pending_scale
        -:  424:            // . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
   13494*:  425:            SPEX_CHECK(SPEX_mpz_sgn(&sgn, L->v[ks]->x[pks]));
    13494:  426:            if (sgn != 0)
        -:  427:            {
   13478*:  428:                SPEX_CHECK(SPEX_mpz_sgn(&sgn, Lk_dense_col->x[cks]));
    13478:  429:                if (sgn != 0)
        -:  430:                {
        -:  431:                    // L(cks,k) = floor(L(cks,k)*sd[k]/L(P[k],k))
     9938:  432:                    SPEX_CHECK(SPEX_mpz_mul(Lk_dense_col->x[cks],
        -:  433:                        Lk_dense_col->x[cks], sd[k]));
    9925*:  434:                    SPEX_CHECK(SPEX_mpz_fdiv_q(Lk_dense_col->x[cks],
        -:  435:                        Lk_dense_col->x[cks], Lk_dense_col->x[Pk]));
        -:  436:
        -:  437:                    // tmpz = ceil(L(cks,ks)*pending_scale)
     9925:  438:                    SPEX_CHECK(SPEX_mpz_mul(tmpz, L->v[ks]->x[pks],
        -:  439:                        SPEX_MPQ_NUM(pending_scale)));
    9902*:  440:                    SPEX_CHECK(SPEX_mpz_cdiv_q(tmpz, tmpz,
        -:  441:                        SPEX_MPQ_DEN(pending_scale)));
        -:  442:
        -:  443:                    // L(cks,k) = L(cks,k)+tmpz
    9902*:  444:                    SPEX_CHECK(SPEX_mpz_add(Lk_dense_col->x[cks],
        -:  445:                        Lk_dense_col->x[cks], tmpz));
     9902:  446:                    Lk_untouched--;
        -:  447:                }
        -:  448:                else  // fillin 
        -:  449:                {
        -:  450:                    // L(cks,k) = L(cks,ks)*pending_scale
    3540*:  451:                    SPEX_CHECK(SPEX_mpz_divexact(Lk_dense_col->x[cks],
        -:  452:                        L->v[ks]->x[pks], SPEX_MPQ_DEN(pending_scale)));
     3540:  453:                    SPEX_CHECK(SPEX_mpz_mul(Lk_dense_col->x[cks],
        -:  454:                        Lk_dense_col->x[cks], SPEX_MPQ_NUM(pending_scale)));
        -:  455:                }
        -:  456:            }
        -:  457:            else
        -:  458:            {
      16*:  459:                SPEX_CHECK(SPEX_mpz_sgn(&sgn, Lk_dense_col->x[cks]));
       16:  460:                if (sgn != 0)
        -:  461:                {
        -:  462:                    // L(cks,k) = L(cks,k)*sd[k]/L(P[k],k)
      10*:  463:                    SPEX_CHECK(SPEX_mpz_mul(Lk_dense_col->x[cks],
        -:  464:                        Lk_dense_col->x[cks], sd[k]));
      10*:  465:                    SPEX_CHECK(SPEX_mpz_divexact(Lk_dense_col->x[cks],
        -:  466:                        Lk_dense_col->x[cks], Lk_dense_col->x[Pk]));
       10:  467:                    Lk_untouched--;
        -:  468:                }
        -:  469:            }
        -:  470:
        -:  471:            // . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
        -:  472:            // move nonzero entry from Lk_dense_col to L->v[k]->x
        -:  473:            // NOTE: explicit zero due to exact cancellation in backtracking
        -:  474:            //       is removed
        -:  475:            // . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
   13441*:  476:            SPEX_CHECK(SPEX_mpz_sgn(&sgn, Lk_dense_col->x[cks]));
    13441:  477:            if (sgn != 0)
        -:  478:            {
    10775:  479:                L->v[k]->i[Lk_nz] = cks;
   10775*:  480:                SPEX_CHECK(SPEX_mpz_swap(L->v[k]->x[Lk_nz],
        -:  481:                                         Lk_dense_col->x[cks]));
        -:  482:                // reset L(cks,k)=0 in the scattered vector
   10775*:  483:                SPEX_CHECK(SPEX_mpz_set_ui(Lk_dense_col->x[cks], 0));
    10775:  484:                Lk_nz++;
        -:  485:            }
        -:  486:        }
        -:  487:
        -:  488:        // continue the backtracking process in case explicit zeros are removed
        -:  489:        // in column ks, which means certain entries in column k remain
        -:  490:        // untouched.
        -:  491:        // check if there is any other nnz left untouched other than L(P[k],k)
     6831:  492:        if (Lk_untouched > 1)
        -:  493:        {
        -:  494:            // Lk_untouched is the max # of nnz that would be inserted
     2287:  495:            if (L->v[k]->nzmax < Lk_nz+Lk_untouched)
        -:  496:            {
     2170:  497:                SPEX_CHECK(SPEX_vector_realloc(L->v[k],
        -:  498:                       SPEX_MIN(n, SPEX_MAX(2*(L->v[k]->nzmax),
        -:  499:                                            Lk_nz+Lk_untouched)), option));
        -:  500:            }
    10012:  501:            for (pk = 0; pk < Lk_dense_col->nz; pk++)
        -:  502:            {
        -:  503:                // row index in scattered form of column k of L
     7769:  504:                ck = Lk_dense_col->i[pk];
        -:  505:
        -:  506:                // skip L(P[k],k)
     7769:  507:                if (ck == Pk)      {continue;}
        -:  508:
        -:  509:                // remove explicit 0s
    5515*:  510:                SPEX_CHECK(SPEX_mpz_sgn(&sgn, Lk_dense_col->x[ck]));
     5515:  511:                if (sgn == 0)
        -:  512:                {
     1502:  513:                    continue;
        -:  514:                }
        -:  515:
        -:  516:                // L(ck,k) = L(ck,k)*sd[k]/L(P[k],k)
     4013:  517:                SPEX_CHECK(SPEX_mpz_mul(Lk_dense_col->x[ck],
        -:  518:                                        Lk_dense_col->x[ck], sd[k]));
    4002*:  519:                SPEX_CHECK(SPEX_mpz_divexact(Lk_dense_col->x[ck],
        -:  520:                                             Lk_dense_col->x[ck],
        -:  521:                                             Lk_dense_col->x[Pk]));
     4002:  522:                L->v[k]->i[Lk_nz] = ck;
    4002*:  523:                SPEX_CHECK(SPEX_mpz_swap(L->v[k]->x[Lk_nz],
        -:  524:                                         Lk_dense_col->x[ck]));
        -:  525:                // reset L(ck,k)=0 in the scattered vector
    4002*:  526:                SPEX_CHECK(SPEX_mpz_set_ui(Lk_dense_col->x[ck], 0));
     4002:  527:                Lk_nz++;
        -:  528:            }
        -:  529:        }
        -:  530:        // update number of nnz
     6787:  531:        L->v[k]->nz = Lk_nz;
        -:  532:        // For L(P[k],k), we don't need to place it as U(k,Q(ks)) since
        -:  533:        // k-th col will be deleted. Therefore, just reset it to 0.
    6787*:  534:        SPEX_CHECK(SPEX_mpz_set_ui(Lk_dense_col->x[Pk], 0));
        -:  535:    }
        -:  536:    else  // U(ks+1:k-1,Q(ks)) contains nnz(s)
        -:  537:    {
        -:  538:        // . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
        -:  539:        // construct column k of L based on Lk_dense_col
        -:  540:        // explicit zeros are not removed/skipped, since they should be rarely
        -:  541:        // found here (appear only when exact cancellation happens) and also
        -:  542:        // this vector will be updated right after the backtracking process.
        -:  543:        // . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
     1475:  544:        if (Lk_dense_col->nz > L->v[k]->nzmax)
        -:  545:        {
       1*:  546:            SPEX_CHECK(SPEX_vector_realloc(L->v[k],
        -:  547:                SPEX_MIN(n, SPEX_MAX(2*(L->v[k]->nzmax), Lk_dense_col->nz)),
        -:  548:                option));
        -:  549:        }
        -:  550:
        -:  551:        // put pivot as the first entries in L->v[k]->x
    1475*:  552:        SPEX_CHECK(SPEX_mpz_swap(L->v[k]->x[0], Lk_dense_col->x[Pk]));
    1475*:  553:        SPEX_CHECK(SPEX_mpz_set_ui(Lk_dense_col->x[Pk], 0));
     1475:  554:        L->v[k]->i[0] = Pk;
     1475:  555:        Lk_nz = 1;
     6391:  556:        for (pk = 0; pk < Lk_dense_col->nz; pk++)
        -:  557:        {
     4916:  558:            ck = Lk_dense_col->i[pk];
        -:  559:            // pivot has been inserted
     4916:  560:            if (ck == Pk)            {continue;}
        -:  561:            // swap the entries in the Lk_dense_col and L->v[k]->x
    3441*:  562:            SPEX_CHECK(SPEX_mpz_swap(L->v[k]->x[Lk_nz], Lk_dense_col->x[ck]));
    3441*:  563:            SPEX_CHECK(SPEX_mpz_set_ui(Lk_dense_col->x[ck], 0));
     3441:  564:            L->v[k]->i[Lk_nz] = ck;
     3441:  565:            Lk_nz++;
        -:  566:        }
     1475:  567:        L->v[k]->nz = Lk_nz;
        -:  568:        // Lk_dense_col->nz = 0;
        -:  569:
        -:  570:        // . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
        -:  571:        // initialize history vector h and copy L->v[ks]->x to Lk_dense_col
        -:  572:        // with scale applied. Explicit zero(s) are kept if exist
        -:  573:        // . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
        -:  574:        // sgn = sgn( S(1,ks) - 1 )
    1475*:  575:        SPEX_CHECK(SPEX_mpq_cmp_ui(&sgn, SL(ks), 1, 1));
        -:  576:        // first entry is the pivot, so we just update it with sd[ks]
        -:  577:        ASSERT(L->v[ks]->i[0] == Pks);
    1475*:  578:        SPEX_CHECK(SPEX_mpz_set(Lk_dense_col->x[Pks], sd[ks]));
     1475:  579:        Lk_dense_col->i[0] = Pks;
     1475:  580:        h[Pks] = SPEX_FLIP(ks-1);
        -:  581:        // continue copy the remaining entries
     2389:  582:        for (pks = 1; pks < L->v[ks]->nz; pks++) 
        -:  583:        {
      914:  584:            cks = L->v[ks]->i[pks];
        -:  585:            // apply scale to each entry. This must be done to keep these
        -:  586:            // entries in the same scale (with no pending scale) as other
        -:  587:            // entries from U(k:ks-1,Q[ks]), which will have any pending
        -:  588:            // applied as well
      914:  589:            if (sgn != 0) // S(1,ks) != 1
        -:  590:            {
       2*:  591:                SPEX_CHECK(SPEX_mpz_divexact(Lk_dense_col->x[cks],
        -:  592:                                             L->v[ks]->x[pks],
        -:  593:                                             SPEX_MPQ_DEN(SL(ks))));
       2*:  594:                SPEX_CHECK(SPEX_mpz_mul     (Lk_dense_col->x[cks],
        -:  595:                                             Lk_dense_col->x[cks],
        -:  596:                                             SPEX_MPQ_NUM(SL(ks))));
        -:  597:            }
        -:  598:            else
        -:  599:            {
     912*:  600:                SPEX_CHECK(SPEX_mpz_set(Lk_dense_col->x[cks],L->v[ks]->x[pks]));
        -:  601:            }
        -:  602:            // set the column index
      914:  603:            Lk_dense_col->i[pks] = cks;
        -:  604:            // Assuming that zero resulted from exact cancellation is kept in
        -:  605:            // the nnz pattern, then performing backtracking will not introduce
        -:  606:            // new fillin. That is, for any i such that U(i,Q[ks])!=0, the nnz
        -:  607:            // pattern of L(i+1:n, i) is a subset of the nnz pattern of
        -:  608:            // Lk_dense_col(i+1:n). Therefore, the final nnz pattern can be
        -:  609:            // found by L->v[ks]->i and column-wise nnz pattern of U(:,ks).
        -:  610:            // We can just initialize the history vector as:
        -:  611:            //
        -:  612:            // h[cks] = ks-1;
        -:  613:            //
        -:  614:            // However, when explicit zero(s) are always eleminated, the
        -:  615:            // following initialization should be used instead:
        -:  616:            //
        -:  617:            // h[cks] = SPEX_FLIP(ks-1); 
        -:  618:            //
        -:  619:            // With such initialization, entry with h > -1 is clearly not in
        -:  620:            // nnz pattern and any entry in the nnz pattern with h = -1 must be
        -:  621:            // nonzero. In all, any explicit zero with h >= -1 must not be in
        -:  622:            // the nnz pattern.  In this way, we can determine if a zero entry
        -:  623:            // in Lk_dense_col is in the nnz pattern.
      914:  624:            h[cks] = SPEX_FLIP(ks-1);
        -:  625:        }
     1475:  626:        Lk_nz = L->v[ks]->nz; // # of nnz in Lk_dense_col
        -:  627:
        -:  628:        // . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
        -:  629:        // backtrack column ks of L and U for each nnz in U(k:ks-1,Q(ks))
        -:  630:        // . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
     1475:  631:        pks = Uc_ks_nz-1;     // 2nd last entry in the Q[ks]-th col of U
        -:  632:        ASSERT(pks >= 0);
     1475:  633:        i = Uci_ks[pks];      // row index
        -:  634:        ASSERT(i > k);
     2935:  635:        while (i >= k)
        -:  636:        {
        -:  637:            // Uiks = U(i,Q(ks))*S(2,k)*S(3,k)
     2935:  638:            if (i == k)
        -:  639:            {
        -:  640:                // store this pointer for later use
     1460:  641:                Ucp_k_ks = pks;
        -:  642:
        -:  643:                // Uiks = U(k,Q(ks))*S(2,k)
    1460*:  644:                SPEX_CHECK(SPEX_mpz_divexact(Uiks, Uk_dense_row->x[Qks],
        -:  645:                                             SPEX_MPQ_DEN(SU(k))));
     1460:  646:                SPEX_CHECK(SPEX_mpz_mul(Uiks, Uiks, SPEX_MPQ_NUM(SU(k))));
        -:  647:            }
        -:  648:            else
        -:  649:            {
        -:  650:                ASSERT(U->v[i]->i[Ucx_ks[pks]] == Qks);
        -:  651:                // skip if U(i, Q[ks]) turns out to be explicit zero
    1475*:  652:                SPEX_CHECK(SPEX_mpz_sgn(&sgn, U->v[i]->x[Ucx_ks[pks]]));
     1475:  653:                if (sgn == 0)
        -:  654:                {
        -:  655:                    // get next nnz
        2:  656:                    pks --;
        -:  657:                    // the last nonzero must be U(k,Q(ks)), if this is not
        -:  658:                    // in the nonzero pattern found, then it is a new nnz
        -:  659:                    // caused by fillin. Otherwise, cppu won't be used
        -:  660:                    // according to the heuristics in SPEX_LUU
        2:  661:                    if (pks < 0)  {i = k;}
        1:  662:                    else          {i = SPEX_MAX(k, Uci_ks[pks]);}
        2:  663:                    continue;
        -:  664:                }
        -:  665:
        -:  666:                // Uiks = U(i,Q(ks))*S(2,i)
    1473*:  667:                SPEX_CHECK(SPEX_mpz_divexact(Uiks, U->v[i]->x[Ucx_ks[pks]],
        -:  668:                                             SPEX_MPQ_DEN(SU(i))));
     1473:  669:                SPEX_CHECK(SPEX_mpz_mul(Uiks, Uiks, SPEX_MPQ_NUM(SU(i))));
        -:  670:            }
        -:  671:
        -:  672:            // r = sgn( S(1,i) - 1 )
    2921*:  673:            SPEX_CHECK(SPEX_mpq_cmp_ui(&r, SL(i), 1, 1));
        -:  674:
        -:  675:            // the pivot L(P[i],i) is the first entry in the L->v[i], which
        -:  676:            // should be skipped, so we start with pi = 1
     2921:  677:            Pi = P[i];
     8642:  678:            for (pi = 1; pi < L->v[i]->nz; pi++)
        -:  679:            {
        -:  680:                // row index of entry in column i of L
     5736:  681:                ci = L->v[i]->i[pi];
        -:  682:                ASSERT(ci != Pi);// L(P[i],i) has been excluded
        -:  683:
        -:  684:                // Lk_dense_col = (Lk_dense_col*sd(i-1) + L(:,i)*Uiks)/sd(i)
    5736*:  685:                SPEX_CHECK(SPEX_mpz_sgn(&sgn, Lk_dense_col->x[ci]));
     5736:  686:                if (sgn != 0)
        -:  687:                {
        -:  688:                    ASSERT(h[ci] < -1);
     5038:  689:                    if (i > 0)
        -:  690:                    {
        -:  691:                        // Lk_dense_col = Lk_dense_col*sd(i-1)
     4986:  692:                        SPEX_CHECK(SPEX_mpz_mul(Lk_dense_col->x[ci],
        -:  693:                                                Lk_dense_col->x[ci], sd[i-1]));
        -:  694:                    }
     5031:  695:                    int64_t real_hci = SPEX_FLIP(h[ci]);
     5031:  696:                    if (i < real_hci || r != 0 /*S(1,i) != 1*/)
        -:  697:                    {
        -:  698:                        // Lk_dense_col = Lk_dense_col/sd(h[ci])
        -:  699:                        //                + L(ci,i)*Uiks/L(P(i),i)
        -:  700:                        // use L(P(i),i) instead of sd[i] to avoid scaling
        -:  701:                        // for L(:,i)
      422:  702:                        SPEX_CHECK(SPEX_mpz_mul(tmpz, L->v[i]->x[pi], Uiks));
     419*:  703:                        SPEX_CHECK(SPEX_mpz_cdiv_q(tmpz, tmpz,
        -:  704:                                   L->v[i]->x[0]));
     419*:  705:                        SPEX_CHECK(SPEX_mpz_fdiv_q(Lk_dense_col->x[ci],
        -:  706:                                   Lk_dense_col->x[ci], sd[real_hci]));
        -:  707:
      419:  708:                        SPEX_CHECK(SPEX_mpz_add(Lk_dense_col->x[ci],
        -:  709:                                   Lk_dense_col->x[ci], tmpz));
        -:  710:                    }
        -:  711:                    else
        -:  712:                    {
        -:  713:                        // Lk_dense_col = (Lk_dense_col + L(ci,i)*Uiks)/sd(i)
    4609*:  714:                        SPEX_CHECK(SPEX_mpz_addmul(Lk_dense_col->x[ci],
        -:  715:                                                   L->v[i]->x[pi], Uiks));
    4609*:  716:                        SPEX_CHECK(SPEX_mpz_divexact(Lk_dense_col->x[ci],
        -:  717:                                                   Lk_dense_col->x[ci], sd[i]));
        -:  718:                    }
        -:  719:                }
        -:  720:                else
        -:  721:                {
      698:  722:                    if (h[ci] >= -1)
        -:  723:                    {
        -:  724:                        // this is a fill-in
      486:  725:                        Lk_dense_col->i[Lk_nz] = ci;
      486:  726:                        Lk_nz++;
        -:  727:                    }
        -:  728:                    // Lk_dense_col =  L(ci,i)*Uiks/L(P(i),i)
      698:  729:                    SPEX_CHECK(SPEX_mpz_mul(Lk_dense_col->x[ci],
        -:  730:                                            L->v[i]->x[pi], Uiks));
     695*:  731:                    SPEX_CHECK(SPEX_mpz_divexact(Lk_dense_col->x[ci],
        -:  732:                                                 Lk_dense_col->x[ci],
        -:  733:                                                 L->v[i]->x[0]));
        -:  734:                }
        -:  735:
        -:  736:                // update h[ci]
     5721:  737:                h[ci] = SPEX_FLIP(i-1);
        -:  738:            }
        -:  739:
     2906:  740:            if (i > k)
        -:  741:            {
        -:  742:                // move Uiks (scaled U(i,Q(ks)) to Lk_dense_col
    1458*:  743:                SPEX_CHECK(SPEX_mpz_swap(Lk_dense_col->x[Pi], Uiks));
     1458:  744:                Lk_dense_col->i[Lk_nz] = Pi;
     1458:  745:                Lk_nz++;
        -:  746:                // update corresponding entry in the history vector
     1458:  747:                h[Pi] = SPEX_FLIP(i-1);
        -:  748:            }
        -:  749:            else //i == k, which is the last loop
        -:  750:            {
        -:  751:                // Uiks will be the new pivot of column k, so we just place it
        -:  752:                // as the first entry in L->v[k]. However, we postpone updating
        -:  753:                // sd[k], since the original value of sd[k] could be used
    1448*:  754:                SPEX_CHECK(SPEX_mpz_swap(L->v[k]->x[0], Uiks));
     1448:  755:                L->v[k]->i[0] = Pi;
     1448:  756:                break;
        -:  757:            }
        -:  758:
        -:  759:            // get next nnz
     1458:  760:            pks --;
        -:  761:            // the last nonzero must be U(k,Q(ks)), if this is not
        -:  762:            // in the nonzero pattern found, then it is a new nnz
        -:  763:            // caused by fillin. Otherwise, cppu won't be used
        -:  764:            // according to the heuristics
     1458:  765:            if (pks < 0)  {i = k;}
        1:  766:            else          {i = SPEX_MAX(k, Uci_ks[pks]);}
        -:  767:        }
     1448:  768:        Lk_dense_col->nz = Lk_nz;
        -:  769:
        -:  770:        // . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
        -:  771:        // 1. Iterate across all nnz in Lk_dense_col, perform history update if
        -:  772:        //    needed, then move all nonzero entry from Lk_dense_col to
        -:  773:        //    L->v[k]->x
        -:  774:        // NOTE: explicit zero due to exact cancellation in backtracking
        -:  775:        //       is removed.
        -:  776:        // 2. Swap values from L->v[ks]->x and Lk_dense_col
        -:  777:        // . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
        -:  778:        // reallocate the nonzero pattern if needed
     1448:  779:        if (L->v[k]->nzmax < Lk_dense_col->nz+1)
        -:  780:        {
      718:  781:            SPEX_CHECK(SPEX_vector_realloc(L->v[k],
        -:  782:                   SPEX_MIN(n, SPEX_MAX(2*(L->v[k]->nzmax),
        -:  783:                                        Lk_dense_col->nz+1)), option));
        -:  784:        }
     1439:  785:        Lk_nz = 1; // the pivot has been inserted to L->v[k]
     5670:  786:        for (pks = 0; pks < Lk_dense_col->nz; pks++) 
        -:  787:        {
     4232:  788:            cks = Lk_dense_col->i[pks];
     4232:  789:            h[cks] = SPEX_FLIP(h[cks]);
        -:  790:            ASSERT(h[cks] >= -1);
    4232*:  791:            SPEX_CHECK(SPEX_mpz_sgn(&sgn, Lk_dense_col->x[cks]));
     4232:  792:            if (sgn != 0)
        -:  793:            {
        -:  794:                // check if need to perform history update
     2325:  795:                if (h[cks] != k-1)
        -:  796:                {
      887:  797:                    if (k > 0)
        -:  798:                    {
      870:  799:                        SPEX_CHECK(SPEX_mpz_mul(Lk_dense_col->x[cks],
        -:  800:                                   Lk_dense_col->x[cks], sd[k-1]));
        -:  801:                    }
     886*:  802:                    SPEX_CHECK(SPEX_mpz_divexact(Lk_dense_col->x[cks],
        -:  803:                               Lk_dense_col->x[cks], sd[h[cks]]));
        -:  804:                }
     2324:  805:                L->v[k]->i[Lk_nz] = cks;
    2324*:  806:                SPEX_CHECK(SPEX_mpz_swap(L->v[k]->x[Lk_nz],
        -:  807:                                         Lk_dense_col->x[cks]));
    2324*:  808:                SPEX_CHECK(SPEX_mpz_set_ui(Lk_dense_col->x[cks], 0));
     2324:  809:                Lk_nz++;
        -:  810:            }
        -:  811:        }
        -:  812:        // update number of nnz in column k of L
     1438:  813:        L->v[k]->nz = Lk_nz;
        -:  814:        // update sd[k] = L->v[k]->x[0]
    1438*:  815:        SPEX_CHECK(SPEX_mpz_set(sd[k], L->v[k]->x[0]));
        -:  816:    }
        -:  817:    // update S(1,k) and S(2,k) as 1, since all entry in L(:,k) are scaled
    8225*:  818:    SPEX_CHECK(SPEX_mpq_set_ui(SL(k), 1, 1));
        -:  819:
        -:  820:    //-------------------------------------------------------------------------
        -:  821:    // swap values from L->v[ks]->x and Lk_dense_col
        -:  822:    //-------------------------------------------------------------------------
     8225:  823:    pk = 0;
    23900:  824:    for (pks = 0; pks < L->v[ks]->nz; pks++)
        -:  825:    {
    15675:  826:        cks = L->v[ks]->i[pks];
   15675*:  827:        SPEX_CHECK(SPEX_mpz_sgn(&sgn, L->v[ks]->x[pks]));
    15675:  828:        int64_t real_cks = P_inv[cks];
    15675:  829:        if (sgn != 0 && real_cks < *inext && real_cks > ks)
        -:  830:        {
     6416:  831:            *inext = real_cks;
        -:  832:        }
   15675*:  833:        SPEX_CHECK(SPEX_mpz_swap(Lk_dense_col->x[cks], L->v[ks]->x[pks]));
    15675:  834:        Lk_dense_col->i[pk] = cks;
    15675:  835:        pk++;
        -:  836:    }
     8225:  837:    Lk_dense_col->nz = pk;
        -:  838:
        -:  839:    //-------------------------------------------------------------------------
        -:  840:    // remove explicit zeros from Uk_dense_row
        -:  841:    //-------------------------------------------------------------------------
        -:  842:    int64_t Uk_nz;
        -:  843:#ifdef SPEX_DEBUG
        -:  844:    Uk_nz = Uk_dense_row->nz;
        -:  845:    for (pk = 0; pk < Uk_nz;)
        -:  846:    {
        -:  847:        j = Uk_dense_row->i[pk];
        -:  848:        SPEX_CHECK(SPEX_mpz_sgn(&sgn, Uk_dense_row->x[j]));
        -:  849:        ASSERT(sgn != 0);
        -:  850:        // There is no need to remove explicit zeros here, since every time when
        -:  851:        // entries are swapped from U->v[k] to Uk_dense_row, explicit zeros are
        -:  852:        // removed. In addition, cppu is never called after dppu2, while
        -:  853:        // Uk_dense_row is not modified in dppu1, and updated at the end of
        -:  854:        // every call to cppu.
        -:  855:        /*if (sgn == 0)
        -:  856:        {
        -:  857:            // remove explicit zeros
        -:  858:            Uk_nz--;
        -:  859:            Uk_dense_row->i[pk] = Uk_dense_row->i[Uk_nz];
        -:  860:            continue;
        -:  861:        }*/
        -:  862:
        -:  863:        // there should not be any nnz in U(k,Q(k+1:ks-1))
        -:  864:        ASSERT (Q_inv[j] == k || Q_inv[j] >= ks);
        -:  865:        pk++;
        -:  866:    }
        -:  867:    Uk_dense_row->nz = Uk_nz;
        -:  868:#endif
        -:  869:
        -:  870:    //-------------------------------------------------------------------------
        -:  871:    // RwSOP. This could cause fill-ins!
        -:  872:    //-------------------------------------------------------------------------
        -:  873:    int64_t p_Uiks;  // pointer for U(i,Q(ks))
        -:  874:    // pending_scale = U(k, Q(ks))/ U(k, Q(k))
    8225*:  875:    SPEX_CHECK(SPEX_mpq_set_z(pending_scale, Uk_dense_row->x[Qks]));
    8225*:  876:    SPEX_CHECK(SPEX_mpq_set_den(pending_scale, Uk_dense_row->x[Qk]));
    8225*:  877:    SPEX_CHECK(SPEX_mpq_canonicalize(pending_scale));
        -:  878:
        -:  879:    // iterate for all nnz in U(k+1:ks,Q(ks))
    17790:  880:    for (pks = Ucp_k_ks+1; pks <= Uc_ks_nz; pks++)
        -:  881:    {
        -:  882:        // U(ks, Q[ks]) is not in the nnz pattern provided by Uci_ks, Ucx_ks
     9655:  883:        if (pks == Uc_ks_nz)
        -:  884:        {
     8217:  885:            i = ks;
     8217:  886:            p_Uiks = 0;
        -:  887:        }
        -:  888:        else
        -:  889:        {
     1438:  890:            i = Uci_ks[pks];       // row index
     1438:  891:            p_Uiks = Ucx_ks[pks];  // pointer for U(i,Q(ks))
        -:  892:        }
     9655:  893:        int64_t Ui_nz = U->v[i]->nz;
        -:  894:
        -:  895:        // skip scaling for frames between iterations
        -:  896:        // REMARK: U(k,Q(ks)) may not be in the nnz pattern initially
     9655:  897:        int64_t i1 = (pks == 0) ? k+1 : SPEX_MAX(k, Uci_ks[pks-1])+1;
     9815:  898:        for (; i1 < i; i1++)
        -:  899:        {
     160*:  900:            SPEX_CHECK(SPEX_mpq_mul(SL(i1), SL(i1), pending_scale));
     160*:  901:            SPEX_CHECK(SPEX_mpq_mul(SU(i1), SU(i1), pending_scale));
     160*:  902:            SPEX_CHECK(SPEX_mpz_divexact(sd[i1], sd[i1],
        -:  903:                                    SPEX_MPQ_DEN(pending_scale)));
     160*:  904:            SPEX_CHECK(SPEX_mpz_mul(sd[i1], sd[i1],
        -:  905:                                    SPEX_MPQ_NUM(pending_scale)));
        -:  906:        }
        -:  907:
        -:  908:        // simply scale up whole frame i if U(i, Q[ks]) == 0
    9655*:  909:        SPEX_CHECK(SPEX_mpz_sgn(&sgn, U->v[i]->x[p_Uiks]));
     9655:  910:        if (sgn == 0)
        -:  911:        {
        -:  912:            // remove U(i, Q[ks])
        2:  913:            Ui_nz--;
        2:  914:            U->v[i]->i[p_Uiks] = U->v[i]->i[Ui_nz];
       2*:  915:            SPEX_CHECK(SPEX_mpz_swap(U->v[i]->x[p_Uiks], U->v[i]->x[Ui_nz]));
        2:  916:            U->v[i]->nz = Ui_nz;
        -:  917:
        -:  918:            // skip scaling if U(i, Q(ks)) == 0
       2*:  919:            SPEX_CHECK(SPEX_mpq_mul(SL(i), SL(i), pending_scale));
       2*:  920:            SPEX_CHECK(SPEX_mpq_mul(SU(i), SU(i), pending_scale));
       2*:  921:            SPEX_CHECK(SPEX_mpz_divexact(sd[i], sd[i],
        -:  922:                                    SPEX_MPQ_DEN(pending_scale)));
       2*:  923:            SPEX_CHECK(SPEX_mpz_mul(sd[i], sd[i],
        -:  924:                                    SPEX_MPQ_NUM(pending_scale)));
        2:  925:            continue;
        -:  926:        }
        -:  927:
        -:  928:        // This is used to determine the number of additional fillins that will
        -:  929:        // be introduced to row i of U after RwSOP. Initializing with
        -:  930:        // Uk_dense_row->nz-2 is because that U(k,Q[k]) and U(k,Q[ks]) won't be
        -:  931:        // used. This number decreases for every other nonzero entries in
        -:  932:        // U(k,:) used to perform RwSOP update for the corresponding entry in
        -:  933:        // U(i,:). 
     9653:  934:        int64_t num_of_fillin = Uk_dense_row->nz-2;
        -:  935:
        -:  936:        // the updates for all entries in row i of U (except U(i,Q[ks])) share
        -:  937:        // one common feature, that they all need to divide U(k,Q[k]).
        -:  938:        // Therefore, we set
        -:  939:        // S(2, i) = S(2, i)/ U(k,Q(k))
     9653:  940:        SPEX_CHECK(SPEX_mpz_mul(SPEX_MPQ_DEN(SU(i)),
        -:  941:                                SPEX_MPQ_DEN(SU(i)),
        -:  942:                                Uk_dense_row->x[Qk]));
    9642*:  943:        SPEX_CHECK(SPEX_mpq_canonicalize(SU(i)));
        -:  944:
        -:  945:        // store the value for U(i,Q[ks])
        -:  946:        ASSERT(U->v[i]->i[p_Uiks] == Qks);
    9642*:  947:        SPEX_CHECK(SPEX_mpz_set_ui(Uiks, 0));
    9642*:  948:        SPEX_CHECK(SPEX_mpz_swap(Uiks, U->v[i]->x[p_Uiks]));
        -:  949:
        -:  950:        // update row i of U
        -:  951:        // for U(ci,i) with Q_inv(ci) < ks, multiply U(k,Q(ks))
        -:  952:        // for U(ci,i) with Q_inv(ci) > ks but U(k,ci) == 0, multiply U(k,Q(ks))
        -:  953:        // for U(ci,i) with Q_inv(ci) > ks but U(k,ci) != 0, perform 
        -:  954:        //     U(i,ci) = U(i,ci)*U(k,Q(ks)) - U(i,Q(ks))*U(k,ci)
        -:  955:        // then divide all U(ci,i) by the denominator of S(2,i)
        -:  956:        // update U(i,Q[ks]) after iteration, which only needs flipping sign
    28407:  957:        for (pi = 0; pi < Ui_nz; pi++)
        -:  958:        {
    18779:  959:            ci = U->v[i]->i[pi];
    18779:  960:            int64_t real_ci = Q_inv[ci];
    18779:  961:            if (real_ci == ks)
        -:  962:            {
        -:  963:                // handle U(i, Q[ks]) after iteration
     9639:  964:                h[ci] = -2; // or SPEX_MARK(P, ci);
     9639:  965:                continue;
        -:  966:            }
     9140:  967:            else if (real_ci > ks)
        -:  968:            {
        -:  969:                // if U(k,ci) is zero then U(i,ci) needs only scaling
    7705*:  970:                SPEX_CHECK(SPEX_mpz_sgn(&sgn, Uk_dense_row->x[ci]));
        -:  971:            }
        -:  972:            else
        -:  973:            {
     1435:  974:                sgn = 0;
        -:  975:            }
        -:  976:
        -:  977:            // multiply U(k, Q[ks])
     9140:  978:            SPEX_CHECK(SPEX_mpz_mul(U->v[i]->x[pi], U->v[i]->x[pi],
        -:  979:                                    Uk_dense_row->x[Qks]));
     9126:  980:            if (sgn != 0)
        -:  981:            {
        -:  982:                // perform RwSOP to U(i,Q(ks+1:n+1))
        -:  983:                // U(i,ci)= U(i,ci)*U(k,Q(ks)) - U(i,Q(ks))*U(k,ci)
    3051*:  984:                SPEX_CHECK(SPEX_mpz_submul(U->v[i]->x[pi], Uiks,
        -:  985:                                        Uk_dense_row->x[ci]));
     3051:  986:                num_of_fillin --;
     3051:  987:                h[ci] = -2; // or SPEX_MARK(P, ci);
        -:  988:            }
    9126*:  989:            SPEX_CHECK(SPEX_mpz_divexact(U->v[i]->x[pi], U->v[i]->x[pi],
        -:  990:                                    SPEX_MPQ_DEN(SU(i))));
        -:  991:        }
        -:  992:
        -:  993:        // flip sign in advance: Uiks = -Uiks
    9628*:  994:        SPEX_CHECK(SPEX_mpz_neg(Uiks, Uiks));
        -:  995:        // finish RwSOP by checking if there is fillin that should be added
     9628:  996:        if (num_of_fillin > 0)
        -:  997:        {
        -:  998:            // allocate additional space if needed
     3551:  999:            if (U->v[i]->nzmax < Ui_nz+num_of_fillin)
        -: 1000:            {
     2624: 1001:                SPEX_CHECK(SPEX_vector_realloc(U->v[i],
        -: 1002:                       SPEX_MIN(n, SPEX_MAX(2*(U->v[i]->nzmax),
        -: 1003:                                            Ui_nz+num_of_fillin)), option));
        -: 1004:            }
        -: 1005:        }
        -: 1006:        // add FILLIN and restore P
    36397: 1007:        for (pk = 0; pk < Uk_dense_row->nz; pk++)
        -: 1008:        {
    26809: 1009:            ck = Uk_dense_row->i[pk];
    26809: 1010:            if (ck == Qk) { continue; }
    17208: 1011:            else if (h[ck] != -2) // or (!SPEX_MARKED(P, ck))
        -: 1012:            {
     4576: 1013:                U->v[i]->i[Ui_nz] = ck;
        -: 1014:                // U(i,ck)= -U(i,Q(ks))*U(k,ck)
        -: 1015:                //        = Uiks       *U(k,ck)
     4576: 1016:                SPEX_CHECK(SPEX_mpz_mul(U->v[i]->x[Ui_nz],
        -: 1017:                        Uiks      , Uk_dense_row->x[ck]));
        -: 1018:
    4563*: 1019:                SPEX_CHECK(SPEX_mpz_divexact(U->v[i]->x[Ui_nz],
        -: 1020:                    U->v[i]->x[Ui_nz],SPEX_MPQ_DEN(SU(i))));
     4563: 1021:                Ui_nz++;
        -: 1022:            }
        -: 1023:            else
        -: 1024:            {
    12632: 1025:                h[ck] = -1; // or SPEX_MARK(P, ck);
        -: 1026:            }
        -: 1027:        }
        -: 1028:
        -: 1029:        // CPPU shortcuts
     9588: 1030:        if (i != ks)
        -: 1031:        {
        -: 1032:            // Mathematically, we should update U(i, Q(ks)). However, since
        -: 1033:            // column ks of U will become column k after permutation, which
        -: 1034:            // will be deleted when finished, we will instead delete
        -: 1035:            // U(i,Q(ks)).
     1432: 1036:            Ui_nz--;
     1432: 1037:            U->v[i]->i[p_Uiks] = U->v[i]->i[Ui_nz];
    1432*: 1038:            SPEX_CHECK(SPEX_mpz_swap(U->v[i]->x[p_Uiks], U->v[i]->x[Ui_nz]));
        -: 1039:            // skip scaling for L(:,i) by setting S(1,i) = S(1,i)*pending_scale
     1432: 1040:            SPEX_CHECK(SPEX_mpq_mul(SL(i), SL(i), pending_scale));
        -: 1041:            // sd[i] = sd[i]*pending_scale
    1428*: 1042:            SPEX_CHECK(SPEX_mpz_divexact(sd[i], sd[i],
        -: 1043:                                    SPEX_MPQ_DEN(pending_scale)));
    1428*: 1044:            SPEX_CHECK(SPEX_mpz_mul(sd[i], sd[i],
        -: 1045:                                    SPEX_MPQ_NUM(pending_scale)));
        -: 1046:        }
        -: 1047:        else
        -: 1048:        {
        -: 1049:            // Since U(ks,Q[ks]) should not change other than flipping sign, and
        -: 1050:            // we have let S(2,ks) *= 1/U(k,Q[k]), we need to update it so that
        -: 1051:            // it still shares common pending factor S(2,ks) as other entries in
        -: 1052:            // row ks.
        -: 1053:            // U(ks, Q[ks]) = U(ks, Q[ks]) * U(k,Q(k))
     8156: 1054:            SPEX_CHECK(SPEX_mpz_mul(Uiks, Uiks, Uk_dense_row->x[Qk]));
    8135*: 1055:            SPEX_CHECK(SPEX_mpz_divexact(Uiks, Uiks, SPEX_MPQ_DEN(SU(i))));
        -: 1056:
        -: 1057:            // move Uiks into row i of U. noted that sign has been flipped!
    8135*: 1058:            SPEX_CHECK(SPEX_mpz_swap(U->v[i]->x[p_Uiks], Uiks));
    8135*: 1059:            SPEX_CHECK(SPEX_mpq_neg(SL(i), SL(i)));
    8135*: 1060:            SPEX_CHECK(SPEX_mpz_neg(sd[i], sd[i]));
        -: 1061:        }
     9563: 1062:        U->v[i]->nz = Ui_nz;
    9563*: 1063:        SPEX_CHECK(SPEX_mpz_set_ui(SPEX_MPQ_DEN(SU(i)), 1));
        -: 1064:    }
        -: 1065:
        -: 1066:    //-------------------------------------------------------------------------
        -: 1067:    // copy nnz from Uk_dense_row to U(k,:)
        -: 1068:    // and copy U(ks,:) to Uk_dense_row
        -: 1069:    //-------------------------------------------------------------------------
        -: 1070:    // Except the case when swapping with the inserted column (ks == n), cppu
        -: 1071:    // can never be used after dppu2 is called. And we know that dppu1 does not
        -: 1072:    // modify Uk_dense_row, while at the end of every cppu call, Uk_dense_row
        -: 1073:    // is updated with U->v[ks] (which will be U->v[k] after permutation).
        -: 1074:    // Therefore, Uk_dense_row always holds the same entries as they were in
        -: 1075:    // U->v[k], and the following will always hold.
        -: 1076:    ASSERT(Uk_dense_row->nz-1 <= U->v[k]->nzmax);
        -: 1077:    /*if (Uk_dense_row->nz-1 > U->v[k]->nzmax)
        -: 1078:    {
        -: 1079:        SPEX_CHECK(SPEX_vector_realloc(U->v[k], Uk_dense_row->nz-1));
        -: 1080:    }*/
        -: 1081:
        -: 1082:    // place the new pivot U(k,Q[ks]) as the first entry
    8135*: 1083:    SPEX_CHECK(SPEX_mpz_swap(U->v[k]->x[0], Uk_dense_row->x[Qks]));
     8135: 1084:    U->v[k]->i[0] = Qks;
     8135: 1085:    Uk_nz = 1;
    31945: 1086:    for (pk = 0; pk < Uk_dense_row->nz; pk++)
        -: 1087:    {
    23810: 1088:        j = Uk_dense_row->i[pk];
    23810: 1089:        if (j == Qk || j == Qks)
        -: 1090:        {
        -: 1091:            // no need to copy U(k,Q[k]) since column k will be deleted anyway,
        -: 1092:            // while U(k, Q[ks]) has been handled
   16270*: 1093:            SPEX_CHECK(SPEX_mpz_set_ui(Uk_dense_row->x[j], 0));
    16270: 1094:            continue;
        -: 1095:        }
        -: 1096:
    7540*: 1097:        SPEX_CHECK(SPEX_mpz_swap(U->v[k]->x[Uk_nz], Uk_dense_row->x[j]));
        -: 1098:#ifdef SPEX_DEBUG
        -: 1099:        SPEX_CHECK(SPEX_mpz_sgn(&sgn, Uk_dense_row->x[j]));
        -: 1100:        ASSERT(sgn == 0);
        -: 1101:#endif
     7540: 1102:        U->v[k]->i[Uk_nz] = j;
     7540: 1103:        Uk_nz++;
        -: 1104:    }
     8135: 1105:    U->v[k]->nz = Uk_nz;
        -: 1106:
        -: 1107:    // no need to do this when ks>=n-1
     8135: 1108:    if (ks < n-1)
        -: 1109:    {
     7923: 1110:        Uk_nz = 0;
        -: 1111:        // construct a scattered vector for U->v[ks]
    26795: 1112:        for (pks = 0; pks < U->v[ks]->nz; pks++)
        -: 1113:        {
    18872: 1114:            j = U->v[ks]->i[pks];
    18872: 1115:            int64_t real_j = Q_inv[j];
   18872*: 1116:            SPEX_CHECK(SPEX_mpz_sgn(&sgn, U->v[ks]->x[pks]));
    18872: 1117:            if (sgn == 0) {continue;}
        -: 1118:
    17317: 1119:            if (real_j == ks)
        -: 1120:            {
        -: 1121:                // this entry should be considered as the IPGE update of the
        -: 1122:                // entry in the Q[k]-th column
     7923: 1123:                j = Qk;
        -: 1124:            }
     9394: 1125:            else if (real_j < *jnext)
        -: 1126:            {
        -: 1127:                // update the index for the next nnz in current row
     7521: 1128:                *jnext = real_j;
        -: 1129:            }
    17317: 1130:            Uk_dense_row->i[Uk_nz] = j;
   17317*: 1131:            SPEX_CHECK(SPEX_mpz_swap(Uk_dense_row->x[j], U->v[ks]->x[pks]));
    17317: 1132:            Uk_nz++;
        -: 1133:        }
     7923: 1134:        Uk_dense_row->nz = Uk_nz;
        -: 1135:    }
        -: 1136:
        -: 1137:    //-------------------------------------------------------------------------
        -: 1138:    // update column permutation
        -: 1139:    //-------------------------------------------------------------------------
     8135: 1140:    Q[k] = Qks;          Q[ks] = Qk;
     8135: 1141:    Q_inv[Qks] = k;  Q_inv[Qk] = ks;
        -: 1142:
        -: 1143:    //-------------------------------------------------------------------------
        -: 1144:    // flip sign for columns and rows ks+1 to n and update corresponding sd
        -: 1145:    //-------------------------------------------------------------------------
    22011: 1146:    for (i = ks+1; i < n; i++)
        -: 1147:    {
   13876*: 1148:        SPEX_CHECK(SPEX_mpq_neg(SL(i), SL(i)));
   13876*: 1149:        SPEX_CHECK(SPEX_mpq_neg(SU(i), SU(i)));
   13876*: 1150:        SPEX_CHECK(SPEX_mpz_neg(sd[i], sd[i]));
        -: 1151:    }
        -: 1152:
     8135: 1153:    SPEX_FREE_ALL;
     8135: 1154:    return SPEX_OK;
        -: 1155:}
