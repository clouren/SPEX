        -:    0:Source:spex_update_backward_sub.c
        -:    0:Graph:spex_update_backward_sub.gcno
        -:    0:Data:spex_update_backward_sub.gcda
        -:    0:Runs:3
        -:    1://------------------------------------------------------------------------------
        -:    2:// SPEX_Update/spex_update_backward_sub: sparse REF backward substitution
        -:    3:// i.e., compute x = U\b
        -:    4://------------------------------------------------------------------------------
        -:    5:
        -:    6:// SPEX_Update: (c) 2020-2021, Jinhao Chen, Timothy A. Davis, Erick
        -:    7:// Moreno-Centeno, Texas A&M University.  All Rights Reserved.  See
        -:    8:// SPEX_Update/License for the license.
        -:    9:
        -:   10://------------------------------------------------------------------------------
        -:   11:
        -:   12:/* Purpose: This function performs sparse REF backward substitution, solving
        -:   13: * the system Ux = b. x is internally multiplied by the determinant of A to
        -:   14: * maintain integral. In addition, x is also permuted by Q. Therefore the
        -:   15: * real solution should be found as x(i) = x(Q_inv(i))/det(A).
        -:   16: *
        -:   17: * U is a sparse mpz matrix, which is stored by row, and x is a dense mpz
        -:   18: * vector.
        -:   19: *
        -:   20: * The input argument x contains b on input, and it is overwritten on output
        -:   21: * by the solution x.
        -:   22: */
        -:   23:
        -:   24:#define SPEX_FREE_ALL                \
        -:   25:    SPEX_MPZ_CLEAR(tmpz);
        -:   26:
        -:   27:#include "spex_update_internal.h"
        -:   28:
     2811:   29:SPEX_info spex_update_backward_sub// performs sparse REF backward substitution
        -:   30:(
        -:   31:    SPEX_vector *x,         // right hand side vector
        -:   32:    const SPEX_matrix *U,   // input upper triangular matrix
        -:   33:    const SPEX_matrix *rhos,// array of scaled pivots
        -:   34:    const int64_t *P,       // row permutation
        -:   35:    const int64_t *Q_inv    // inverse of column permutation
        -:   36:)
        -:   37:{
        -:   38:    SPEX_info info ;
        -:   39:    int sgn;
     2811:   40:    int64_t i, j, real_i, real_j, p, n = U->n;
     2811:   41:    mpz_t *sd = rhos->x.mpz;
     2811:   42:    mpz_t tmpz; SPEX_MPZ_SET_NULL(tmpz);
    2811*:   43:    SPEX_CHECK(SPEX_mpz_init(tmpz));
        -:   44:
        -:   45:    // Start at x[n-1], since x[n] will remain the same
    16710:   46:    for (i = n-2; i >= 0; i--)
        -:   47:    {
        -:   48:        // tmpz = 0
   13929*:   49:        SPEX_CHECK(SPEX_mpz_set_ui(tmpz, 0));
    13929:   50:        real_i = P[i];
        -:   51:
        -:   52:        // skip the diagonal (pivot entry), which locates at p = 0
    35893:   53:        for (p = 1; p < U->v[i]->nz; p++) // i-th row of U
        -:   54:        {
    21974:   55:            j = U->v[i]->i[p];// the real col index is Q_inv[j]
    21974:   56:            real_j = P[Q_inv[j]];
        -:   57:
        -:   58:            // skip if corresponding entry in x is zero
   21974*:   59:            SPEX_CHECK(SPEX_mpz_sgn(&sgn, x->x[real_j]));
    21974:   60:            if (sgn == 0) {continue;}
        -:   61:
        -:   62:            // tmpz -= U(i,j)*x[j]
    17226:   63:            SPEX_CHECK(SPEX_mpz_submul(tmpz, U->v[i]->x[p],x->x[real_j]));
        -:   64:        }
        -:   65:        // tmpz = tmpz*S(2,i)
   13919*:   66:        SPEX_CHECK(SPEX_mpz_divexact(tmpz, tmpz, SPEX_MPQ_DEN(U->v[i]->scale)));
   13919*:   67:        SPEX_CHECK(SPEX_mpz_mul(tmpz, tmpz, SPEX_MPQ_NUM(U->v[i]->scale)));
        -:   68:
        -:   69:        // x[i] = x[i]*sd[n-1]+tmpz
    13919:   70:        SPEX_CHECK(SPEX_mpz_mul(x->x[real_i], x->x[real_i], sd[n-1]));
   13909*:   71:        SPEX_CHECK(SPEX_mpz_add(x->x[real_i], x->x[real_i], tmpz));
        -:   72:
        -:   73:        // x[i] = x[i]/sd[i]
   13909*:   74:        SPEX_CHECK(SPEX_mpz_divexact(x->x[real_i], x->x[real_i], sd[i]));
        -:   75:    }
        -:   76:
     2781:   77:    SPEX_FREE_ALL;
     2781:   78:    return (SPEX_OK) ;
        -:   79:}
