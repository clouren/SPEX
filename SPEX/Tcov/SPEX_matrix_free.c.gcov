        -:    0:Source:SPEX_matrix_free.c
        -:    0:Graph:SPEX_matrix_free.gcno
        -:    0:Data:SPEX_matrix_free.gcda
        -:    0:Runs:9
        -:    1://------------------------------------------------------------------------------
        -:    2:// SPEX_Util/SPEX_matrix_free: free a SPEX_matrix
        -:    3://------------------------------------------------------------------------------
        -:    4:
        -:    5:// SPEX_Util: (c) 2019-2021, Chris Lourenco (US Naval Academy), Jinhao Chen,
        -:    6:// Erick Moreno-Centeno, Timothy A. Davis, Texas A&M.  All Rights Reserved.
        -:    7:// SPDX-License-Identifier: GPL-2.0-or-later or LGPL-3.0-or-later
        -:    8:
        -:    9://------------------------------------------------------------------------------
        -:   10:
        -:   11:// Free a SPEX_matrix.  Any shallow component is not freed.
        -:   12:#pragma GCC diagnostic ignored "-Wunused-variable"
        -:   13:#include "spex_util_internal.h"
        -:   14:
   425405:   15:SPEX_info SPEX_matrix_free
        -:   16:(
        -:   17:    SPEX_matrix **A_handle, // matrix to free
        -:   18:    const SPEX_options *option
        -:   19:)
        -:   20:{
        -:   21:
        -:   22:    //--------------------------------------------------------------------------
        -:   23:    // check inputs
        -:   24:    //--------------------------------------------------------------------------
        -:   25:
  425405*:   26:    if (!spex_initialized ( )) { return (SPEX_PANIC) ; } ;
        -:   27:
   425405:   28:    if (A_handle == NULL || (*A_handle) == NULL)
        -:   29:    {
        -:   30:        // nothing to free (not an error)
   236415:   31:        return (SPEX_OK) ;
        -:   32:    }
   188990:   33:    SPEX_matrix *A = (*A_handle) ;
        -:   34:
        -:   35:    //--------------------------------------------------------------------------
        -:   36:    // free any non-shallow components
        -:   37:    //--------------------------------------------------------------------------
        -:   38:
   188990:   39:    if (A->kind == SPEX_DYNAMIC_CSC)
        -:   40:    {
    30380:   41:        if (A->v != NULL)
        -:   42:        {
   212028:   43:            for (int64_t i = 0; i < A->n; i++)
        -:   44:            {
   181828:   45:                SPEX_vector_free(&(A->v[i]), option);
        -:   46:            }
    30200:   47:            SPEX_FREE(A->v);
        -:   48:        }
        -:   49:    }
        -:   50:    else
        -:   51:    {
        -:   52:        // free the integer pattern
   158610:   53:        if (!(A->p_shallow)) SPEX_FREE (A->p) ;
   158610:   54:        if (!(A->i_shallow)) SPEX_FREE (A->i) ;
   158610:   55:        if (!(A->j_shallow)) SPEX_FREE (A->j) ;
        -:   56:
        -:   57:        // free the values
   158610:   58:        if (!(A->x_shallow))
        -:   59:        {
   151376:   60:            switch (A->type)
        -:   61:            {
    60009:   62:                case SPEX_MPZ:
    60009:   63:                    if ( A->x.mpz)
   743133:   64:                    for (int64_t i = 0; i < A->nzmax; i++)
        -:   65:                    {
   685356:   66:                        if ( A->x.mpz[i] != NULL)
        -:   67:                        {
   685356:   68:                            SPEX_MPZ_CLEAR( A->x.mpz[i]);
        -:   69:                        }
        -:   70:                    }
    60009:   71:                    SPEX_FREE (A->x.mpz);
    60009:   72:                    break ;
        -:   73:
    27667:   74:                case SPEX_MPQ:
    27667:   75:                    if ( A->x.mpq)
   328661:   76:                    for (int64_t i = 0; i < A->nzmax; i++)
        -:   77:                    {
   303457:   78:                        if ( A->x.mpq[i] != NULL)
        -:   79:                        {
   303457:   80:                            SPEX_MPQ_CLEAR( A->x.mpq[i]);
        -:   81:                        }
        -:   82:                    }
    27667:   83:                    SPEX_FREE (A->x.mpq);
    27667:   84:                    break ;
        -:   85:
    29968:   86:                case SPEX_MPFR:
    29968:   87:                    if ( A->x.mpfr)
   364688:   88:                    for (int64_t i = 0; i < A->nzmax; i++)
        -:   89:                    {
   336265:   90:                        if ( A->x.mpfr[i] != NULL)
        -:   91:                        {
   336265:   92:                            SPEX_MPFR_CLEAR( A->x.mpfr[i]);
        -:   93:                        }
        -:   94:                    }
    29968:   95:                    SPEX_FREE (A->x.mpfr);
    29968:   96:                    break ;
        -:   97:
    17067:   98:                case SPEX_INT64:
    17067:   99:                    SPEX_FREE (A->x.int64) ;
    17067:  100:                    break ;
        -:  101:
    16349:  102:                case SPEX_FP64:
    16349:  103:                    SPEX_FREE (A->x.fp64) ;
    16349:  104:                    break ;
        -:  105:
      316:  106:                default:
        -:  107:                    // do nothing
      316:  108:                    break ;
        -:  109:            }
     7234:  110:        }
        -:  111:    }
        -:  112:
        -:  113:    // A->scale is never shallow
   188990:  114:    SPEX_MPQ_CLEAR (A->scale) ;
        -:  115:
        -:  116:    //--------------------------------------------------------------------------
        -:  117:    // free the header
        -:  118:    //--------------------------------------------------------------------------
        -:  119:
        -:  120:    // the header is never shallow
   188990:  121:    SPEX_FREE (A) ;
   188990:  122:    (*A_handle) = NULL ;
   188990:  123:    return (SPEX_OK) ;
        -:  124:}
        -:  125:
