        -:    0:Source:SPEX_matrix_allocate.c
        -:    0:Graph:SPEX_matrix_allocate.gcno
        -:    0:Data:SPEX_matrix_allocate.gcda
        -:    0:Runs:9
        -:    1://------------------------------------------------------------------------------
        -:    2:// SPEX_Util/SPEX_matrix_allocate: allocate a SPEX_matrix
        -:    3://------------------------------------------------------------------------------
        -:    4:
        -:    5:// SPEX_Util: (c) 2019-2021, Chris Lourenco (US Naval Academy), Jinhao Chen,
        -:    6:// Erick Moreno-Centeno, Timothy A. Davis, Texas A&M.  All Rights Reserved.
        -:    7:// SPDX-License-Identifier: GPL-2.0-or-later or LGPL-3.0-or-later
        -:    8:
        -:    9://------------------------------------------------------------------------------
        -:   10:
        -:   11:// Allocate an m-by-n SPEX_matrix, in either dynamic_CSC x mpz or one of
        -:   12:// 15 data structures:
        -:   13:// (sparse CSC, sparse triplet, or dense) x
        -:   14:// (mpz, mpz, mfpr, int64, or double).
        -:   15:
        -:   16:// If the matrix is not dynamic_CSC, then it may be created as 'shallow', in
        -:   17:// which case A->p, A->i, A->j, and A->x are all returned as NULL, and all
        -:   18:// A->*_shallow flags are returned as true.
        -:   19:
        -:   20:// If the matrix is dynamic_CSC, each column of the returned matrix will be
        -:   21:// allocated as SPEX_vector with zero available entry. Additional reallocation
        -:   22:// for each column will be needed.
        -:   23:
        -:   24:#define SPEX_FREE_ALL \
        -:   25:    SPEX_matrix_free (&A, option) ;
        -:   26:
        -:   27:#include "spex_util_internal.h"
        -:   28:
   190122:   29:SPEX_info SPEX_matrix_allocate
        -:   30:(
        -:   31:    SPEX_matrix **A_handle, // matrix to allocate
        -:   32:    SPEX_kind kind,         // CSC, triplet, dense, dynamic_CSC
        -:   33:    SPEX_type type,         // mpz, mpq, mpfr, int64, or double
        -:   34:    int64_t m,              // # of rows
        -:   35:    int64_t n,              // # of columns
        -:   36:    int64_t nzmax,          // max # of entries for CSC or triplet
        -:   37:                            // (ignored if A is dense)
        -:   38:    bool shallow,           // if true, matrix is shallow.  A->p, A->i, A->j,
        -:   39:                            // A->x are all returned as NULL and must be set
        -:   40:                            // by the caller.  All A->*_shallow are returned
        -:   41:                            // as true. Ignored if kind is dynamic_CSC.
        -:   42:    bool init,              // If true, and the data types are mpz, mpq, or
        -:   43:                            // mpfr, the entries are initialized (using the
        -:   44:                            // appropriate SPEX_mp*_init function). If false,
        -:   45:                            // the mpz, mpq, and mpfr arrays are malloced but
        -:   46:                            // not initialized. Utilized internally to reduce
        -:   47:                            // memory.  Ignored if shallow is true.
        -:   48:    const SPEX_options *option
        -:   49:)
        -:   50:{
        -:   51:
        -:   52:    //--------------------------------------------------------------------------
        -:   53:    // check inputs
        -:   54:    //--------------------------------------------------------------------------
        -:   55:
        -:   56:    SPEX_info info ;
  190122*:   57:    if (!spex_initialized ( )) return (SPEX_PANIC) ;
        -:   58:
   190122:   59:    if (A_handle == NULL)
        -:   60:    {
       35:   61:        return (SPEX_INCORRECT_INPUT) ;
        -:   62:    }
   190087:   63:    (*A_handle) = NULL ;
   190087:   64:    if (m < 0 || n < 0 ||
   190052:   65:        kind  < SPEX_CSC || kind  > SPEX_DYNAMIC_CSC ||
   190052:   66:        type  < SPEX_MPZ || type  > SPEX_FP64 ||
    30760:   67:        (kind == SPEX_DYNAMIC_CSC && type != SPEX_MPZ)) //dynamic must be mpz
        -:   68:    {
       35:   69:        return (SPEX_INCORRECT_INPUT) ;
        -:   70:    }
        -:   71:
        -:   72:    //--------------------------------------------------------------------------
        -:   73:    // allocate the header
        -:   74:    //--------------------------------------------------------------------------
        -:   75:
   190052:   76:    SPEX_matrix *A = (SPEX_matrix *) SPEX_calloc (1, sizeof (SPEX_matrix)) ;
   190052:   77:    if (A == NULL)
        -:   78:    {
     1062:   79:        return (SPEX_OUT_OF_MEMORY) ;
        -:   80:    }
        -:   81:
   188990:   82:    if (kind == SPEX_DENSE)
        -:   83:    {
    85991:   84:        nzmax = m*n ;
        -:   85:    }
   188990:   86:    nzmax = SPEX_MAX (nzmax, 1) ;
        -:   87:
   188990:   88:    A->m = m ;
   188990:   89:    A->n = n ;
   188990:   90:    A->nzmax = nzmax ;
   188990:   91:    A->nz = 0 ;             // for triplet matrices only (no triplets yet)
   188990:   92:    A->kind = kind ;
   188990:   93:    A->type = type ;
        -:   94:
        -:   95:    // A->p, A->i, A->j, and A->x are currently NULL since A was calloc'd.
   188990:   96:    A->p_shallow = false ;
   188990:   97:    A->i_shallow = false ;
   188990:   98:    A->j_shallow = false ;
   188990:   99:    A->x_shallow = false ;
        -:  100:
        -:  101:    // A->scale = 1
   188990:  102:    SPEX_MPQ_SET_NULL (A->scale) ;
   188990:  103:    SPEX_CHECK (SPEX_mpq_init (A->scale)) ;
  187621*:  104:    SPEX_CHECK (SPEX_mpq_set_ui (A->scale, 1, 1)) ;
        -:  105:
        -:  106:    //--------------------------------------------------------------------------
        -:  107:    // allocate the p, i, j, and x components
        -:  108:    //--------------------------------------------------------------------------
        -:  109:
   187621:  110:    if (kind == SPEX_DYNAMIC_CSC)
        -:  111:    {
        -:  112:        // make sure each A->v[] is initialized as NULL
    30260:  113:        A->v = (SPEX_vector**) SPEX_calloc(n, sizeof(SPEX_vector*)); 
    30260:  114:        if (!(A->v)) 
        -:  115:        { 
       60:  116:            SPEX_FREE_ALL ;
       60:  117:            return SPEX_OUT_OF_MEMORY; 
        -:  118:        } 
        -:  119:         
   208248:  120:        for (int64_t i = 0; i < n; i++) 
        -:  121:        {
   179128:  122:            SPEX_CHECK(SPEX_vector_allocate(&(A->v[i]), 0, option)); 
        -:  123:        } 
        -:  124:    }
   157361:  125:    else if(shallow)
        -:  126:    {
        -:  127:
        -:  128:        // all components are shallow.  The caller can modify individual
        -:  129:        // components after A is created, as needed.
     7234:  130:        A->p_shallow = true ;
     7234:  131:        A->i_shallow = true ;
     7234:  132:        A->j_shallow = true ;
     7234:  133:        A->x_shallow = true ;
        -:  134:
        -:  135:    }
        -:  136:    else
        -:  137:    {
        -:  138:
   150127:  139:        bool ok = true ;
        -:  140:
        -:  141:        // allocate the integer pattern
   150127:  142:        switch (kind)
        -:  143:        {
    49941:  144:            case SPEX_CSC:
    49941:  145:                A->p = (int64_t *) SPEX_calloc (n+1, sizeof (int64_t)) ;
    49941:  146:                A->i = (int64_t *) SPEX_calloc (nzmax, sizeof (int64_t)) ;
    49941:  147:                ok = (A->p != NULL && A->i != NULL) ;
    49941:  148:                break ;
        -:  149:
    21648:  150:            case SPEX_TRIPLET:
    21648:  151:                A->i = (int64_t *) SPEX_calloc (nzmax, sizeof (int64_t)) ;
    21648:  152:                A->j = (int64_t *) SPEX_calloc (nzmax, sizeof (int64_t)) ;
    21648:  153:                ok = (A->i != NULL && A->j != NULL) ;
    21648:  154:                break ;
        -:  155:
   150127:  156:            default: //SPEX_DENSE or SPEX_DYNAMIC_CSC
        -:  157:                ;// nothing to do
        -:  158:
        -:  159:        }
        -:  160:
        -:  161:        // allocate the values
   150127:  162:        switch (type)
        -:  163:        {
    59602:  164:            case SPEX_MPZ:
        -:  165:                // If init == true, we create and initialize each entry
        -:  166:                // in the integer array. If init == false, then we only
        -:  167:                // allocate the array but do not allocate the individual
        -:  168:                // mpz, mpq, or mpfr
    59602:  169:                if (init)
    52574:  170:                    A->x.mpz = spex_create_mpz_array (nzmax) ;
        -:  171:                else
     7028:  172:                    A->x.mpz = SPEX_calloc(nzmax, sizeof(mpz_t));
    59602:  173:                ok = ok && (A->x.mpz != NULL) ;
    59602:  174:                break ;
        -:  175:
    27455:  176:            case SPEX_MPQ:
    27455:  177:                if (init)
    27423:  178:                    A->x.mpq = spex_create_mpq_array (nzmax) ;
        -:  179:                else
       32:  180:                    A->x.mpq = SPEX_calloc(nzmax, sizeof(mpq_t));
    27455:  181:                ok = ok && (A->x.mpq != NULL) ;
    27455:  182:                break ;
        -:  183:
    29746:  184:            case SPEX_MPFR:
    29746:  185:                if (init)
    29718:  186:                    A->x.mpfr = spex_create_mpfr_array (nzmax, option) ;
        -:  187:                else
       28:  188:                    A->x.mpfr = SPEX_calloc(nzmax, sizeof(mpfr_t));
    29746:  189:                ok = ok && (A->x.mpfr != NULL) ;
    29746:  190:                break ;
        -:  191:
    17145:  192:            case SPEX_INT64:
    17145:  193:                A->x.int64 = (int64_t *) SPEX_calloc (nzmax, sizeof (int64_t)) ;
    17145:  194:                ok = ok && (A->x.int64 != NULL) ;
    17145:  195:                break ;
        -:  196:
    16179:  197:            case SPEX_FP64:
    16179:  198:                A->x.fp64 = (double *) SPEX_calloc (nzmax, sizeof (double)) ;
    16179:  199:                ok = ok && (A->x.fp64 != NULL) ;
    16179:  200:                break ;
        -:  201:
        -:  202:        }
        -:  203:
   150127:  204:        if (!ok)
        -:  205:        {
     5717:  206:            SPEX_FREE_ALL ;
     5717:  207:            return (SPEX_OUT_OF_MEMORY) ;
        -:  208:        }
        -:  209:    }
        -:  210:
        -:  211:    //--------------------------------------------------------------------------
        -:  212:    // return result
        -:  213:    //--------------------------------------------------------------------------
        -:  214:
   180764:  215:    (*A_handle) = A ;
   180764:  216:    return (SPEX_OK) ;
        -:  217:}
        -:  218:
