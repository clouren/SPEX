        -:    0:Source:spex_left_lu_get_smallest_pivot.c
        -:    0:Graph:spex_left_lu_get_smallest_pivot.gcno
        -:    0:Data:spex_left_lu_get_smallest_pivot.gcda
        -:    0:Runs:6
        -:    1://------------------------------------------------------------------------------
        -:    2:// SPEX_Left_LU/spex_left_lu_get_smallest_pivot: find the smallest entry in a column
        -:    3://------------------------------------------------------------------------------
        -:    4:
        -:    5:// SPEX_Left_LU: (c) 2019-2021, Chris Lourenco (US Naval Academy), Jinhao Chen,
        -:    6:// Erick Moreno-Centeno, Timothy A. Davis, Texas A&M.  All Rights Reserved.
        -:    7:// SPDX-License-Identifier: GPL-2.0-or-later or LGPL-3.0-or-later
        -:    8:
        -:    9://------------------------------------------------------------------------------
        -:   10:
        -:   11:/* Purpose: This function selects the pivot element as the smallest in the
        -:   12: * column.  This is activated if the user sets option->pivot =
        -:   13: * SPEX_TOL_SMALLEST or SPEX_SMALLEST.
        -:   14: *
        -:   15: * On output, the index of kth pivot is returned.
        -:   16: */
        -:   17:
        -:   18:#define SPEX_FREE_ALL        \
        -:   19:    SPEX_MPZ_CLEAR(small);
        -:   20:
        -:   21:#include "spex_left_lu_internal.h"
        -:   22:
     2365:   23:SPEX_info spex_left_lu_get_smallest_pivot
        -:   24:(
        -:   25:    int64_t *pivot,         // the index of smallest pivot
        -:   26:    SPEX_matrix* x,         // kth column of L and U
        -:   27:    int64_t* pivs,          // vector indicating if each row has been pivotal
        -:   28:    int64_t n,              // dimension of problem
        -:   29:    int64_t top,            // nonzeros are stored in xi[top..n-1]
        -:   30:    int64_t* xi             // nonzero pattern of x
        -:   31:)
        -:   32:{
        -:   33:
        -:   34:    //--------------------------------------------------------------------------
        -:   35:    // check inputs
        -:   36:    //--------------------------------------------------------------------------
        -:   37:
    2365*:   38:    SPEX_REQUIRE(x, SPEX_DENSE, SPEX_MPZ);
        -:   39:    SPEX_info info ;
    2365*:   40:    if (!pivs || !xi || !pivot) {return SPEX_INCORRECT_INPUT;}
        -:   41:
        -:   42:    //--------------------------------------------------------------------------
        -:   43:    // allocate workspace
        -:   44:    //--------------------------------------------------------------------------
        -:   45:
        -:   46:    int64_t i, inew, j, flag ;
        -:   47:    int sgn, r;
        -:   48:    // Flag is non-negative until we have an initial starting value for small
     2365:   49:    (*pivot) = -1;
     2365:   50:    j = n;
     2365:   51:    flag = top;
     2365:   52:    mpz_t small; SPEX_MPZ_SET_NULL(small);
    2365*:   53:    SPEX_CHECK(SPEX_mpz_init(small));
        -:   54:
        -:   55:    //--------------------------------------------------------------------------
        -:   56:    // Find an initial pivot. Fails if all terms are 0 in array x
        -:   57:    //--------------------------------------------------------------------------
        -:   58:
    12493:   59:    while (flag > -1 && flag < n)
        -:   60:    {
        -:   61:        // i location of first nonzero
    10152:   62:        inew = xi[flag];
        -:   63:
        -:   64:        //check if inew can be pivotal
   10152*:   65:        SPEX_CHECK(SPEX_mpz_sgn(&sgn, x->x.mpz[inew]));
    10152:   66:        if (pivs[inew] < 0 && sgn != 0)
        -:   67:        {
        -:   68:            // Current smallest pivot
     1960:   69:            SPEX_CHECK(SPEX_mpz_set(small, x->x.mpz[inew]));
        -:   70:            // Current smallest pivot location
     1955:   71:            *pivot = inew;
        -:   72:            // Where to start the search for rest of nonzeros
     1955:   73:            j = flag;
        -:   74:            // Exit the while loop
     1955:   75:            flag = -5;
        -:   76:        }
        -:   77:        // Increment to next nonzero to search
    10147:   78:        flag += 1;
        -:   79:    }
        -:   80:
        -:   81:    //--------------------------------------------------------------------------
        -:   82:    // Iterate across remaining nonzeros
        -:   83:    //--------------------------------------------------------------------------
        -:   84:
    11068:   85:    for (i = j; i < n; i++)
        -:   86:    {
     8727:   87:        inew = xi[i];
        -:   88:        // check if inew can be pivotal
    8727*:   89:        SPEX_CHECK(SPEX_mpz_cmpabs(&r, small, x->x.mpz[inew]));
     8727:   90:        if (pivs[inew] < 0 && r > 0)
        -:   91:        {
    2550*:   92:            SPEX_CHECK(SPEX_mpz_sgn(&sgn, x->x.mpz[inew]));
     2550:   93:            if (sgn != 0)
        -:   94:            {
        -:   95:                // Current best pivot location
     1168:   96:                *pivot = inew;
        -:   97:                // Current best pivot value
    1168*:   98:                SPEX_CHECK(SPEX_mpz_set(small, x->x.mpz[inew]));
        -:   99:            }
        -:  100:        }
        -:  101:    }
        -:  102:
        -:  103:    //--------------------------------------------------------------------------
        -:  104:    // free workspace and return result
        -:  105:    //--------------------------------------------------------------------------
        -:  106:
     2341:  107:    SPEX_FREE_ALL;
     2341:  108:    if (*pivot == -1)
        -:  109:    {
      386:  110:        return SPEX_SINGULAR;
        -:  111:    }
        -:  112:    else
        -:  113:    {
     1955:  114:        return SPEX_OK;
        -:  115:    }
        -:  116:}
        -:  117:
