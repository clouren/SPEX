        -:    0:Source:SPEX_transpose.c
        -:    0:Graph:SPEX_transpose.gcno
        -:    0:Data:SPEX_transpose.gcda
        -:    0:Runs:9
        -:    1://------------------------------------------------------------------------------
        -:    2:// SPEX_Util/SPEX_transpose: Transpose a matrix
        -:    3://------------------------------------------------------------------------------
        -:    4:
        -:    5:// SPEX_Util: (c) 2019-2021, Chris Lourenco (US Naval Academy), Jinhao Chen,
        -:    6:// Erick Moreno-Centeno, Timothy A. Davis, Texas A&M.  All Rights Reserved.
        -:    7:// SPDX-License-Identifier: GPL-2.0-or-later or LGPL-3.0-or-later
        -:    8:
        -:    9://------------------------------------------------------------------------------
        -:   10:
        -:   11:#define SPEX_FREE_WORK       \
        -:   12:    SPEX_FREE(w);
        -:   13:
        -:   14:#define SPEX_FREE_ALL        \
        -:   15:    SPEX_FREE_WORK;          \
        -:   16:    SPEX_matrix_free(&C, option);
        -:   17:
        -:   18:#include "spex_util_internal.h"
        -:   19:
        -:   20:/* Purpose: This function sets C = A'
        -:   21: * C_handle is NULL on input. On output, C_handle contains a pointer to A'
        -:   22: */
      174:   23:SPEX_info SPEX_transpose
        -:   24:(
        -:   25:    SPEX_matrix **C_handle,     // C = A'
        -:   26:    SPEX_matrix *A,             // Matrix to be transposed
        -:   27:    const SPEX_options *option
        -:   28:)
        -:   29:{
        -:   30:    SPEX_info info;
     174*:   31:    if (!spex_initialized ( )) return (SPEX_PANIC) ;
        -:   32:    // Check input
     174*:   33:    SPEX_REQUIRE_KIND (A, SPEX_CSC);
     174*:   34:    if (!C_handle)       { return SPEX_INCORRECT_INPUT;}
        -:   35:
        -:   36:    // Declare workspace and C
      174:   37:    int64_t* w = NULL;
      174:   38:    SPEX_matrix* C = NULL;
        -:   39:    int64_t nz;                            // Number of nonzeros in A
        -:   40:    int64_t p, q, j, n, m;
      174:   41:    info = SPEX_matrix_nnz(&nz, A, option);
     174*:   42:    if (info != SPEX_OK) {return info;}
      174:   43:    m = A->m ; n = A->n ;
        -:   44:    ASSERT( m >= 0);
        -:   45:    ASSERT( n >= 0);
        -:   46:
        -:   47:    // C is also CSC and its type is the same as A
      174:   48:    SPEX_CHECK(SPEX_matrix_allocate(&C, SPEX_CSC, A->type, n, m, nz,
        -:   49:        false, true, option));
        -:   50:
        -:   51:    // Declare workspace
      120:   52:    w = (int64_t*) SPEX_calloc(m, sizeof(int64_t));
      120:   53:    if (!w)
        -:   54:    {
        3:   55:        SPEX_FREE_ALL;
        3:   56:        return SPEX_OUT_OF_MEMORY;
        -:   57:    }
        -:   58:    // Compute row counts
    17738:   59:    for (p = 0 ; p < nz ; p++)
        -:   60:    {
    17621:   61:        w [A->i [p]]++ ;
        -:   62:    }
        -:   63:
        -:   64:    // Compute row pointers
      117:   65:    SPEX_cumsum (C->p, w, m) ;
        -:   66:    // Populate C
     1101:   67:    for (j = 0 ; j < n ; j++)
        -:   68:    {
    18605:   69:        for (p = A->p [j] ; p < A->p [j+1] ; p++)
        -:   70:        {
    17621:   71:            q = w [A->i [p]]++;
    17621:   72:            C->i [q] = j ;                 // place A(i,j) as entry C(j,i)
        -:   73:
        -:   74:            // assign C->x[q] = A->x[p]
    17621:   75:            if (A->type == SPEX_MPZ)
        -:   76:            {
    4361*:   77:                SPEX_CHECK(SPEX_mpz_set(C->x.mpz[q], A->x.mpz[p]));
        -:   78:            }
    13260:   79:            else if (A->type == SPEX_MPQ)
        -:   80:            {
    3315*:   81:                SPEX_CHECK(SPEX_mpq_set(C->x.mpq[q], A->x.mpq[p]));
        -:   82:            }
     9945:   83:            else if (A->type == SPEX_MPFR)
        -:   84:            {
    3315*:   85:                SPEX_CHECK(SPEX_mpfr_set(C->x.mpfr[q], A->x.mpfr[p],
        -:   86:                    SPEX_OPTION_ROUND(option)));
        -:   87:            }
     6630:   88:            else if (A->type == SPEX_INT64)
        -:   89:            {
     3315:   90:                C->x.int64[q] = A->x.int64[p];
        -:   91:            }
        -:   92:            else
        -:   93:            {
     3315:   94:                C->x.fp64[q] = A->x.fp64[p];
        -:   95:            }
        -:   96:        }
        -:   97:    }
     117*:   98:    SPEX_CHECK(SPEX_mpq_set(C->scale, A->scale));
        -:   99:
      117:  100:    (*C_handle) = C;
      117:  101:    SPEX_FREE_WORK;
      117:  102:    return SPEX_OK;
        -:  103:}
