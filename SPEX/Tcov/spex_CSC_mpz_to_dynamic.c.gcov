        -:    0:Source:spex_CSC_mpz_to_dynamic.c
        -:    0:Graph:spex_CSC_mpz_to_dynamic.gcno
        -:    0:Data:spex_CSC_mpz_to_dynamic.gcda
        -:    0:Runs:9
        -:    1://------------------------------------------------------------------------------
        -:    2:// SPEX_Util/spex_CSC_mpz_to_dynamic.c: convert a SPEX_matrix of CSC x MPZ to
        -:    3:// a dynamic_CSC matrix.
        -:    4://------------------------------------------------------------------------------
        -:    5:
        -:    6:// SPEX_Util: (c) 2020-2021, Jinhao Chen, Chris Lourenco (US Naval Academy),
        -:    7:// Erick Moreno-Centeno, Timothy A. Davis, Texas A&M.  All Rights Reserved.
        -:    8:// SPDX-License-Identifier: GPL-2.0-or-later or LGPL-3.0-or-later
        -:    9:
        -:   10://------------------------------------------------------------------------------
        -:   11:
        -:   12:// spex_CSC_mpz_to_dynamic create a SPEX_matrix A of dynamic_CSC from the given SPEX_matrix B which is
        -:   13:// in Compressed Sparse Column (CSC) format with entries in mpz_t type.
        -:   14:
        -:   15:#define SPEX_FREE_ALL                \
        -:   16:    SPEX_matrix_free(&A, option);
        -:   17:
        -:   18:#include "spex_util_internal.h"
        -:   19:
      285:   20:SPEX_info spex_CSC_mpz_to_dynamic
        -:   21:(
        -:   22:    SPEX_matrix **A_handle,      // converted SPEX_matrix of dynamic_CSC
        -:   23:    const SPEX_matrix *B,         // original matrix
        -:   24:    const SPEX_options *option
        -:   25:)
        -:   26:{
     285*:   27:    SPEX_REQUIRE (B, SPEX_CSC, SPEX_MPZ) ;
     285*:   28:    if (A_handle == NULL)   {return SPEX_INCORRECT_INPUT;}
        -:   29:
        -:   30:    SPEX_info info;
      285:   31:    (*A_handle) = NULL;
      285:   32:    SPEX_matrix *A = NULL;
      285:   33:    int64_t *Bp = B->p;
        -:   34:
      285:   35:    int64_t i, j, p, Ap = 0;
        -:   36:
        -:   37:    // allocate space for A
     285*:   38:    SPEX_CHECK(SPEX_matrix_allocate(&A, SPEX_DYNAMIC_CSC, SPEX_MPZ, B->m, B->n,
        -:   39:        0, false, true, option));
        -:   40:
     2700:   41:    for (j = 0; j < B->n; j++)
        -:   42:    {
        -:   43:        // reallocate space for each column of A
    2415*:   44:        SPEX_CHECK(SPEX_vector_realloc(A->v[j], Bp[j+1]-Bp[j], option));
     2415:   45:        Ap = 0;
    50210:   46:        for (p = Bp[j]; p < Bp[j+1]; p++)
        -:   47:        {
    47795:   48:            i = B->i[p];
    47795:   49:            A->v[j]->i[Ap] = i;
        -:   50:            // A->v[j]->x[Ap] = B->x[p]
   47795*:   51:            SPEX_CHECK(SPEX_mpz_set(A->v[j]->x[Ap], SPEX_1D(B, p, mpz)));
    47795:   52:            Ap++;
        -:   53:        }
     2415:   54:        A->v[j]->nz = Ap;
        -:   55:    }
     285*:   56:    SPEX_CHECK(SPEX_mpq_set(A->scale, B->scale));
        -:   57:
      285:   58:    (*A_handle) = A;
      285:   59:    return SPEX_OK;
        -:   60:}
