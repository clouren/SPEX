        -:    0:Source:spex_update_triangular_solve.c
        -:    0:Graph:spex_update_triangular_solve.gcno
        -:    0:Data:spex_update_triangular_solve.gcda
        -:    0:Runs:3
        -:    1://------------------------------------------------------------------------------
        -:    2:// SPEX_Update/spex_update_triangular_solve.c: perform REF triangular solve up
        -:    3:// to specified iteration, additional history update for certain entries should
        -:    4:// be done after calling this function.
        -:    5://------------------------------------------------------------------------------
        -:    6:
        -:    7:// SPEX_Update: (c) 2020-2021, Jinhao Chen, Timothy A. Davis, Erick
        -:    8:// Moreno-Centeno, Texas A&M University.  All Rights Reserved.  See
        -:    9:// SPEX_Update/License for the license.
        -:   10:
        -:   11://------------------------------------------------------------------------------
        -:   12:
        -:   13:// Purpose: This function is to perform REF triangular solve for LDx=v up to
        -:   14:// specified IPGE iteration when both L and v are sparse. Additional history
        -:   15:// update should be done for certain entries based on the history vector. This
        -:   16:// function is used internally when computing the inserted column for U. For
        -:   17:// forward solving LDUx=b where b is mostly considered and stored as dense
        -:   18:// vector, we will use spex_forward_sub.
        -:   19:
        -:   20:#include "spex_update_internal.h"
        -:   21:
    24931:   22:SPEX_info spex_update_triangular_solve // perform REF triangular solve for LDx=v
        -:   23:(
        -:   24:    spex_scattered_vector *sv_x,// the scattered version of solution for LDx=v,
        -:   25:                        // using the first k-1 columns of L
        -:   26:    int64_t *x_top,     // P_inv[sv_x->i[0...(*x_top)]] <= (*last_update), that
        -:   27:                        // is, sv_x->i[0...(*x_top)] give the indices of all
        -:   28:                        // entries that are up-to-date. However, this is updated
        -:   29:                        // only when i_2ndlast is requested.
        -:   30:    int64_t *h,         // history vector for x
        -:   31:    int64_t *last_update,// the number of finished IPGE iterations, which is
        -:   32:                        // also the number of columns in L used last time
        -:   33:    int64_t *i_2ndlast, // i_2ndlast is the index of the found last nnz entry
        -:   34:                        // of x[P] in the range of (last_update, n-2], this
        -:   35:                        // could be NULL if not needed
        -:   36:    const int64_t k,    // compute x up to k-th IPGE iteration, that is, using
        -:   37:                        // the first k-1 columns of L
        -:   38:    const SPEX_matrix *L,  // matrix L
        -:   39:    const SPEX_matrix *U,  // matrix U
        -:   40:    const SPEX_matrix *rhos,// array of scaled pivots
        -:   41:    const int64_t *P,   // row permutation
        -:   42:    const int64_t *P_inv// inverse of row permutation
        -:   43:)
        -:   44:{
        -:   45:    SPEX_info info;
        -:   46:    int sgn;
        -:   47:    int64_t j;
    24931:   48:    int64_t n = sv_x->nzmax;
        -:   49:
        -:   50:    // there is no nnz in vk(P[last_update,n-2])
    24931:   51:    if (i_2ndlast != NULL && *i_2ndlast == -1)
        -:   52:    {
      146:   53:        return SPEX_OK;    
        -:   54:    }
        -:   55:
    24785:   56:    if (*last_update < k-1)
        -:   57:    {
        -:   58:        // iterate across each entry
    69813:   59:        for (j = *last_update+1; j < k; j++)
        -:   60:        {
        -:   61:            // skip if x(P[j]) == 0
   46017*:   62:            SPEX_CHECK(SPEX_mpz_sgn(&sgn, sv_x->x[P[j]]));
    46017:   63:            if (sgn == 0)       {continue; }
        -:   64:
        -:   65:            // perform j-th IPGE update for x
    24779:   66:            SPEX_CHECK(spex_update_ipge(sv_x, h, i_2ndlast, L->v[j], P,
        -:   67:                P_inv, rhos, j));
        -:   68:        }
    23796:   69:        *last_update = k-1;
        -:   70:
        -:   71:        // double check if i_2ndlast gives the correct index for 2nd last nnz
    23796:   72:        if(i_2ndlast != NULL && *i_2ndlast != -1)
        -:   73:        {
   19444*:   74:            SPEX_CHECK(SPEX_mpz_sgn(&sgn, sv_x->x[*i_2ndlast]));
    19444:   75:            if (sgn == 0 || *i_2ndlast < k) // needs to update i_2ndlast
        -:   76:            {
        -:   77:                int64_t p, real_j;
     2345:   78:                *i_2ndlast = -1;
    12504:   79:                for (p = *x_top; p < sv_x->nz;)
        -:   80:                {
    10159:   81:                    j = sv_x->i[p];
    10159:   82:                    real_j = P_inv[j];
        -:   83:
        -:   84:                    // skip entries above k-th row
    10159:   85:                    if (real_j <= *last_update)
        -:   86:                    {
        -:   87:                        // move these entries before x_top
     3850:   88:                        sv_x->i[p] = sv_x->i[*x_top];
     3850:   89:                        sv_x->i[*x_top] = j;
     3850:   90:                        (*x_top)++;
     3850:   91:                        p++;
     3850:   92:                        continue;
        -:   93:                    }
        -:   94:
    6309*:   95:                    SPEX_CHECK(SPEX_mpz_sgn(&sgn, sv_x->x[j]));
     6309:   96:                    if (sgn == 0)
        -:   97:                    {
        -:   98:                        // remove it from nnz pattern
     2312:   99:                        h[j] = -1;
     2312:  100:                        sv_x->nz--;
     2312:  101:                        sv_x->i[p] = sv_x->i[sv_x->nz];
        -:  102:                    }
        -:  103:                    else
        -:  104:                    {
     3997:  105:                        if (real_j > *i_2ndlast && real_j != n-1)
        -:  106:                        {
     2957:  107:                            *i_2ndlast = real_j;
        -:  108:                        }
     3997:  109:                        p++;
        -:  110:                    }
        -:  111:                }
        -:  112:            }
        -:  113:        }
        -:  114:    }
        -:  115:
    24221:  116:    return SPEX_OK;
        -:  117:}
