        -:    0:Source:SPEX_Left_LU_factorize.c
        -:    0:Graph:SPEX_Left_LU_factorize.gcno
        -:    0:Data:SPEX_Left_LU_factorize.gcda
        -:    0:Runs:6
        -:    1://------------------------------------------------------------------------------
        -:    2:// SPEX_Left_LU/SPEX_Left_LU_factorize: exact sparse LU factorization
        -:    3://------------------------------------------------------------------------------
        -:    4:
        -:    5:// SPEX_Left_LU: (c) 2019-2021, Chris Lourenco (US Naval Academy), Jinhao Chen,
        -:    6:// Erick Moreno-Centeno, Timothy A. Davis, Texas A&M.  All Rights Reserved.
        -:    7:// SPDX-License-Identifier: GPL-2.0-or-later or LGPL-3.0-or-later
        -:    8:
        -:    9://------------------------------------------------------------------------------
        -:   10:
        -:   11:/* Purpose: This function performs the SPEX Left LU factorization. This 
        -:   12: * factorization is done via n iterations of the sparse REF triangular solve 
        -:   13: * function. The overall factorization is PAQ = LDU
        -:   14: * The determinant of A can be obtained as determinant = rhos[n-1]
        -:   15: *
        -:   16: *  L: undefined on input, created on output
        -:   17: *  U: undefined on input, created on output
        -:   18: *  rhos: undefined on input, created on output
        -:   19: *  pinv: undefined on input, created on output
        -:   20: *
        -:   21: *  A: input only, not modified
        -:   22: *  S: input only, not modified
        -:   23: *  option: input only, not modified
        -:   24: */
        -:   25:
        -:   26:#define SPEX_FREE_WORK              \
        -:   27:    SPEX_matrix_free(&x, NULL);     \
        -:   28:    SPEX_FREE(xi);                  \
        -:   29:    SPEX_FREE(h);                   \
        -:   30:    SPEX_FREE(pivs);                \
        -:   31:    SPEX_FREE(row_perm);            \
        -:   32:
        -:   33:#define SPEX_FREE_ALL               \
        -:   34:    SPEX_FREE_WORK                  \
        -:   35:    SPEX_matrix_free(&L, NULL);     \
        -:   36:    SPEX_matrix_free(&U, NULL);     \
        -:   37:    SPEX_matrix_free(&rhos, NULL);  \
        -:   38:    SPEX_FREE(pinv);
        -:   39:
        -:   40:#include "spex_left_lu_internal.h"
        -:   41:
     1883:   42:SPEX_info SPEX_Left_LU_factorize
        -:   43:(
        -:   44:    // output:
        -:   45:    SPEX_matrix **L_handle,    // lower triangular matrix
        -:   46:    SPEX_matrix **U_handle,    // upper triangular matrix
        -:   47:    SPEX_matrix **rhos_handle, // sequence of pivots
        -:   48:    int64_t **pinv_handle,     // inverse row permutation
        -:   49:    // input:
        -:   50:    const SPEX_matrix *A,      // matrix to be factored
        -:   51:    const SPEX_LU_analysis *S, // column permutation and estimates
        -:   52:                               // of nnz in L and U 
        -:   53:    const SPEX_options* option // command options
        -:   54:)
        -:   55:{
        -:   56:
        -:   57:    //--------------------------------------------------------------------------
        -:   58:    // check inputs
        -:   59:    //--------------------------------------------------------------------------
        -:   60:
    1883*:   61:    if (!spex_initialized ( )) return (SPEX_PANIC) ;
        -:   62:
    1883*:   63:    SPEX_REQUIRE (A, SPEX_CSC, SPEX_MPZ) ;
        -:   64:    int64_t anz;
        -:   65:    // SPEX enviroment is checked to be init'ed and A is a SPEX_CSC matrix that
        -:   66:    // is not NULL, so SPEX_matrix_nnz must return SPEX_OK
     1883:   67:    SPEX_info info = SPEX_matrix_nnz (&anz, A, option) ;
        -:   68:    ASSERT(info == SPEX_OK);
        -:   69:
     1883:   70:    if (!L_handle || !U_handle || !rhos_handle || !pinv_handle || !S || anz < 0)
        -:   71:    {
        2:   72:        return SPEX_INCORRECT_INPUT;
        -:   73:    }
        -:   74:
     1881:   75:    (*L_handle) = NULL ;
     1881:   76:    (*U_handle) = NULL ;
     1881:   77:    (*rhos_handle) = NULL ;
     1881:   78:    (*pinv_handle) = NULL ;
        -:   79:
        -:   80:    //--------------------------------------------------------------------------
        -:   81:    // Declare and initialize workspace
        -:   82:    //--------------------------------------------------------------------------
        -:   83:
     1881:   84:    SPEX_matrix *L = NULL ;
     1881:   85:    SPEX_matrix *U = NULL ;
     1881:   86:    SPEX_matrix *rhos = NULL ;
     1881:   87:    int64_t *pinv = NULL ;
     1881:   88:    int64_t *xi = NULL ;
     1881:   89:    int64_t *h = NULL ;
     1881:   90:    int64_t *pivs = NULL ;
     1881:   91:    int64_t *row_perm = NULL ;
     1881:   92:    SPEX_matrix *x = NULL ;
        -:   93:
     1881:   94:    int64_t n = A->n ;
        -:   95:
     1881:   96:    int64_t k = 0, top, i, j, col, loc, lnz = 0, unz = 0, pivot, jnew ;
        -:   97:    size_t size ;
        -:   98:
        -:   99:    // Inverse pivot ordering
     1881:  100:    pinv = (int64_t *) SPEX_malloc (n * sizeof (int64_t)) ;
        -:  101:
        -:  102:    // Indicator of which rows have been pivotal
        -:  103:    // pivs[i] = 1 if row i has been selected as a pivot
        -:  104:    // row, otherwise, pivs[i] < 0
     1881:  105:    pivs = (int64_t*) SPEX_malloc(n* sizeof(int64_t));
        -:  106:
        -:  107:    // h is the history vector utilized for the sparse REF
        -:  108:    // triangular solve algorithm. h serves as a global
        -:  109:    // vector which is repeatedly passed into the triangular
        -:  110:    // solve algorithm
     1881:  111:    h = (int64_t*) SPEX_malloc(n* sizeof(int64_t));
        -:  112:
        -:  113:    // xi is the global nonzero pattern vector. It stores
        -:  114:    // the pattern of nonzeros of the kth column of L and U
        -:  115:    // for the triangular solve.
     1881:  116:    xi = (int64_t*) SPEX_malloc(2*n* sizeof(int64_t));
        -:  117:
        -:  118:    // Actual row permutation, the inverse of pinv. This
        -:  119:    // is used for sorting
     1881:  120:    row_perm = (int64_t*) SPEX_malloc(n* sizeof(int64_t));
        -:  121:
     1881:  122:    if (!pivs || !h || !xi || !row_perm || !pinv)
        -:  123:    {
        -:  124:        // out of memory: free everything and return
       40:  125:        SPEX_FREE_ALL  ;
       40:  126:        return SPEX_OUT_OF_MEMORY;
        -:  127:    }
        -:  128:
        -:  129:    // initialize workspace and pivot status
     9722:  130:    for (i = 0; i < n; i++)
        -:  131:    {
     7881:  132:        h[i] = -1;
     7881:  133:        pivs[i] = -1;
        -:  134:        // Initialize location based vectors
     7881:  135:        pinv[i] = i;
     7881:  136:        row_perm[i] = i;
        -:  137:    }
        -:  138:
        -:  139:    //--------------------------------------------------------------------------
        -:  140:    // Declare memory for rhos, L, and U
        -:  141:    //--------------------------------------------------------------------------
        -:  142:
        -:  143:    // Create rhos, a global dense mpz_t matrix of dimension n*1
     1841:  144:    SPEX_CHECK (SPEX_matrix_allocate(&rhos, SPEX_DENSE, SPEX_MPZ, n, 1, n,
        -:  145:        false, false, option));
        -:  146:
        -:  147:    // Allocate L and U without initializing each entry.
        -:  148:    // L and U are allocated to have nnz(L) which is estimated by the symbolic
        -:  149:    // analysis. However, unlike traditional matrix allocation, the second
        -:  150:    // boolean parameter here is set to false, so the individual values of
        -:  151:    // L and U are not allocated. Instead, a more efficient method to
        -:  152:    // allocate these values is done in the factorization to reduce
        -:  153:    // memory usage.
     1809:  154:    SPEX_CHECK (SPEX_matrix_allocate(&L, SPEX_CSC, SPEX_MPZ, n, n, S->lnz,
        -:  155:        false, false, option));
     1761:  156:    SPEX_CHECK (SPEX_matrix_allocate(&U, SPEX_CSC, SPEX_MPZ, n, n, S->unz,
        -:  157:        false, false, option));
        -:  158:
        -:  159:    //--------------------------------------------------------------------------
        -:  160:    // allocate and initialize the workspace x
        -:  161:    //--------------------------------------------------------------------------
        -:  162:
        -:  163:    // SPEX Left LU utilizes arbitrary sized integers which can grow beyond the
        -:  164:    // default 64 bits allocated by GMP. If the integers frequently grow, GMP
        -:  165:    // can get bogged down by performing intermediate reallocations. Instead,
        -:  166:    // we utilize a larger estimate on the workspace x vector so that computing
        -:  167:    // the values in L and U do not require too many extra intemediate calls to
        -:  168:    // realloc.
        -:  169:    //
        -:  170:    // Note that the estimate presented here is not an upper bound nor a lower
        -:  171:    // bound.  It is still possible that more bits will be required which is
        -:  172:    // correctly handled internally.
     1713:  173:    int64_t estimate = 64 * SPEX_MAX (2, ceil (log2 ((double) n))) ;
        -:  174:
        -:  175:    // Create x, a global dense mpz_t matrix of dimension n*1. Unlike rhos, the
        -:  176:    // second boolean parameter is set to false to avoid initializing
        -:  177:    // each mpz entry of x with default size.  It is intialized below.
     1713:  178:    SPEX_CHECK (SPEX_matrix_allocate(&x, SPEX_DENSE, SPEX_MPZ, n, 1, n,
        -:  179:        false, /* do not initialize the entries of x: */ false, option));
        -:  180:
        -:  181:    // initialize the entries of x
     8842:  182:    for (i = 0; i < n; i++)
        -:  183:    {
        -:  184:        // Allocate memory for entries of x
     7193:  185:        SPEX_CHECK(SPEX_mpz_init2(x->x.mpz[i], estimate));
        -:  186:    }
        -:  187:
        -:  188:    //--------------------------------------------------------------------------
        -:  189:    // Iterations 0:n-1 (1:n in standard)
        -:  190:    //--------------------------------------------------------------------------
        -:  191:
     4060:  192:    for (k = 0; k < n; k++)
        -:  193:    {
        -:  194:        // Column pointers for column k of L and U
     3665:  195:        L->p[k] = lnz;
     3665:  196:        U->p[k] = unz;
     3665:  197:        col = S->q[k];
        -:  198:
        -:  199:        //----------------------------------------------------------------------
        -:  200:        // Reallocate memory if necessary
        -:  201:        // if lnz+n > L->nzmax, L needs to expand to accomodate new nonzeros.
        -:  202:        // To do so, we double the size of the L and U matrices.
        -:  203:        //----------------------------------------------------------------------
     3665:  204:        if (lnz + n > L->nzmax)
        -:  205:        {
        -:  206:            // Double the size of L
      500:  207:            SPEX_CHECK(spex_sparse_realloc(L));
        -:  208:        }
     3655:  209:        if (unz + n > U->nzmax)
        -:  210:        {
        -:  211:            // Double the size of U
      450:  212:            SPEX_CHECK(spex_sparse_realloc(U));
        -:  213:        }
        -:  214:
        -:  215:        //----------------------------------------------------------------------
        -:  216:        // Triangular solve to compute LDx = A(:,k)
        -:  217:        //----------------------------------------------------------------------
     3645:  218:        SPEX_CHECK(spex_left_lu_ref_triangular_solve(&top, L, A, k, xi,
        -:  219:            (const int64_t *) (S->q),
        -:  220:            rhos,
        -:  221:            (const int64_t *) pinv,
        -:  222:            (const int64_t *) row_perm,
        -:  223:            h, x)) ;
        -:  224:
        -:  225:        //----------------------------------------------------------------------
        -:  226:        // Obtain pivot
        -:  227:        //----------------------------------------------------------------------
     3626:  228:        SPEX_CHECK(spex_left_lu_get_pivot(&pivot, x, pivs, n, top, xi,
        -:  229:            col, k, rhos, pinv, row_perm, option));
        -:  230:
        -:  231:        //----------------------------------------------------------------------
        -:  232:        // Populate L and U. We iterate across all nonzeros in x
        -:  233:        //----------------------------------------------------------------------
    38833:  234:        for (j = top; j < n; j++)
        -:  235:        {
    36422:  236:            jnew = xi[j];
        -:  237:            // Location of x[j] in final matrix
    36422:  238:            loc = pinv[jnew];
        -:  239:
        -:  240:            //------------------------------------------------------------------
        -:  241:            // loc <= k are rows above k, thus go to U
        -:  242:            //------------------------------------------------------------------
    36422:  243:            if (loc <= k)
        -:  244:            {
        -:  245:                // Place the i location of the unz nonzero
    21544:  246:                U->i[unz] = jnew;
        -:  247:                // Find the size in bits of x[j]
   21544*:  248:                SPEX_CHECK(SPEX_mpz_sizeinbase(&size, x->x.mpz[jnew], 2));
        -:  249:                // GMP manual: Allocated size should be size+2
    21544:  250:                SPEX_CHECK(SPEX_mpz_init2(U->x.mpz[unz], size+2));
        -:  251:                // Place the x value of the unz nonzero
   21504*:  252:                SPEX_CHECK(SPEX_mpz_set(U->x.mpz[unz], x->x.mpz[jnew]));
        -:  253:                // Increment unz
    21504:  254:                unz++;
        -:  255:            }
        -:  256:
        -:  257:            //------------------------------------------------------------------
        -:  258:            // loc >= k are rows below k, thus go to L
        -:  259:            //------------------------------------------------------------------
    36382:  260:            if (loc >= k)
        -:  261:            {
        -:  262:                // Place the i location of the lnz nonzero
    17319:  263:                L->i[lnz] = jnew;
        -:  264:                // Set the size of x[j]
   17319*:  265:                SPEX_CHECK(SPEX_mpz_sizeinbase(&size, x->x.mpz[jnew], 2));
        -:  266:                // GMP manual: Allocated size should be size+2
    17319:  267:                SPEX_CHECK(SPEX_mpz_init2(L->x.mpz[lnz], size+2));
        -:  268:                // Place the x value of the lnz nonzero
   17279*:  269:                SPEX_CHECK(SPEX_mpz_set(L->x.mpz[lnz], x->x.mpz[jnew]));
        -:  270:                // Increment lnz
    17279:  271:                lnz++;
        -:  272:            }
        -:  273:        }
        -:  274:    }
        -:  275:
        -:  276:    // Finalize L->p, U->p
      395:  277:    L->p[n] = lnz;
      395:  278:    U->p[n] = unz;
        -:  279:
        -:  280:    //--------------------------------------------------------------------------
        -:  281:    // Free memory
        -:  282:    //--------------------------------------------------------------------------
        -:  283:
        -:  284:    // free everything, but keep L, U, rhos, and pinv
      395:  285:    SPEX_FREE_WORK ;
        -:  286:
        -:  287:    // This cannot fail since the size of L and U are shrinking.
        -:  288:    // Collapse L
      395:  289:    spex_sparse_collapse(L);
        -:  290:    // Collapse U
      395:  291:    spex_sparse_collapse(U);
        -:  292:
        -:  293:    //--------------------------------------------------------------------------
        -:  294:    // finalize the row indices in L and U
        -:  295:    //--------------------------------------------------------------------------
        -:  296:
        -:  297:    // Permute entries in L
    16864:  298:    for (i = 0; i < lnz; i++)
        -:  299:    {
    16469:  300:        L->i[i] = pinv[L->i[i]];
        -:  301:    }
        -:  302:    // Permute entries in U
    21333:  303:    for (i = 0; i < unz; i++)
        -:  304:    {
    20938:  305:        U->i[i] = pinv[U->i[i]];
        -:  306:    }
        -:  307:
        -:  308:    //--------------------------------------------------------------------------
        -:  309:    // check the LU factorization (debugging only)
        -:  310:    //--------------------------------------------------------------------------
        -:  311:
        -:  312:    #if 0
        -:  313:    SPEX_CHECK (SPEX_matrix_check (L, option)) ;
        -:  314:    SPEX_CHECK (SPEX_matrix_check (U, option)) ;
        -:  315:    #endif
        -:  316:
        -:  317:    //--------------------------------------------------------------------------
        -:  318:    // return result
        -:  319:    //--------------------------------------------------------------------------
        -:  320:
      395:  321:    (*L_handle) = L ;
      395:  322:    (*U_handle) = U ;
      395:  323:    (*rhos_handle) = rhos ;
      395:  324:    (*pinv_handle) = pinv ;
      395:  325:    return (SPEX_OK) ;
        -:  326:}
        -:  327:
